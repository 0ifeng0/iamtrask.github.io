<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>i am trask</title>
    <description>Write your site description here. It will be used as your sites meta description as well!</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 03 Jan 2017 13:50:16 +0000</pubDate>
    <lastBuildDate>Tue, 03 Jan 2017 13:50:16 +0000</lastBuildDate>
    <generator>Jekyll v3.3.1</generator>
    
      <item>
        <title>Free is not Freedom</title>
        <description>&lt;h2 class=&quot;section-heading&quot;&gt;The &quot;free&quot; internet is not free.&lt;/h2&gt;

&lt;p&gt;Google is not free. Facebook is not free. Twitter is not free. These three entities (and many thousands more…) exist because they are able to do one thing: &lt;br /&gt;&lt;/p&gt;

&lt;center&gt;&lt;i&gt;Persuade users to buy more than it costs for them to operate.&lt;/i&gt;&lt;/center&gt;

&lt;p&gt;Not just a little more… so much more that both they AND the business buying the advertising can operate.&lt;/p&gt;

&lt;p&gt;In other words, you go on Facebook and are persuaded &lt;i&gt;against your will&lt;/i&gt; to buy enough junk to keep both Facebook and X other company… profitable.&lt;/p&gt;

&lt;h3 class=&quot;section-heading&quot;&gt;How much do I pay?&lt;/h3&gt;

&lt;p&gt;This clearly varies based on the effectiveness of varying mediums, but in terms of facebook, the ROI for advertising on the site&lt;a href=&quot;http://www.slate.com/articles/technology/technology/2013/03/facebook_advertisement_studies_their_ads_are_more_like_tv_ads_than_google.single.html&quot;&gt; averages around 3x &lt;/a&gt;. What does this mean? This means that companies who invest $250,000 in facebook ads can buy $750,000 worth of persuasion! Still thinking you're in control?&lt;/p&gt;

&lt;h3 class=&quot;section-heading&quot;&gt;The Grand Delusion: &quot;I chose to buy.&quot;&lt;/h3&gt;

&lt;p&gt;We need to wake up and realize that we are all suckers to the worlds in which we live. There is a multi-billion dollar industry that exists to exploit our sensitivies, the very traits that make us human. Furthermore, they're continually empowered with more and more detail about what makes our minds tick. From our entire friend network, to our location every waking minute of the day, to our emails, chat messages, purchases, and with the advent of Google Home &amp;amp; Amazon Echo, everything that goes on in our own homes.&lt;/p&gt;

&lt;p&gt;And for some reason, we still think that we're the ones behind the wheel of our own purchases! Check out this advertisement below. Look familiar?&lt;/p&gt;

&lt;hr /&gt;

&lt;script async=&quot;&quot; src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;

&lt;!-- Part 1 --&gt;
&lt;p&gt;&lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px;text-align:center&quot; data-ad-client=&quot;ca-pub-6751104560361558&quot; data-ad-slot=&quot;2365390629&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;How to protect yourself&lt;/h2&gt;

&lt;p&gt;In short, get &lt;a href=&quot;https://chrome.google.com/webstore/detail/adblock/gighmmpiobklfepjocnamgkkbiglidom&quot;&gt;AdBlock&lt;/a&gt; and spend less online on crap you don’t need.&lt;/p&gt;

</description>
        <pubDate>Mon, 02 Jan 2017 12:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/01/02/free-is-not-freedom/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/01/02/free-is-not-freedom/</guid>
        
        
      </item>
    
      <item>
        <title>Grokking Deep Learning</title>
        <description>&lt;p&gt;If you passed &lt;u&gt;high school math&lt;/u&gt; and can hack around in Python, &lt;u&gt;I want to teach you Deep Learning&lt;/u&gt;.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Edit: 50% Coupon Code:&lt;/b&gt; &quot;mltrask&quot; (expires August 26)&lt;/p&gt;

&lt;p&gt;I've decided to write a &lt;a href=&quot;https://www.manning.com/books/grokking-deep-learning&quot;&gt;Deep Learning book&lt;/a&gt; in the same style as my blog, teaching Deep Learning from an &lt;i&gt;intuitive&lt;/i&gt; perspective, all in Python, using only numpy. I wanted to make the &lt;b&gt;lowest possible barrier to entry&lt;/b&gt; to learn Deep Learning.&lt;/p&gt;

&lt;p&gt;Here's what you need to know:
&lt;div style=&quot;padding-left:50px&quot;&gt;• High School Math (basic algebra)&lt;br /&gt;
• Python... the basics&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;The Problem&lt;/b&gt; with most &lt;i&gt;entry level&lt;/i&gt; Deep Learning resources these days is that they either assume advanced knowledge of Calculus, Linear Algebra, Differential Equations, and perhaps even Convex Optimization, or they just teach a &quot;black box&quot; framework like Torch, Keras, or TensorFlow (where you just hit &quot;train&quot; but you don't actually know what's going on under the hood). Both have their appropriate audience, but I don't believe that either are appropriate for your average python hacker looking for a 101 on the fundamentals.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;My Solution&lt;/b&gt; is to teach Deep Learning from an &lt;i&gt;intuitive standpoint&lt;/i&gt;, just like I've done in the other posts on this blog. Everything you need to know to understand Deep Learning will be explained like you would to a &lt;u&gt;5 year old&lt;/u&gt;, including the bits and pieces of Linear Algebra and Calculus that are necessary. You'll learn how neural networks work, and how to use them to classify images, understand language (including machine translation), and even play games.&lt;/p&gt;

&lt;p&gt;At the time of writing, I think that this is the only Deep Learning resource that is taught this way. I hope you enjoy it.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Who This Book Is NOT For:&lt;/b&gt; people who would rather be taught using formulas. Individuals with advanced mathematical backgrounds should choose another resource. This book is for an introduction to Deep Learning. It's about lowering the barrier to entry.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.manning.com/books/grokking-deep-learning&quot;&gt;Click To See the Early Release Page (where the first three chapters are)&lt;/a&gt;&lt;/p&gt;

&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/shCore.css&quot; /&gt;

&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/shThemeDefault.css&quot; /&gt;

&lt;script src=&quot;/js/shCore.js&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;/js/shLegacy.js&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;/js/shBrushPython.js&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
	// SyntaxHighlighter.config.bloggerMode = true;
	SyntaxHighlighter.config.toolbar = true;
    SyntaxHighlighter.all();
&lt;/script&gt;

</description>
        <pubDate>Wed, 17 Aug 2016 13:00:00 +0100</pubDate>
        <link>http://localhost:4000/2016/08/17/grokking-deep-learning/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/08/17/grokking-deep-learning/</guid>
        
        
      </item>
    
      <item>
        <title>How to Code and Understand DeepMind's Neural Stack Machine</title>
        <description>&lt;p&gt;&lt;b&gt;Summary:&lt;/b&gt; I learn best with toy code that I can play with. This tutorial teaches &lt;a href=&quot;http://papers.nips.cc/paper/5648-learning-to-transduce-with-unbounded-memory.pdf&quot;&gt;DeepMind's Neural Stack&lt;/a&gt; machine via a very simple toy example, a short python implementation. I will also explain my thought process along the way for &lt;b&gt;reading and implementing research papers&lt;/b&gt; from scratch, which I hope you will find useful.&lt;/p&gt;

&lt;p&gt;I typically tweet out new blogposts when they're complete at &lt;a href=&quot;https://twitter.com/iamtrask&quot;&gt;@iamtrask&lt;/a&gt;. Feel free to follow if you'd be interested in reading more in the future and thanks for all the feedback!
&lt;/p&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;&lt;hr /&gt;Part 1: What is a Neural Stack?&lt;br /&gt;&lt;hr /&gt;&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;iframe width=&quot;700px&quot; height=&quot;440px&quot; src=&quot;https://www.youtube.com/embed/3DeL7utEz_k&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3&gt;A Simple Stack&lt;/h3&gt;
&lt;p&gt;Let's start with the definition of a regular stack before we get to a neural one. In computer science, a stack is a type of data structure. Before I explain it, let me just show it to you. In the code below, we &quot;stack&quot; a bunch of harry potter books on an (ascii art) table.&lt;/p&gt;

&lt;iframe src=&quot;https://trinket.io/embed/python/e887f17901&quot; width=&quot;100%&quot; height=&quot;600&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;Just like in the example above, picture yourself stacking Harry Potter books onto a table. A stack is pretty much the same as a list with one exception: &lt;i&gt;you can't add/remove a book to/from anywhere except the top&lt;/i&gt;. So, you can add another to the top ( stack.push(book) ) or you can remove a book from the top ( stack.pop() ), however you can't do anything with the books in the middle. &lt;b&gt;Pushing&lt;/b&gt; when we add a book to the top. &lt;b&gt;Popping&lt;/b&gt; is when we remove a book from the top (and perhaps do something with it :) )&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3&gt;A Neural Stack&lt;/h3&gt;
&lt;p&gt;
A close eye might ask, &quot;We learn things with neural networks. What is there to learn with a data structure? Why would you learn how to do what you can easily code?&quot; A neural stack is still just a stack. However, our neural network will learn &lt;b&gt;how to use the stack&lt;/b&gt; to implement an algorithm. It will learn &lt;b&gt;when to push and pop&lt;/b&gt; to correctly model output data given input data.
&lt;/p&gt;

&lt;center&gt;&lt;p&gt;&lt;b&gt;How will a neural network learn when to push and pop?&lt;/b&gt;&lt;/p&gt;&lt;/center&gt;

&lt;p&gt;A neural network will learn to push and pop using backpropgation. Certainly a pre-requisite to this blogpost is an intuitive understanding of neural networks and backpropagation in general. Everything in &lt;a href=&quot;http://iamtrask.github.io/2015/07/12/basic-python-network/&quot;&gt; this blogpost &lt;/a&gt;will be enough.&lt;/p&gt;

&lt;p&gt;So, how will a neural network learn when to push and pop? To answer this question, we need to understand what a &quot;correct sequence&quot; of pushing and popping would look like? And that's right... it's a &quot;sequence&quot; of pushing and popping. So, that means that our &lt;b&gt;input data&lt;/b&gt; and our correct &lt;b&gt;output data&lt;/b&gt; will both be sequences. So, what kinds of sequences are stacks good at modeling?&lt;/p&gt;

&lt;iframe src=&quot;https://trinket.io/embed/python/3e7f031729?start=result&quot; width=&quot;100%&quot; height=&quot;600&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;When we push a sequence onto a stack, and then pop that sequence off of the stack. The squence pops off in &lt;b&gt;reverse order&lt;/b&gt; to the original sequence that was pushed. So, if you have a sequence of 6 numbers, pushing 6 times and then popping 6 times is the &lt;b&gt;correct sequence&lt;/b&gt; of pushing and popping to reverse a list.&lt;/p&gt;

&lt;h3&gt;...so What is a Neural Stack?&lt;/h3&gt;

&lt;p&gt;A Neural Stack is a stack that can learn to correctly accept a sequence of inputs, remember them, and then transform them according to a pattern learned from data. 

&lt;h3&gt;...and How Does It Learn?&lt;/h3&gt;

&lt;p&gt;A Neural Stack learns by: &lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;1)&lt;/b&gt; accepting input data, pushing and popping it according to when a neural network says to push and pop. This generates a sequence of output data (predictions).&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;2)&lt;/b&gt; Comparing the output data to the input data to see how much the neural stack &quot;missed&quot;.&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;3)&lt;/b&gt; Updating the neural network to more correctly push and pop next time. (using backpropagation)&lt;br /&gt;
&lt;br /&gt;

... so basically... just like every other neural network learns...
&lt;/p&gt;

&lt;p&gt;And now for the money question...&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Money Question:&lt;/b&gt; How does backpropagation learn to push and pop when the error is on the output of the stack and the neural network is on the input to the stack? Normally we backpropagate the error from the output of the network to the weights so that we can make a weight update. It seems like the stack is &quot;blocking&quot; the output from the decision making neural network (which controls the pushing and popping).&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Money Answer:&lt;/b&gt; We make the neural stack &quot;differentiable&quot;. If you haven't had calculus, the simplest way to think about it is that we will make the &quot;neural stack&quot; using a sequence of vector additions, subtractions, and multiplications. If we can figure out how to mimic the stack's behaviors using only these tools, then we will be able to backpropagate the error &lt;b&gt;through the stack&lt;/b&gt; just like we backpropagate it through a neural network's hidden layers. And it will be quite familiar to us! We're already used to backpropagating through sequences of additions, subtractions, and multiplications. Figuring out how to mimic the operations of a stack in a fully differentiable way was the hard part... which why Edward Grefenstette, Karl Moritz Hermann, Mustafa Suleyman, and Phil Blunsom are so brilliant!!!&lt;/p&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;&lt;hr /&gt;Part 2: Reading and Implementing Academic Papers&lt;br /&gt;&lt;hr /&gt;&lt;/h2&gt;
&lt;br /&gt;
&lt;iframe width=&quot;700px&quot; height=&quot;440px&quot; src=&quot;https://www.youtube.com/embed/P7LiUOd8kdg&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;br /&gt;
&lt;h3&gt;Where To Start....&lt;/h3&gt;
&lt;p&gt;As promised, I want to give a bit of &quot;meta-learning&quot; regarding how to approach implementing academic papers. So, pop open &lt;a href=&quot;http://arxiv.org/pdf/1506.02516v3.pdf&quot;&gt;this paper&lt;/a&gt; and have a look around. As a disclaimer, &lt;b&gt;there is no correct way&lt;/b&gt; to read academic papers. I wish only to share how I approached this one and why. Feel free to take any/all of it with a grain of salt. If you have lessons to add from experience, please comment on the hacker news or reddit posts if you came from there... or feel free to tweet &lt;a href=&quot;https://twitter.com/iamtrask&quot;&gt;@iamtrask&lt;/a&gt;. I'm happy to retweet good advice on this topic.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;First Pass:&lt;/b&gt; Most people I know start by just reading a paper start to finish. Don't try to understand everything. Just get the high level goal of what's being accomplished, the key vocabulary terms involved, and a sense of the approach. Don't worry too much about formulas. Take time to look at pictures and tables. This paper has lots of good ones, which is helpful too. :) If this paper were about how to build a car, this first pass is just about learning &quot;We're going to build a driving machine. It's going to be able to move and turn at 60 miles per hour down a curvy road. It runs on gasolean and has wheels. I think it will be driven by a human being.&quot; Don't worry about the alternator, transmission, or spark plugs... and certainly not the optimal temperature for combustion. Just get the general idea.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Second Pass:&lt;/b&gt; For the second pass, if you feel like you understand the background (which is always the first few sections... commonly labeled &quot;Introduction&quot; and &quot;Related Work&quot;), jump straight to the approach. In this paper the approach section starts with &quot;3 Models&quot; at the bottom of page 2. For this section, read each sentence &lt;b&gt;slowly&lt;/b&gt;. These sections are almost always &lt;b&gt;extremely&lt;/b&gt; dense. Each sentence is crafted with care, and without an understanding of each sentence in turn, the next might not make sense. At this point, still don't worry too much about the details of the formulas. Instead, just get an idea of the &quot;major moving parts&quot; in the algorithm. Focus on the &lt;b&gt;what&lt;/b&gt; not the &lt;b&gt;how&lt;/b&gt;. Again, if this were about building a car, this is about making a list of what each part is called and what it generally does like below... &lt;/p&gt;
&lt;style type=&quot;text/css&quot;&gt;
.tg  {border-collapse:collapse;border-spacing:0;border-color:#ccc;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#ccc;color:#333;background-color:#fff;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#ccc;color:#333;background-color:#f0f0f0;text-align:center;}
.tg .tg-5rcs{font-weight:bold;font-size:20px;}
.tg .tg-4kyz{font-size:20px;text-align:center;}
&lt;/style&gt;
&lt;center&gt;
&lt;table class=&quot;tg&quot;&gt;
  &lt;tr&gt;
    &lt;th class=&quot;tg-5rcs&quot; colspan=&quot;1&quot;&gt;Part Name&lt;/th&gt;
    &lt;th class=&quot;tg-5rcs&quot; colspan=&quot;1&quot;&gt;Variable&lt;/th&gt;
    &lt;th class=&quot;tg-5rcs&quot; colspan=&quot;1&quot;&gt;Description When First Reading&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;&quot;The Memory&quot;&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;V_t&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;Sortof like &quot;self.contents&quot; in our &lt;br /&gt;VerySimpleStack. This is where&lt;br /&gt; our stuff goes. More specifically, this is the state of our stack at timestep &quot;t&quot;.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;&quot;The Controller&quot;&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;?&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;The neural network that &lt;br /&gt; decides when to push or pop.&lt;/td&gt;    
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;&quot;Pop Signal&quot;&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;u_t&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;How much the controller wants to pop.&lt;/td&gt;
    
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;&quot;Push Signal&quot;&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;d_t&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;How much the controller wants to push.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;&quot;Strength Signal&quot;&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;s_t&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;Given u_t and d_t are real valued, it seems like we can push on or pop off &quot;parts&quot; of objects... &lt;br /&gt; This vector seems to keep up with how much of each variable we still  have in V (or V_t really).&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;&quot;Read Value&quot;&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;v_t&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;This seems to be made by combining s_t and V_t somehow.... so some sort of weighted average of what's on the stack... interesting....&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;&quot;Time&quot;&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;_t&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;This is attached to many of the variables... i think it means the state of that variable at a specific timestep in the sequence.&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/center&gt;
&lt;p&gt;As a sidenote, this is also a great time to create some mental pneumonics to remember which variable is which. In this case, since the &quot;u&quot; in &quot;u_t&quot; is open at the top... I thought that it looked like it has been &quot;popped&quot; open. It's also the &quot;pop signal&quot;. In contrast, &quot;d_t&quot; is closed on top and is the &quot;push signal&quot;. I found that this helped later when trying to read the formulas intuitively (which is the next step). If you don't know the variables by heart, it's really hard to figure out how they relate to each other in the formulas.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;N More Passes:&lt;/b&gt; At this point, you just keep reading the method section until you have your working implementation (which you can evaluate using the later sections). So, this is generally how to read the paper. :)&lt;br /&gt;&lt;br /&gt;

&lt;b&gt;Have Questions? Stuck? Feel free to tweet your question &lt;a href=&quot;https://twitter.com/iamtrask&quot;&gt;@iamtrask&lt;/a&gt; for help.&lt;/b&gt;&lt;/p&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;&lt;hr /&gt;Part 3: Building a Toy Neural Stack&lt;br /&gt;&lt;hr /&gt;&lt;/h2&gt;
&lt;br /&gt;
&lt;iframe width=&quot;700px&quot; height=&quot;440px&quot; src=&quot;https://www.youtube.com/embed/XhohuJzu-Lo&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;br /&gt;
&lt;h3&gt;Where To Start....&lt;/h3&gt;
&lt;p&gt;Ok, so we have a general idea of what's going on. Where do we start? I'm always tempted to just start coding the whole big thing but inevitably I get halfway through with bugs I'll never find again. So, a word from experience, break down each project into distinct, testable sections. In this case, the smallest testable section is the &quot;stack mechanism&quot; itself. Why? Well, the bottom of page 5 gives it away &quot;the three memory modules... contain no tunable parameters to optimize during training&quot;. In a word, they're deterministic. To me, this is always the easiest place to start. Debugging something with deterministic, constant behavior is always easier than debugging something you learn/optimize/constantly changes. Furthermore, the stack logic is at the core of the algorithm. Even better, Figure 1 section (a) gives its expected behavior which we can use as a sort of &quot;unit test&quot;. All of these things make this a great place to start. Let's jump right into understanding this portion by looking at the diagram of the stack's architecture.&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/neural_stack/neural_stack_picture.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;&lt;b&gt;What I'm Thinking When I See This:&lt;/b&gt; Ok... so we can push green vectors v_t onto the stack. Each yellow bubble on the right of each green v_t looks like it coresponds to the weight of v_t in the stack... which can be 0 apparently (according to the far right bubble). So, even though there isn't a legend, I suspect that the yellow circles are infact s_t. This is very useful. Furthermore, it looks like the graphs go from left to right. So, this is 3 timesteps. t=1, t=2, and t=3. Great. I think I see what's going on.&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/neural_stack/neural_stack_formulas.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;&lt;b&gt;What I'm Thinking:&lt;/b&gt; Ok. I can line up the formulas with the picture above. The first formula sets each row of V_t which are the green bubbles. The second formula determines each row of s_t, which are the yellow bubbles. The final formula doesn't seem to be pictured above but I can see what its values are given the state of the stack. (e.g. r_3 = 0.9 * v_3 + 0 * v_2 + 0.1 * v_1) Now, what are these formulas really saying?&lt;/p&gt;

&lt;p&gt;So, what we're going to try to do here is &quot;tell the story&quot; of each part of each formula in our head. Let's start with the first formula (1) which seems the least intimidating.&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/neural_stack/neural_stack_formulas_1.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;See the part circled in blue above? Notice that it's indexed by &lt;b&gt;two&lt;/b&gt; numbers, t, and i. I actually overlooked this at first and it came back to bite me. V_t is the state of our stack's memory at time t. We can see its state in the picture at t=1, t=2, and t=3. However, at each timestep, the memory can have more than one value v_t inside of it! This will have significant implications for the code later (and the memory overhead).&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Bottom Line:&lt;/b&gt; If V_t is the state of the stack's memory at time &quot;t&quot;, then V is a list of &lt;b&gt;ALL&lt;/b&gt; of the memory states the stack goes through (at every timestep). So, V is a list of lists of vectors. (a vector is a list of numbers). In your head, you can think of this as the &lt;b&gt;shape&lt;/b&gt; of V. Make sure you can look away and tell yourself what the shapes of V, V_t, and V_t[i] are. You'll need that kind of information on the fly when you're reading the rest of the paper.&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/neural_stack/neural_stack_formulas_2.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;Ok, so this next section defines a conditional function. In this case, that means that the function is different depending on what value &quot;i&quot; takes on. If our variable &quot;i&quot; is greater than or equal to 1 AND is less than t, then V_t[i] = V_t-1[i]. If, on the other hand, &quot;i&quot; equals &quot;t&quot;, then V_t[i] = v_t.&lt;/p&gt;

&lt;p&gt;So, what story is this telling? What is really going on? Well, what are we combining to make V_t[i]? We're either using V_t-1 or v_t. That's interesting. Also, since &quot;i&quot; determines each row of the stack, and we've got &quot;if&quot; statements depending on &quot;i&quot;, that means that different rows of the stack are created differently. If &quot;i&quot; == &quot;t&quot;... which would be the newest member of the stack... then it's equal to some variable v_t. If not, hoever, then it seems like it equals whatever the previous timestep equaled at that row. Eureka!!!&lt;/p&gt;

&lt;p&gt;So, all this formula is really saying is... each row of V_t is the same as it was in the previous timestep EXCEPT for the newest row v_t... which we just added! This makes total sense given that we're building a stack! Also, when we look at the picture again, we see that each timestep adds a new row... which is curious.&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/neural_stack/neural_stack_picture.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;Interesting... so we ALWAYS add a row. We ALWAYS add v_t. That's very interesting. This sounds like we're always pushing. V_t has t rows. That must be why &quot;i&quot; can range from 1 to &quot;t&quot;. We have &quot;t&quot; rows for &quot;i&quot; to index.&lt;/p&gt;

&lt;p&gt;Take a deep breath. This formula is actually pretty simple, although there are a few things to note that could trip us up in the implementation. First, &quot;i&quot; doesn't seem to be defined at 0 (by &quot;not defined&quot; i mean that they didn't tell us what to do if i == 0... so what do we do?). To me, this means that the original implementation was probably written in Torch (Lua) instead of Theano (Python) because &quot;i&quot; seems to range from 1 to t (as opposed to 0 to t). &quot;i&quot; is an index into an array. In Lua, the first value in an array or list is at index 1. In Python (the language we're prototyping in), the first value in an array or list is at index 0. Thus, we'll need to compensate for the fact that we're coding this network in a different langauge from the original by subtracting 1 from each index. It's a simple fix but perhaps easy to miss.&lt;/p&gt;


&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/neural_stack/neural_stack_formulas_3.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;So, now that we finished the first formula, can you tell what shape s_t[i] is going to be? It's also indexed by both t and i. However, there's a key difference. The &quot;s&quot; is lowercased which means that s_t is a vector (whereas V_t was a list of vectors... e.g. a matrix). Since s_t is a vector, then s_t[i] is a value from that vector. So, what's the shape of &quot;s&quot;? It's a list of &quot;t&quot; vectors.It's a matrix. (I suppose V is technically a strange kind of tensor.)&lt;/p&gt;

&lt;pre class=&quot;brush: python&quot;&gt;

def s_t(i,t,u,d):
    if(i &amp;gt;= 0 and i &amp;lt; t):
        inner_sum = sum(s[t-1][i+1:t])
        out = max(0,s[t-1][i] - max(0,u[t] - (inner_sum)))
        return out
    elif(i == t):
        return d[t]
    else:
        print &quot;Undefined i -&amp;gt; t relationship&quot;

&lt;/pre&gt;

&lt;p&gt;When whe just do an exact representation of the function in code, we get the following function above.&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/neural_stack/neural_stack_formulas_4.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;This should be very familiar. Just like the first formula (1), formula (2) is also a conditional function based on &quot;i&quot; and &quot;t&quot;. They're the same conditions so I suppose there's no additional explanation here. Note that the same 1 vs 0 indexing discrepancy between Lua and Python applies here. In the code, this blue circle is modeled on &lt;b&gt;line 02.&lt;/b&gt;&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/neural_stack/neural_stack_formulas_5.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;So, we have two conditions that are identical as before. This means that the bottom part of the function (circled in blue) is only true if &quot;i&quot; == &quot;t&quot;. &quot;i&quot; only equals &quot;t&quot; when we're talking about the row corresponding to the newest vector on our stack. So, what's the value of s_t for the newest member of our stack? This is where we remember back to the definitions we wrote out earlier. s_t was the strength/weight of each vector on the stack. d_t was our pushing weight. s_t is the current strength. d_t is the weight we pushed it on the stack with.&lt;/p&gt;

&lt;p&gt;Pause here... try to figure it out for yourself. What is the relationship between s_t[i] and d_t when i == t?&lt;/p&gt;

&lt;p&gt;Aha! This makes sense! For the newest vector that we just put on the stack (V_t[t]), it is added to the stack with the &lt;b&gt;same weight&lt;/b&gt; (s_t[i]) that we &lt;b&gt;push&lt;/b&gt; it onto the stack with (d_t). That's brilliant! This also answers the question of why we push every time! &quot;not pushing&quot; just means &quot;pushing&quot; with a weight equal to 0! (e.g. d_t == 0) If we push with d_t equal to zero then the weight of that vector on the stack is also equal to 0. This section is represented on &lt;b&gt;line 07&lt;/b&gt; in the code.&lt;/p&gt;

&lt;pre class=&quot;brush: python&quot;&gt;

def s_t(i,t,u,d):
    if(i &amp;gt;= 0 and i &amp;lt; t):
        inner_sum = sum(s[t-1][i+1:t])
        out = max(0,s[t-1][i] - max(0,u[t] - (inner_sum)))
        return out
    elif(i == t):
        return d[t]
    else:
        print &quot;Undefined i -&amp;gt; t relationship&quot;

&lt;/pre&gt;



&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/neural_stack/neural_stack_formulas_6.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;Ok, now we're getting to the meat of a slightly more complicated formula. So, we're gong to break it into slightly smaller parts. I'm also re-printing the picture below to help you visualize the formula. This sum circled in blue sums from i+1 to t-1. Intuitively this is equivalent to summing &quot;all of the weights between s_t[i] and the top of the stack&quot;. Stop here. Make sure you have that in your head.&lt;/p&gt;

&lt;p&gt;Why t-1? Well, s_t-1 only runs to t-1. s_t-1[t] would overflow.&lt;/p&gt;
&lt;p&gt;Why i+1? Well, think about being at the bottom of the ocean. Imagine that s_t is measuring the amount of water at each level in the ocean. Imagine then that the sum circled in blue is measuring &quot;the weight of the water above me&quot;. I don't want to include the water even with me when measuring the &quot;sum total amount of water between me and the ocean's surface.&quot; Perhaps I only want to measure the water that's &quot;between me and the surface&quot;. That's why we start from i+1. I know that's kindof a silly analogy, but that's how I think about it in my head.&lt;/p&gt;
&lt;p&gt;So, what's circled in blue is &quot;the sum total amount of weight between the current strength and the top of the stack&quot;. We don't know what we're using it for yet, but just remember that for now.&lt;/p&gt;

&lt;pre class=&quot;brush: python&quot;&gt;

def s_t(i,t,u,d):
    if(i &amp;gt;= 0 and i &amp;lt; t):
        inner_sum = sum(s[t-1][i+1:t])
        out = max(0,s[t-1][i] - max(0,u[t] - (inner_sum)))
        return out
    elif(i == t):
        return d[t]
    else:
        print &quot;Undefined i -&amp;gt; t relationship&quot;

&lt;/pre&gt;

&lt;p&gt;In the code, this blue circle is represented on &lt;b&gt;line 03&lt;/b&gt;. It's stored in the variable &quot;inner_sum&quot;.&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/neural_stack/neural_stack_picture.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;Look below at the circle in the next image. This is only a slight modification to the previous circle. So, if the previous circle was &quot;the sum total amount of weight between the current strength adn the top of the stack&quot;, this is &lt;b&gt;&quot;u_t&quot; minus that weight&lt;/b&gt;. Remember what u_t was? It's our pop weight! So, this circle is &quot;the amount we want to pop MINUS the weight between the current index and the top of the stack&quot;. Stop here and make sure you can picture it.&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/neural_stack/neural_stack_formulas_7.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;
What does the blue circle above mean intuitively? Let's try the ocean floor analogy again except this time the ocean is dirt. You're buried alive. The sum from before is the sum total amount of weight above you. It's the sum total of all the dirt above you. u_t is the amount of dirt that can be &quot;popped&quot; off. So, if you're popping more than the amount of dirt above you, then this blue circle returns a positive number. You'll be uncovered! You'll be free! However, if u_t is smaller than the amount of dirt above you, then you'll still be buried. The circle will return &quot;-1 * amount_of_dirt_still_above_me&quot;. This circle determines how deep in the dirt you are after dirt was popped off. Negative numbers mean you're still buried. Positive numbers mean you're above the ground. The next circle will reveal more about this. Stop and make sure you've got this in your head.
&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/neural_stack/neural_stack_formulas_8.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;Now instead of picturing yourself as being under the ground, picture yourself as a gold digger from above ground. You're wanting to figure out how far you have to dig to get to some gold. You ask yourself, &quot;if I did 10 meters, how much (if any) gold will I get). u_t is the 10 meters you're digging. The sum previously discussed is the distance from the gold to the surface of the ground. In this case, if u_t - the sum is negative, then you get no gold. If it is positive, then you get gold. That's why we take the max. At each level, we want to know if that vector will be popped off at all. Will the gold at that level be &quot;removed&quot; by popping &quot;u_t&quot; distance. Thus, this circle takes the &quot;max between the difference and 0&quot; so that the output is either &quot;how much gold we get&quot; or &quot;0&quot;. The output is either &quot;we're popping off this much&quot; or it's &quot;0&quot;. So, the &quot;max&quot; represents how much we have left to &quot;pop&quot; at the current depth in the stack. Stop here and make sure you've got this in your head.&lt;/p&gt;

&lt;pre class=&quot;brush: python&quot;&gt;

def s_t(i,t,u,d):
    if(i &amp;gt;= 0 and i &amp;lt; t):
        inner_sum = sum(s[t-1][i+1:t])
        out = max(0,s[t-1][i] - max(0,u[t] - (inner_sum)))
        return out
    elif(i == t):
        return d[t]
    else:
        print &quot;Undefined i -&amp;gt; t relationship&quot;

&lt;/pre&gt;

&lt;p&gt;Can you see the second &quot;max&quot; function on &lt;b&gt;line 04&lt;/b&gt;. It is the code equivalent of the circled function above&lt;/p&gt;.

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/neural_stack/neural_stack_formulas_9.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;Almost there! So, if the max from the previous circle indicates &quot;whether u_t is large enough to pop this row off (and if so how much of it)&quot;, then s_t-1[i] - that number is how much we have left after popping.&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/neural_stack/neural_stack_formulas_10.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;If the previous circle was &quot;how much left we have after popping&quot;, then this just guarantees that we can only have a positive amount left, which is exactly the desirable property. So, this function is really saying: given how much we're popping off at this time step (u_t), and how much is between this row and the top of the stack, how much weight is left in this row? Note that u_t doesn't have any affect if i == t. (It has no affect on how much we push on d_t) This means that we're popping before we push at each timestep. Stop here and make sure this makes sense in your head.&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/neural_stack/neural_stack_picture.png&quot; alt=&quot;&quot; /&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/neural_stack/neural_stack_formulas_11.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;And now onto the third formula! This sum should look very familiar. The only difference between this sum and the sum in function (2) is that in this function we sum all the way to &quot;t&quot; instead of stopping at &quot;t-1&quot;. This means that we're including the most recently pushed strength (s_t) in the sum. Previously we did not.&lt;/p&gt;
&lt;pre class=&quot;brush: python&quot;&gt;
def r_t(t):
    r_t_out = np.zeros(stack_width)
    for i in xrange(0,t+1):
        temp = min(s[t][i],max(0,1 - sum(s[t][i+1:t+1])))
        r_t_out += temp * V[t][i]
    return r_t_out
&lt;/pre&gt;

&lt;p&gt;The circled sum above is represented with the &quot;sum&quot; function on &lt;b&gt;line 04&lt;/b&gt; of this code. The circled (1 - sum) immediately below this paragraph is equivalent to the (1 - sum) on &lt;b&gt;line 04&lt;/b&gt;.&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/neural_stack/neural_stack_formulas_12.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;This &quot;1&quot; means a lot more than you might think. As a sneak peek, this formula is reading from the stack. How many vectors is it reading? It's reading &quot;1&quot; deep into the stack. The previous sum calculates (for every row of s_t) the sum of all the weights above it in the stack. The sum calculates the &quot;depth&quot; if you were of each strength at index &quot;i&quot;. Thus, 1 minus that strength calculates what's &quot;left over&quot;. This difference will be positive for s_t[i] values that are less than 1.0 units deep in the stack. It will be negative for s_t[i] values that are deeper in the stack.&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/neural_stack/neural_stack_formulas_13.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;Taking the max of the previous circle guarantees that it's positive. The previous circle was negative for s_t[i] values that were deeper in the stack than 1.0. Since we're only interested in reading values up to 1.0 deep in the stack, all the weights for deeper values in the stack will be 0.&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/neural_stack/neural_stack_formulas_14.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;If the previous circle returned 1 - the sum of the weights above a layer in the stack, then it guarantees that the weight is 0 if the layer is too deep. However, if the vector is much shallower than 1.0, the previous circle would return a very positive number (perhaps as high as 1 for the vector at the top). This min function guarantees that the weight at this level doesn't exceed the strength that was pushed onto this level s_t[i].&lt;/p&gt;

&lt;pre class=&quot;brush: python&quot;&gt;
def r_t(t):
    r_t_out = np.zeros(stack_width)
    for i in xrange(0,t+1):
        temp = min(s[t][i],max(0,1 - sum(s[t][i+1:t+1])))
        r_t_out += temp * V[t][i]
    return r_t_out
&lt;/pre&gt;

&lt;p&gt;So, the circle in the image above is represented as the variable &quot;temp&quot; created on &lt;b&gt;line 04&lt;/b&gt;. The circled section below is the output of the entire function, stored as &quot;r_t_out&quot;.

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/neural_stack/neural_stack_formulas_15.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;So, what does this function do? It performs a weighted sum over the entire stack, multiplying each vector by s_t, if that vector is less than 1.0 depth into the stack. In other words, it reads the top 1.0 weight off of the stack by performing a weighted sum of the vectors, weighted by s_t. This is the vector that is read at time t and put into the variable r_t.&lt;/p&gt;

&lt;h3&gt;Writing the Code&lt;/h3&gt;

&lt;p&gt;Ok, so now we have an intuitive understanding of what these formulas are doing. Where do we start coding? Recall the following figure.&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/neural_stack/neural_stack_picture.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;Let's recreate this behavior given the values of u_t, d_t, and r_t above. Remember that many of the &quot;time indices&quot; will be decreased by 1 relative to the Figure 1 above because we're working in Python (instead of Lua).&lt;/p&gt;

&lt;iframe src=&quot;https://trinket.io/embed/python/6efe1b68ad?start=result&quot; width=&quot;100%&quot; height=&quot;600&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;So, at risk of re-explaining all of the logic above, I'll point to which places in the code correspond to each function.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Lines 1 - 18&lt;/b&gt; initialize all of our variables. v_0, v_1, and v_2 correspond to v_1, v_2, and v_3 in the picture of a stack operating. I made them be the rows of the identity matrix so that they'd be easy to see inside the stack. v_0 has a 1 in the first position (and zeros everywhere else). v_1 has a 1 in the second position, and v_2 has a 1 in the third position.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Lines 13-17&lt;/b&gt; create our basic stack variables... all indexed by &quot;t&quot;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Lines 19-24&lt;/b&gt; correspond to function (3).&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Lines 26-33&lt;/b&gt; correspond to function (2).&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Lines 35-56&lt;/b&gt; performs a push and pop operation on our stack&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Lines 45-55&lt;/b&gt; correspond to function (1). Notice that function (1) is more about how to create V_t given V_t-1.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Lines 58-60&lt;/b&gt; run and print out the exact operations in the picture from the paper. Follow along to make sure you see the data flow!&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Lines 62-66&lt;/b&gt; reset the stack variables so we can make sure we got the outputs correct (by making sure they equal the values from the paper)&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Lines 68-70&lt;/b&gt; assert that the operations from the graph in the paper produce the correct results&lt;/p&gt;

&lt;b&gt;Have Questions? Stuck? Feel free to tweet your question &lt;a href=&quot;https://twitter.com/iamtrask&quot;&gt;@iamtrask&lt;/a&gt; for help.&lt;/b&gt;&lt;/p&gt;


&lt;h2 class=&quot;section-heading&quot;&gt;&lt;hr /&gt;Part 4: Learning A Sequence&lt;br /&gt;&lt;hr /&gt;&lt;/h2&gt;
&lt;br /&gt;
&lt;iframe width=&quot;700px&quot; height=&quot;440px&quot; src=&quot;https://www.youtube.com/embed/kO5LfoPBWDQ&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;br /&gt;
&lt;p&gt;In the last section, we learned the intuitions behind the neural stack mechanism's formulas. We then constructed those exact formulas in python code and validated that they behaved identically to the example laid out in Figure 1 (a) of the paper. In this section, we're going to dig further into how the neural stack works. We will then teach our neural stack to learn a single sequence using backpropagation.&lt;/p&gt;

&lt;h3&gt;Let's Revisit How The Neural Stack Will Learn&lt;/h3&gt;

&lt;p&gt;In Part 2, we discussed how the neural stack is unique in that we can backpropgate error from the output of the stack back through to the input. The reason we can do this is that the stack is fully differentiable. (For background on determining whether a function is differentiable, please see &lt;a href=&quot;https://www.youtube.com/watch?v=pj1VvscsV0s&quot;&gt; Khan Academy &lt;/a&gt;. For more on derivatives and differentiability, see the rest of that tutorial.) Why do we care that the stack (as a function) is differentiable? Well, we used the &quot;derivative&quot; of the function to move the error around (more specifically... to backpropagate). For more on this, please see the &lt;a href=&quot;http://iamtrask.github.io/2015/07/12/basic-python-network/&quot;&gt;Tutorial I Wrote on Basic Neural Networks&lt;/a&gt;, &lt;a href=&quot;https://iamtrask.github.io/2015/07/27/python-network-part2/&quot;&gt; Gradient Descent&lt;/a&gt;, and &lt;a href=&quot;https://iamtrask.github.io/2015/11/15/anyone-can-code-lstm/&quot;&gt;Recurrent Neural Networks&lt;/a&gt;. I particularly recommend the last one because it demontrates backpropgating through somewhat more arbitrary vector operations... kindof like what we're going to do here. :)&lt;/p&gt;

&lt;p&gt;Perhaps you might say, &quot;Hey Andrew, pre-requisite information is all nice and good... but I'd like a little bit more intuition on why this stack is differentiable&quot;. Let me try to simplify most of it to a few easy to use rules. Backpropagation is really about credit attribution. It's about the neural network saying &quot;ok... I messed up. I was supposed to predict 1.0 but i predicted 0.9. What parts of the function caused me to do this? What parts can I change to better predict 1.0 next time?&quot;. Consider this problem.&lt;/p&gt;

&lt;pre class=&quot;brush: python&quot;&gt;
y = a + b
&lt;/pre&gt;

&lt;p&gt;What if I told you that when we ran this equation, y ended up being a little bit too low. It should have been 1.0 and it was 0.9. So, the error was &lt;b&gt;0.1&lt;/b&gt;. Where did the error come from? Clearly. It came from both a and b equally. So, this gives us an early rule of thumb. When we're summing two variables into another variable. The error is divided evenly between the sum... becuase it's both their faults that it missed! This is a gross oversimplification of calculus, but it helps me remember how to do the chain rule in code on the fly... so I dunno. I find it helpful... at least as a pneumonic. Let's look at another problem.&lt;/p&gt;

&lt;pre class=&quot;brush: python&quot;&gt;
y = a + 2*b
&lt;/pre&gt;

&lt;p&gt;Same question. Different answer. In this case, the error is 2 times more significant because of b. So remember, when you are multiplying in the function, you have to multiply the error at any point by what that point was multiplied by. So, if the error at y is 0.1. The error at a is 0.1 and the error at b is 2 * 0.1 = 0.2. By the way, this generalizes to vector addition and multiplication as well. Consider in your head why the error would be twice as significant at b. Y is twice as sensitive to changes in b!&lt;/p&gt;

&lt;pre class=&quot;brush: python&quot;&gt;
y = a*b
&lt;/pre&gt;

&lt;p&gt;Ok, last one for now. If you compute 0.1 error at y, what is the error at a. Well, we can't really know without knowing what b is because b is determining how sensitive y is to a. Funny enough the reverse is also true. a is determining how sensitive y is to b! So, let's take this simple intuition and reflect on our neural stack in both the formal math functions and the code. (Btw, there are many more rules to know in Calculus, and I highly recommend taking a course on it from Coursera or Khan Academy, but these rules should pretty much get you through the Neural Stack)&lt;/p&gt;

&lt;pre class=&quot;brush: python&quot;&gt;
def s_t(i,t,u,d):
    if(i &amp;gt;= 0 and i &amp;lt; t):
        inner_sum = sum(s[t-1][i+1:t])
        out = max(0,s[t-1][i] - max(0,u[t] - (inner_sum)))
        return out
    elif(i == t):
        return d[t]
    else:
        print &quot;Undefined i -&amp;gt; t relationship&quot;

def r_t(t):
    r_t_out = np.zeros(stack_width)
    for i in xrange(0,t+1):
        temp = min(s[t][i],max(0,1 - sum(s[t][i+1:t+1])))
        r_t_out += temp * V[t][i]
    return r_t_out

&lt;/pre&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/neural_stack/neural_stack_formulas.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;Read through each formula. What if the output of our python function r_t(t) was supposed to be 1.0 and it returned 0.9. We would (again) have an error of &lt;b&gt;0.1&lt;/b&gt;. Conceptually, this means we read our stack (by calling the function r_t(t)) and got back a number that was a little bit too low. So, can you see how we can take the simple rules above and move the error (0.1) from the output of the function (line 16) back through to the various inputs? In our case, those inputs include global variables s and V. It's really not any more complicated than the 3 rules we identified above! It's just a long chain of them. This would end up putting error onto s and V. This puts error onto the stack! I find this concept really fascinating. Error in memory! It's like telling the network &quot;dude... you remembered the wrong thing man! Remember something more relevant next time!&quot;. Pretty sweet stuff.&lt;/p&gt;

&lt;p&gt;So, if we were to code up this error attribution... this backpropagation. It would look like the following.&lt;/p&gt;

&lt;pre class=&quot;brush: python&quot;&gt;
def s_t_error(i,t,u,d,error):
    if(i &amp;gt;= 0 and i &amp;lt; t):
        if(s_t(i,t,u,d) &amp;gt;= 0):
            s_delta[t-1][i] += error
            if(max(0,u[t] - np.sum(s[t-1][i+1:t-0])) &amp;gt;= 0):
                u_delta[t] -= error
                s_delta[t-1][i+1:t-0] += error
    elif(i == t):
        d_delta[t] += error
    else:
        print &quot;Problem&quot;

def r_t_error(t,r_t_error):
    for i in xrange(0, t+1):
        temp = min(s[t][i],max(0,1 - np.sum(s[t][i+1:t+1])))
        V_delta[t][i] += temp * r_t_error
        temp_error = np.sum(r_t_error * V[t][i])
    
        if(s[t][i] &amp;lt; max(0,1 - np.sum(s[t][i+1:t+1]))):
            s_delta[t][i] += temp_error
        else:
            if(max(0,1 - np.sum(s[t][i+1:t+1])) &amp;gt; 0):
                s_delta[t][i+1:t+1] -= temp_error # minus equal because of the (1-).. and drop the 1
&lt;/pre&gt;

&lt;p&gt;Notice that I have variables V_delta, u_delta, and s_delta that I put the &quot;errors&quot; into. These are identically shaped variables to V, u, and s respectively. It's just a place to put the delta (since there are already meaningful variables in the regular V, u, and s that I don't want to erase).&lt;/p&gt;

&lt;h3&gt;From Error Propagation To Learning&lt;/h3&gt;

&lt;p&gt;Ok, so now we know how to move error around through two of our fun stack functions. How does this translate to learning? What are we trying to learn anyway?&lt;/p&gt;

&lt;p&gt;Let's think back to our regular stack again. Remember the toy problem we had before? If we pushed an entire sequence onto a stack and then popped it off, we'd get the sequence back in reverse. What this requires is the correct sequence of pushing and popping. So, what if we pushed 3 items on our stack, could we learn to correctly pop them off by adjusting u_t? Let's give it a shot!&lt;/p&gt;

&lt;p&gt;Step one is to setup our problem. We need to pick a sequence, and initialize our u_t and d_t variables. (We're initializing both, but we're only going to try to adjust u_t). Something like this will do.&lt;/p&gt;

&lt;pre class=&quot;brush: python&quot;&gt;

u_weights = np.array([0,0,0,0,0,0.01])
d_weights = np.array([1,1,1,0,0,0]).astype('float64')
# for i in xrange(1000):
stack_width = 2
copy_length = 5

sequence = np.array([[0.1,0.2,0.3],[0,0,0]]).T

# INIT
V = list() # stack states
s = list() # stack strengths 
d = list() # push strengths
u = list() # pop strengths

V_delta = list() # stack states
s_delta = list() # stack strengths 
d_delta = list() # push strengths
u_delta = list() # pop strengths

&lt;/pre&gt;

&lt;p&gt;Ok, it's time to start &quot;reading the net&quot; a little bit. Notice that d_weights starts wtih three 1s in the first three positions. This is what's going to push our sequence onto the stack! By just fixing these weights to 1, we will push with a weight of 1 onto the stack. We're also jumping into something a bit fancy here but important to form the right picture of the stack in our heads. Our sequence has two dimensions and three values. The first dimension (column) has the sequence 0.1, 0.2, and 0.3. The second dimension is all zeros. So, the first item in our sequence is really [0.1, 0.0]. The second is [0.2,0.0]. We're only focusing on optimizing for (reversing) the sequence in the first column, but I want to use two dimensions so that we can make sure our logic is generalized to multi-dimensional sequence inputs. We'll see why later. :)&lt;/p&gt;

&lt;p&gt;Also notice that we're initializing the &quot;delta&quot; variables. We also make a few changes to our functions from before to make sure we keep the delta variables maintaining the same shape as their respective base variables.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; When you hit &quot;Play&quot;, the browser may freeze temporarily. Just wait for it to finish. Could be a minute or two.&lt;/p&gt;

&lt;iframe src=&quot;https://trinket.io/embed/python/24f5f8fc11&quot; width=&quot;100%&quot; height=&quot;600&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;So, at risk of making this blogpost too long (it probably already is), I'll leave it up to you to use what I've taught here and in previous blogposts to work through the backpropgation steps if you like. It's really just a sequence of applying the rules that we outlined above. Furthermore, everything else in the learning stack above is based on the concepts we already learned. I encourage you to play around with the code. All we did was backprop from the error in prediction back to the popping weight array u_weights... which stores the value we enter for u_t at each timestep. We then update the weights to apply a different u_t at the next iteration. To be clear, this is basically a neural network with only 3 parameters that we update. However, since that update is whether we pop or not, it has the opportunity to optimize this toy problem. Try to learn different sequences. Break it. Fix it. Play with it!&lt;/p&gt;

&lt;h3&gt;The Next Level: Learning to Push&lt;/h3&gt;

&lt;p&gt;So, why did we build that last toy example? Well, for me personally, I wanted to be able to sanity check that my backpropagation logic was correct. What better way to check that than to have it optimize the simplest toy problem I could surmise. This is another best practice. Validate as much as you can along the way. What I know so far is that the deltas showing up in u_delta are correct, and if I use them to update future values of u_t, then the network converges to a sequence. However, what about d_t? Let's try to optimize both with a slightly harder problem (but only slightly... remember... we're validating code). Notice that there are very few code changes. We're just harvesting the derivatives from d_t as well to update d_weights just like we did u_weights (run for more iterations to get better convergence).&lt;/p&gt;

&lt;iframe src=&quot;https://trinket.io/embed/python/98c8cf72d5&quot; width=&quot;100%&quot; height=&quot;600&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;b&gt;Have Questions? Stuck? Feel free to tweet your question &lt;a href=&quot;https://twitter.com/iamtrask&quot;&gt;@iamtrask&lt;/a&gt; for help.&lt;/b&gt;&lt;/p&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;&lt;hr /&gt;Part 5: Building a Neural Controller&lt;br /&gt;&lt;hr /&gt;&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;iframe width=&quot;700px&quot; height=&quot;440px&quot; src=&quot;https://www.youtube.com/embed/J6Zaugshvqs&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;We did it! At this point, we have built a neural stack and all of its components. However, there's more to do to get it to learn arbitrary sequences. So, for a little while we're going to return to some of our fundamentals of neural networks. The next phase is to control v_t, u_t, and d_t with an external neural network called a &quot;Controller&quot;. This network will be a Recurrent Neural Network (because we're still modeling sequences). Thus, the knowledge of RNNs contained in the previous blogpost on &lt;a href=&quot;http://iamtrask.github.io/2015/11/15/anyone-can-code-lstm/&quot;&gt;Recurrent Neural Networks&lt;/a&gt; will be considered a pre-requisite.&lt;/p&gt;

&lt;p&gt;To determine what kind of neural network we will use to control these various operations, let's take a look back at the formulas describing it in the paper.&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/neural_stack/controller_formulas.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The high level takeaway of these formulas is that all of our inputs to the stack are conditioned on a vector called o_prime_t. If you are familiar with vanilla neural networks already, then this should be easy work. The code for these functions looks something like this.&lt;/p&gt;

&lt;pre class=&quot;brush: python&quot;&gt;

import numpy as np

def sigmoid(x):
    return 1/(1+np.exp(-x))

def tanh(x):
    return np.tanh(x)

o_prime_dim = 5
stack_width = 2
output_dim = 3

o_prime_t = np.random.rand(o_prime_dim) # random input data

# weight matrix
W_d = np.random.rand(o_prime_dim,1) * 0.2 - 0.1
# bias
b_d = np.random.rand(1) * 0.2 - 0.1

# weight matrix
W_u = np.random.rand(o_prime_dim,1) * 0.2 - 0.1
# bias
b_u = np.random.rand(1) * 0.2 - 0.1

# weight matrix
W_v = np.random.rand(o_prime_dim,stack_width) * 0.2 - 0.1
#bias
b_v = np.random.rand(stack_width) * 0.2 - 0.1

#weight matrix
W_o = np.random.rand(o_prime_dim,output_dim) * 0.2 - 0.1
#bias
b_o = np.random.rand(output_dim) * 0.2 - 0.1

#forward propagation
d_t = sigmoid(np.dot(o_prime_t,W_d) + b_d)
u_t = sigmoid(np.dot(o_prime_t,W_u) + b_u)
v_t = tanh(np.dot(o_prime_t,W_v) + b_v)
o_t = tanh(np.dot(o_prime_t,W_o) + b_o)

&lt;/pre&gt;

&lt;p&gt;So, this is another point where it would be tempting to hook up all of these controllers at once, build and RNN, and see if it converges. However, this is not wise. Instead, let's (again) just bite off the smallest piece that we can test. Let's start by just controlling u_t and d_t with a neural network by altering our previous codebase. This is also a good time to add some object oriented abstraction to our neural stack since we won't be changing it anymore (make it work... THEN make it pretty :) )&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; I'm just writing the code inline for you to copy and run locally. This was getting a bit too computationally intense for a browser. I highly recommend downloading &lt;a href=&quot;http://ipython.org/notebook.html&quot;&gt;iPython Notebook&lt;/a&gt; and running all the rest of the examples in this blog in various notebooks. That's what I used to develop them. They're extremely effective for experimention and rapid prototyping.&lt;/p&gt;

&lt;pre class=&quot;brush: python&quot;&gt;

import numpy as np
np.random.seed(1)

def sigmoid(x):
    return 1/(1+np.exp(-x))

def sigmoid_out2deriv(out):
    return out * (1 - out)

def tanh(x):
    return np.tanh(x)

def tanh_out2deriv(out):
    return (1 - out**2)

def relu(x,deriv=False):
    if(deriv):
        return int(x &amp;gt;= 0)
    return max(0,x)

class NeuralStack():
    def __init__(self,stack_width=2,o_prime_dim=6):
        self.stack_width = stack_width
        self.o_prime_dim = o_prime_dim
        self.reset()
        
    def reset(self):
        # INIT STACK
        self.V = list() # stack states
        self.s = list() # stack strengths 
        self.d = list() # push strengths
        self.u = list() # pop strengths
        self.r = list()
        self.o = list()

        self.V_delta = list() # stack states
        self.s_delta = list() # stack strengths 
        self.d_error = list() # push strengths
        self.u_error = list() # pop strengths
        
        self.t = 0
        
    def pushAndPopForward(self,v_t,d_t,u_t):

        self.d.append(d_t)
        self.d_error.append(0)

        self.u.append(u_t)
        self.u_error.append(0)

        new_s = np.zeros(self.t+1)
        for i in xrange(self.t+1):
            new_s[i] = self.s_t(i)
        self.s.append(new_s)
        self.s_delta.append(np.zeros_like(new_s))

        if(len(self.V) == 0):
            V_t = np.zeros((0,self.stack_width))
        else:
            V_t = self.V[-1]
        self.V.append(np.concatenate((V_t,np.atleast_2d(v_t)),axis=0))
        self.V_delta.append(np.zeros_like(self.V[-1]))
        
        r_t = self.r_t()
        self.r.append(r_t)
        
        self.t += 1
        return r_t
    
    def s_t(self,i):
        if(i &amp;gt;= 0 and i &amp;lt; self.t):
            inner_sum = self.s[self.t-1][i+1:self.t-0]
            return relu(self.s[self.t-1][i] - relu(self.u[self.t] - np.sum(inner_sum)))
        elif(i == self.t):
            return self.d[self.t]
        else:
            print &quot;Problem&quot;
            
    def s_t_error(self,i,error):
        if(i &amp;gt;= 0 and i &amp;lt; self.t):
            if(self.s_t(i) &amp;gt;= 0):
                self.s_delta[self.t-1][i] += error
                if(relu(self.u[self.t] - np.sum(self.s[self.t-1][i+1:self.t-0])) &amp;gt;= 0):
                    self.u_error[self.t] -= error
                    self.s_delta[self.t-1][i+1:self.t-0] += error
        elif(i == self.t):
            self.d_error[self.t] += error
        else:
            print &quot;Problem&quot;
            
    def r_t(self):
        r_t_out = np.zeros(self.stack_width)
        for i in xrange(0,self.t+1):
            temp = min(self.s[self.t][i],relu(1 - np.sum(self.s[self.t][i+1:self.t+1])))
            r_t_out += temp * self.V[self.t][i]
        return r_t_out
            
    def r_t_error(self,r_t_error):
        for i in xrange(0, self.t+1):
            temp = min(self.s[self.t][i],relu(1 - np.sum(self.s[self.t][i+1:self.t+1])))
            self.V_delta[self.t][i] += temp * r_t_error
            temp_error = np.sum(r_t_error * self.V[self.t][i])

            if(self.s[self.t][i] &amp;lt; relu(1 - np.sum(self.s[self.t][i+1:self.t+1]))):
                self.s_delta[self.t][i] += temp_error
            else:
                if(relu(1 - np.sum(self.s[self.t][i+1:self.t+1])) &amp;gt; 0):
                    self.s_delta[self.t][i+1:self.t+1] -= temp_error # minus equal becuase of the (1-).. and drop the 1
            
    def backprop(self,all_errors_in_order_of_training_data):
        errors = all_errors_in_order_of_training_data
        for error in reversed(list((errors))):
            self.t -= 1
            self.r_t_error(error)
            for i in reversed(xrange(self.t+1)):
                self.s_t_error(i,self.s_delta[self.t][i])

        
u_weights = np.array([0,0,0,0,0,0.0])

o_primes = np.eye(6)
y = np.array([1,0])
W_op_d = (np.random.randn(6,1) * 0.2) - 0.2
b_d = np.zeros(1)

W_op_u = (np.random.randn(6,1) * 0.2) - 0.2
b_u = np.zeros(1)

for h in xrange(10000):
    
    sequence = np.array([np.random.rand(3),[0,0,0]]).T
    sequence = np.concatenate((sequence,np.zeros_like(sequence)))
    
    stack = NeuralStack()

    d_weights = sigmoid(np.dot(o_primes,W_op_d) + b_d)
    u_weights = sigmoid(np.dot(o_primes,W_op_u) + b_u)
    
    reads = list()
    for i in xrange(6):
        reads.append(stack.pushAndPopForward(sequence[i],d_weights[i],u_weights[i]))

    reads = np.array(reads)

    reads[:3] *= 0 # eliminate errors we're not ready to backprop

    errors_in_order = reads - np.array(list(reversed(sequence)))

    stack.backprop(errors_in_order)

    # WEIGHT UPDATE
    alpha = 0.5

    u_delta = np.atleast_2d(np.array(stack.u_error) * sigmoid_out2deriv(u_weights)[0])
    W_op_u -= alpha * np.dot(o_primes,u_delta.T)
    b_u -= alpha * np.mean(u_delta)

    d_delta = np.atleast_2d(np.array(stack.d_error) * sigmoid_out2deriv(d_weights)[0])
    W_op_d -= alpha * np.dot(o_primes,d_delta.T)
    b_d -= alpha * np.mean(d_delta)

    for k in range(len(d_weights)):
        if d_weights[k] &amp;lt; 0:
            d_weights[k] = 0
        if u_weights[k] &amp;lt; 0:
            u_weights[k] = 0
            

    if(h % 100 == 0):
        print errors_in_order        

&lt;/pre&gt;

&lt;h3&gt;Runtime Output:&lt;/h3&gt;
&lt;pre&gt;

[[ 0.          0.        ]
 [ 0.          0.        ]
 [ 0.          0.        ]
 [-0.79249511  0.        ]
 [-0.19810149  0.        ]
 [-0.14038694  0.        ]]

 .....
 .....
 .....

 [[ 0.          0.        ]
 [ 0.          0.        ]
 [ 0.          0.        ]
 [-0.00174623  0.        ]
 [ 0.0023387   0.        ]
 [-0.00084291  0.        ]]
&lt;/pre&gt;

&lt;p&gt;Note that I'm logging errors this time instead of the discrete sequence.&lt;/p&gt;
&lt;p&gt;All this code is doing is using two weight matrices W_op_u and W_op_d (and their biases) to predict u_t and d_t. We created mock o_prime_t variables to be different at each timestep. Instead of taking the delta at u_t and changing the u_weight directly. We used the delta at u_t to update the matrices W_op_u. Even though the code is cleaned up considerably, it's still doing the same thing for 99% of it.&lt;/p&gt;

&lt;h3&gt;Building Out The Rest of the Controller&lt;/h3&gt;

&lt;p&gt;So, all we're really doing now is taking the RNN from my previous blogpost on Recurrent Neural Networks and using it to generate o_prime_t. We then hook up the forward and backpropagation and we get the following code. I'm going to write the code in section here and describe (at a high level) what's going on. I'll then give you a single block with all the code together (that's runnable)&lt;/p&gt;

&lt;pre class=&quot;brush: python&quot;&gt;

import numpy as np

def sigmoid(x):
    return 1/(1+np.exp(-x))

def sigmoid_out2deriv(out):
    return out * (1 - out)

def tanh(x):
    return np.tanh(x)

def tanh_out2deriv(out):
    return (1 - out**2)

def relu(x,deriv=False):
    if(deriv):
        return int(x &amp;gt;= 0)
    return max(0,x)

&lt;/pre&gt;

&lt;p&gt;Seen this before. Just some utility nonlinearities to use at various layers. Note that I'm using relu here instead of using the &quot;max(0,x)&quot; from before. They are identical. So, wherever you used to see &quot;max(0,&quot; you will now see &quot;relu(&quot;.&lt;/p&gt;

&lt;pre class=&quot;brush: python&quot;&gt;

class NeuralStack():
    def __init__(self,stack_width=2,o_prime_dim=6):
        self.stack_width = stack_width
        self.o_prime_dim = o_prime_dim
        self.reset()
        
    def reset(self):
        # INIT STACK
        self.V = list() # stack states
        self.s = list() # stack strengths 
        self.d = list() # push strengths
        self.u = list() # pop strengths
        self.r = list()
        self.o = list()

        self.V_delta = list() # stack states
        self.s_delta = list() # stack strengths 
        self.d_error = list() # push strengths
        self.u_error = list() # pop strengths
        
        self.t = 0
        
    def pushAndPopForward(self,v_t,d_t,u_t):

        self.d.append(d_t)
        self.d_error.append(0)

        self.u.append(u_t)
        self.u_error.append(0)

        new_s = np.zeros(self.t+1)
        for i in xrange(self.t+1):
            new_s[i] = self.s_t(i)
        self.s.append(new_s)
        self.s_delta.append(np.zeros_like(new_s))

        if(len(self.V) == 0):
            V_t = np.zeros((0,self.stack_width))
        else:
            V_t = self.V[-1]
        self.V.append(np.concatenate((V_t,np.atleast_2d(v_t)),axis=0))
        self.V_delta.append(np.zeros_like(self.V[-1]))
        
        r_t = self.r_t()
        self.r.append(r_t)
        
        self.t += 1
        return r_t
    
    def s_t(self,i):
        if(i &amp;gt;= 0 and i &amp;lt; self.t):
            inner_sum = self.s[self.t-1][i+1:self.t-0]
            return relu(self.s[self.t-1][i] - relu(self.u[self.t] - np.sum(inner_sum)))
        elif(i == self.t):
            return self.d[self.t]
        else:
            print &quot;Problem&quot;
            
    def s_t_error(self,i,error):
        if(i &amp;gt;= 0 and i &amp;lt; self.t):
            if(self.s_t(i) &amp;gt;= 0):
                self.s_delta[self.t-1][i] += error
                if(relu(self.u[self.t] - np.sum(self.s[self.t-1][i+1:self.t-0])) &amp;gt;= 0):
                    self.u_error[self.t] -= error
                    self.s_delta[self.t-1][i+1:self.t-0] += error
        elif(i == self.t):
            self.d_error[self.t] += error
        else:
            print &quot;Problem&quot;
            
    def r_t(self):
        r_t_out = np.zeros(self.stack_width)
        for i in xrange(0,self.t+1):
            temp = min(self.s[self.t][i],relu(1 - np.sum(self.s[self.t][i+1:self.t+1])))
            r_t_out += temp * self.V[self.t][i]
        return r_t_out
            
    def r_t_error(self,r_t_error):
        for i in xrange(0, self.t+1):
            temp = min(self.s[self.t][i],relu(1 - np.sum(self.s[self.t][i+1:self.t+1])))
            self.V_delta[self.t][i] += temp * r_t_error
            temp_error = np.sum(r_t_error * self.V[self.t][i])

            if(self.s[self.t][i] &amp;lt; relu(1 - np.sum(self.s[self.t][i+1:self.t+1]))):
                self.s_delta[self.t][i] += temp_error
            else:
                if(relu(1 - np.sum(self.s[self.t][i+1:self.t+1])) &amp;gt; 0):
                    self.s_delta[self.t][i+1:self.t+1] -= temp_error # minus equal becuase of the (1-).. and drop the 1
    def backprop_single(self,r_t_error):
        self.t -= 1
        self.r_t_error(r_t_error)
        for i in reversed(xrange(self.t+1)):
            self.s_t_error(i,self.s_delta[self.t][i])
    
    def backprop(self,all_errors_in_order_of_training_data):
        errors = all_errors_in_order_of_training_data
        for error in reversed(list((errors))):
            self.backprop_single(error)


&lt;/pre&gt;

&lt;p&gt;This is pretty much the same Neural Stack we developed before. I broke the &quot;backprop&quot; method into two methods: backprop and backprop_single. Backpropagating over all the timesteps can be done by calling backprop. If you just want to backprop a single step at a time (which was useful when making sure to backprop through the RNN), then call backprop_single.&lt;/p&gt;

&lt;pre class=&quot;brush: python&quot;&gt;
options = 2
sub_sequence_length = 2
sequence_length = sub_sequence_length*2

sequence = (np.random.random(sub_sequence_length)*options).astype(int)+1
sequence[-1] = 0
sequence

X = np.zeros((sub_sequence_length*2,options+1))
Y = np.zeros_like(X)
for i in xrange(len(sequence)):
    X[i][sequence[i]] = 1
    Y[-i][sequence[i]] = 1

x_dim = X.shape[1]
h_dim = 16
o_prime_dim = 16
stack_width = options
y_dim = Y.shape[1]
&lt;/pre&gt;

&lt;p&gt;This segment of code does a couple things. First, it constructs a training example sequence. &quot;sub_sequence_length&quot; is the lengh of the sequence that we want to remember and then reverse with the neural stack. &quot;options&quot; is the number of unique elements in the sequence. Setting options to 2 generates a binary sequence, which is what we're running here. The sequence_length is just double the sub_sequence_length. This is because we need to first encode the whole sequence and then decode the whole sequence. So, if the sub_sequence_length is of length 5, then we have to generate 10 training examples (5 encoding and 5 decoding). Note that we set the last number in the sequence to 0 which is a special index indicating that we have reached the end of the sequence. The network will learn to start reversing at this point.&lt;/p&gt;

&lt;p&gt;X and Y are our input and output training examples respectively. They one-hot encode our training data for both inputs and outputs.&lt;/p&gt;

&lt;p&gt;Finally, we have the dimensionality of our neural network. In accordance with the paper, we the input dimension x_dim (equal to the number of &quot;options&quot; in our sequence plus one special character for the end of sequence marker). We also have two hidden layers. &quot;h_dim&quot; refers to the hidden layer in the recurrent neural network. &quot;o_prime_dim&quot; is the second hidden layer (generated from the recurrent hidden layer) which sends information into our neural stack. We have set the dimensionality of both hidden layers to 16. Note that this is WAY smaller than the 256 and 512 size layers in the paper. For ease, we're going to work with shorter binary sequences which require smaller hidden layers sizes (mostly because of the number of options, not the length of the sequence...)&lt;/p&gt;

&lt;p&gt;&quot;stack_width&quot; is still the width of the vectors on the stack. In this case, I'm setting it to the number of options so that it can (in theory) one hot encode the input data into the stack. In theory you could actually use log_base_2(options) but this level of compression just requires more training time. I tried several experiments making this bigger with mixed results.&lt;/p&gt;

&lt;p&gt;&quot;y_dim&quot; is the dimensionality of the output sequence to be predicted. Note that this could be (in theory) any sequence, but in this case it is the reverse of the input.&lt;/p&gt;

&lt;pre class=&quot;brush: python&quot;&gt;

W_xh = (np.random.rand(x_dim,h_dim)*0.2) - 0.1
W_xh_update = np.zeros_like(W_xh)

W_hh = (np.random.rand(h_dim,h_dim)*0.2) - 0.1
W_hh_update = np.zeros_like(W_hh)

W_rh = (np.random.rand(stack_width,h_dim)*0.2) - 0.1
W_rh_update = np.zeros_like(W_rh)

b_h = (np.random.rand(h_dim)*0.2) - 0.1
b_h_update = np.zeros_like(b_h)

W_hop = (np.random.rand(h_dim,o_prime_dim) * 0.2) - 0.1
W_hop_update = np.zeros_like(W_hop)

b_op = (np.random.rand(o_prime_dim)*0.2) - 0.1
b_op_update = np.zeros_like(b_op)

W_op_d = (np.random.rand(o_prime_dim,1)*0.2) - 0.1
W_op_d_update = np.zeros_like(W_op_d)

W_op_u = (np.random.rand(o_prime_dim,1)*0.2) - 0.1
W_op_u_update = np.zeros_like(W_op_u)

W_op_v = (np.random.rand(o_prime_dim,stack_width)*0.2) - 0.1
W_op_v_update = np.zeros_like(W_op_v)

W_op_o = (np.random.rand(o_prime_dim,y_dim)*0.2) - 0.1
W_op_o_update = np.zeros_like(W_op_o)

b_d = (np.random.rand(1)*0.2)+0.1
b_d_update = np.zeros_like(b_d)

b_u = (np.random.rand(1)*0.2)-0.1
b_u_update = np.zeros_like(b_u)

b_v = (np.random.rand(stack_width)*0.2)-0.1
b_v_update = np.zeros_like(b_v)

b_o = (np.random.rand(y_dim)*0.2)-0.1
b_o_update = np.zeros_like(b_o)

&lt;/pre&gt;

&lt;p&gt;This initializes all of our weight matrices necessary for the Recurrent Neural Network Controller. I generally used the notation W_ for weight matrices and b_ for biases. Following the W is shorthand for what it connects from and to. For example, W_xh connects the input (x) to the recurrent hidden layer (h). &quot;op&quot; is shorthand for &quot;o_prime&quot;.&lt;/p&gt;

&lt;p&gt;There is one other note here that you can find in the appendix of the paper. Initialization of b_d and b_u has significant impact on how well the neural stack is learned. In general, if the first iterations of the network don't push anything onto the stack, then no derivatives will backpropagate THROUGH the stack, and the neural network will just ignore it. Thus, initializing b_d (the push bias) to a higher number (+0.1 instead of -0.1) encourages the network to push onto the neural stack during the beginning of training. This has a nice parallel intuition to life. If you had a stack but never pushed anything onto it... how would you know what it does? Generally the same thing going on here intuitively.&lt;/p&gt;

&lt;p&gt;The reason we have _update variables is that we're going to be implementing mini-batch updates. Thus, we'll create updates and save them in the _update variables and only occasionally update the actual variables. This make for smoother training. See more on this in previous blogposts.&lt;/p&gt;

&lt;pre class=&quot;brush: python&quot;&gt;

error = 0
max_len = 1
batch_size = 10
for it in xrange(1000000000):
    
    sub_sequence_length = np.random.randint(max_len)+1
    sequence = (np.random.random(sub_sequence_length)*options).astype(int)+1
#     sequence[-1] = 0
    sequence
    
    X = np.zeros((sub_sequence_length*2,options+1))
    Y = np.zeros_like(X)
    for i in xrange(len(sequence)):
        X[i][sequence[i]] = 1
        X[i][0] = 1
        Y[-i-1][sequence[i]] = 1
    
&lt;/pre&gt;

&lt;p&gt;Ok, so the logic above that creates training examples doesn't exactly get used. I just use that section further up to experiment with the training example logic. I encourage you to do it. As you can see here, we randomly generate new training examples as we go. Note that &quot;max_len&quot; refers to the maximum length that we will model initially. As the error goes down (the neural network learns), this number will increase, modeling longer and longer sequences. Basically, we start by training the neural stack on short sequences, and once it gets good at those we start presenting longer ones. Experimenting with how long to start with was very fascinating to me. I highly encourage playing around with it.&lt;/p&gt;

&lt;pre class=&quot;brush: python&quot;&gt;

layers = list()
stack = NeuralStack(stack_width=stack_width,o_prime_dim=o_prime_dim)    
for i in xrange(len(X)):
    layer = {}

    layer['x'] = X[i]

    if(i == 0):
        layer['h_t-1'] = np.zeros(h_dim)
        layer['h_t-1'][0] = 1
        layer['r_t-1'] = np.zeros(stack_width)
        layer['r_t-1'][0] = 1
    else:
        layer['h_t-1'] = layers[i-1]['h_t']
        layer['r_t-1'] = layers[i-1]['r_t']

    layer['h_t'] = tanh(np.dot(layer['x'],W_xh) + np.dot(layer['h_t-1'],W_hh) + np.dot(layer['r_t-1'],W_rh) + b_h)
    layer['o_prime_t'] = tanh(np.dot(layer['h_t'],W_hop)+b_op)
    layer['o_t'] = tanh(np.dot(layer['o_prime_t'],W_op_o) + b_o)

    if(i &amp;lt; len(X)-1):
        layer['d_t'] = sigmoid(np.dot(layer['o_prime_t'],W_op_d) + b_d)
        layer['u_t'] = sigmoid(np.dot(layer['o_prime_t'],W_op_u) + b_u)
        layer['v_t'] = tanh(np.dot(layer['o_prime_t'],W_op_v) + b_v)

        layer['r_t'] = stack.pushAndPopForward(layer['v_t'],layer['d_t'],layer['u_t'])

    layers.append(layer)

&lt;/pre&gt;

&lt;p&gt;This is the forward propagation step. Notice that it's just a recurrent neural network with one extra input r_t-1 which is the neural stack r_t from the previous timestep. Generally, you can also see that x-&amp;gt;h, h-&amp;gt;o_prime, o_prime-&amp;gt;stack_controllers, stack_controllers-&amp;gt;stack, stack-&amp;gt;r_t, and then r_t is fed into the next layer. Study this portion of code until the &quot;information flow&quot; becomes clear. Also notice the convention I use of storing the intermediate variables into the &quot;layers&quot; list. This will help make backpropagation easier later. Note that the prediction of the neural network is layer['o'] which isn't exactly what we read off of the stack. Information must travel from the stack to the hidden layer and out through layer['o']. We'll talk more about how to encourage this in a minute.&lt;/p&gt;

&lt;pre class=&quot;brush: python&quot;&gt;

for i in list(reversed(xrange(len(X)))):
    layer = layers[i]

    layer['o_t_error'] = Y[i] - layer['o_t']
    error += np.sum(np.abs(layer['o_t_error']))
    if(it % 100 == 99):
        if(i == len(X)-1):
            if(it % 10000 == 9999):
                print &quot;MaxLen:&quot;+str(max_len)+ &quot; Iter:&quot; + str(it) + &quot; Error:&quot; + str(error) + &quot;True:&quot; + str(sequence) + &quot; Pred:&quot; + str(map(lambda x:np.argmax(x['o_t']),layers[sub_sequence_length:]))
            if(error &amp;lt; (5*max_len)):
                max_len+=1              
            error = 0

#                     sub_sequence_length += 1                
#             print str(Y[i]) + &quot; - &quot; + str(layer['o_t']) + &quot; = &quot; + str(layer['o_t_error'])        
    layer['o_t_delta'] = layer['o_t_error'] * tanh_out2deriv(layer['o_t'])

    layer['o_prime_t_error'] = np.dot(layer['o_t_delta'],W_op_o.T)

    if(i &amp;lt; len(X)-1):
        layer['r_t_error'] = layers[i+1]['r_t-1_error']
        stack.backprop_single(layer['r_t_error'])

        layer['v_t_error'] = stack.V_delta[i][i]
        layer['v_t_delta'] = layer['v_t_error'] * tanh_out2deriv(layer['v_t'])
        layer['o_prime_t_error'] += np.dot(layer['v_t_delta'],W_op_v.T)

        layer['u_t_error'] = stack.u_error[i]
        layer['u_t_delta'] = layer['u_t_error'] * sigmoid_out2deriv(layer['u_t'])
        layer['o_prime_t_error'] += np.dot(layer['u_t_delta'],W_op_u.T)

        layer['d_t_error'] = stack.d_error[i]
        layer['d_t_delta'] = layer['d_t_error'] * sigmoid_out2deriv(layer['d_t'])
        layer['o_prime_t_error'] += np.dot(layer['d_t_delta'],W_op_d.T)


    layer['o_prime_t_delta'] = layer['o_prime_t_error'] * tanh_out2deriv(layer['o_prime_t'])
    layer['h_t_error'] = np.dot(layer['o_prime_t_delta'],W_hop.T)

    if(i &amp;lt; len(X)-1):
        layer['h_t_error'] += layers[i+1]['h_t-1_error']

    layer['h_t_delta'] = layer['h_t_error'] * tanh_out2deriv(layer['h_t'])
    layer['h_t-1_error'] = np.dot(layer['h_t_delta'],W_hh.T)
    layer['r_t-1_error'] = np.dot(layer['h_t_delta'],W_rh.T)	

&lt;/pre&gt;

&lt;p&gt;This is the backpropagation step. Again, we're just taking the delta we get from the neural stack and then backpropagating it through all the layers just like we did with the recurrent neural network in the previous blogpost. Also note the logic on lines 7-13. If the error gets below 5*max_len, then it increases the length of the sequence it's trying to model by 1 at the next iteration.&lt;/p&gt;

&lt;pre class=&quot;brush: python&quot;&gt;
for i in xrange(len(X)):
    layer = layers[i]
    max_alpha = 0.005 * batch_size
    alpha = max_alpha / sub_sequence_length

    W_xh_update += alpha * np.outer(layer['x'],layer['h_t_delta'])
    W_hh_update += alpha * np.outer(layer['h_t-1'],layer['h_t_delta'])
    W_rh_update += alpha * np.outer(layer['r_t-1'],layer['h_t_delta'])
    b_h_update += alpha * layer['h_t_delta']

    W_hop_update += alpha * np.outer(layer['h_t'],layer['o_prime_t_delta'])
    b_op_update += alpha * layer['o_prime_t_delta']

    if(i &amp;lt; len(X)-1):
        W_op_d_update += alpha * np.outer(layer['o_prime_t'],layer['d_t_delta'])
        W_op_u_update += alpha * np.outer(layer['o_prime_t'],layer['u_t_delta'])
        W_op_v_update += alpha * np.outer(layer['o_prime_t'],layer['v_t_delta'])

        b_d_update += alpha * layer['d_t_delta']
        b_u_update += alpha * layer['u_t_delta']
        b_v_update += alpha * layer['v_t_delta']

    W_op_o_update += alpha * np.outer(layer['o_prime_t'],layer['o_t_delta'])
    b_o_update += alpha * layer['o_t_delta']

&lt;/pre&gt;

&lt;p&gt;At this phase, we create our weight updates by multiplying the outer product of each layers weights by the deltas at the immediately following layer. We save these updates aside into our _update variables. Note that this doesn't change the weights. It just collects the updates. &lt;/p&gt;

&lt;pre class=&quot;brush: python&quot;&gt;

if(it % batch_size == (batch_size-1)):
    W_xh += W_xh_update/batch_size
    W_xh_update *= 0
    
    W_hh += W_hh_update/batch_size
    W_hh_update *= 0
    
    W_rh += W_rh_update/batch_size
    W_rh_update *= 0
    
    b_h += b_h_update/batch_size
    b_h_update *= 0
    
    W_hop += W_hop_update/batch_size
    W_hop_update *= 0
    
    b_op += b_op_update/batch_size
    b_op_update *= 0
    
    W_op_d += W_op_d_update/batch_size
    W_op_d_update *= 0
    
    W_op_u += W_op_u_update/batch_size
    W_op_u_update *= 0
    
    W_op_v += W_op_v_update/batch_size
    W_op_v_update *= 0
    
    b_d += b_d_update/batch_size
    b_d_update *= 0
    
    b_d += b_d * 0.00025 * batch_size
    b_u += b_u_update/batch_size
    b_u_update *= 0
    
    b_v += b_v_update/batch_size
    b_v_update *= 0
    
    W_op_o += W_op_o_update/batch_size
    W_op_o_update *= 0
    
    b_o += b_o_update/batch_size
    b_o_update *= 0

&lt;/pre&gt;

&lt;p&gt;And if we are at the end of a mini-batch, then we update the weights using the average of all the updates we had accumulated so far. We then clear out each _update variable by multiplying it by 0.&lt;/p&gt;

&lt;h3&gt;And We Have It!!!&lt;/h3&gt;

&lt;p&gt;So, for all the code in one big file for you to run&lt;/p&gt;

&lt;pre class=&quot;brush: python&quot;&gt;
import numpy as np

def sigmoid(x):
    return 1/(1+np.exp(-x))

def sigmoid_out2deriv(out):
    return out * (1 - out)

def tanh(x):
    return np.tanh(x)

def tanh_out2deriv(out):
    return (1 - out**2)

def relu(x,deriv=False):
    if(deriv):
        return int(x &amp;gt;= 0)
    return max(0,x)

class NeuralStack():
    def __init__(self,stack_width=2,o_prime_dim=6):
        self.stack_width = stack_width
        self.o_prime_dim = o_prime_dim
        self.reset()
        
    def reset(self):
        # INIT STACK
        self.V = list() # stack states
        self.s = list() # stack strengths 
        self.d = list() # push strengths
        self.u = list() # pop strengths
        self.r = list()
        self.o = list()

        self.V_delta = list() # stack states
        self.s_delta = list() # stack strengths 
        self.d_error = list() # push strengths
        self.u_error = list() # pop strengths
        
        self.t = 0
        
    def pushAndPopForward(self,v_t,d_t,u_t):

        self.d.append(d_t)
        self.d_error.append(0)

        self.u.append(u_t)
        self.u_error.append(0)

        new_s = np.zeros(self.t+1)
        for i in xrange(self.t+1):
            new_s[i] = self.s_t(i)
        self.s.append(new_s)
        self.s_delta.append(np.zeros_like(new_s))

        if(len(self.V) == 0):
            V_t = np.zeros((0,self.stack_width))
        else:
            V_t = self.V[-1]
        self.V.append(np.concatenate((V_t,np.atleast_2d(v_t)),axis=0))
        self.V_delta.append(np.zeros_like(self.V[-1]))
        
        r_t = self.r_t()
        self.r.append(r_t)
        
        self.t += 1
        return r_t
    
    def s_t(self,i):
        if(i &amp;gt;= 0 and i &amp;lt; self.t):
            inner_sum = self.s[self.t-1][i+1:self.t-0]
            return relu(self.s[self.t-1][i] - relu(self.u[self.t] - np.sum(inner_sum)))
        elif(i == self.t):
            return self.d[self.t]
        else:
            print &quot;Problem&quot;
            
    def s_t_error(self,i,error):
        if(i &amp;gt;= 0 and i &amp;lt; self.t):
            if(self.s_t(i) &amp;gt;= 0):
                self.s_delta[self.t-1][i] += error
                if(relu(self.u[self.t] - np.sum(self.s[self.t-1][i+1:self.t-0])) &amp;gt;= 0):
                    self.u_error[self.t] -= error
                    self.s_delta[self.t-1][i+1:self.t-0] += error
        elif(i == self.t):
            self.d_error[self.t] += error
        else:
            print &quot;Problem&quot;
            
    def r_t(self):
        r_t_out = np.zeros(self.stack_width)
        for i in xrange(0,self.t+1):
            temp = min(self.s[self.t][i],relu(1 - np.sum(self.s[self.t][i+1:self.t+1])))
            r_t_out += temp * self.V[self.t][i]
        return r_t_out
            
    def r_t_error(self,r_t_error):
        for i in xrange(0, self.t+1):
            temp = min(self.s[self.t][i],relu(1 - np.sum(self.s[self.t][i+1:self.t+1])))
            self.V_delta[self.t][i] += temp * r_t_error
            temp_error = np.sum(r_t_error * self.V[self.t][i])

            if(self.s[self.t][i] &amp;lt; relu(1 - np.sum(self.s[self.t][i+1:self.t+1]))):
                self.s_delta[self.t][i] += temp_error
            else:
                if(relu(1 - np.sum(self.s[self.t][i+1:self.t+1])) &amp;gt; 0):
                    self.s_delta[self.t][i+1:self.t+1] -= temp_error # minus equal becuase of the (1-).. and drop the 1
    def backprop_single(self,r_t_error):
        self.t -= 1
        self.r_t_error(r_t_error)
        for i in reversed(xrange(self.t+1)):
            self.s_t_error(i,self.s_delta[self.t][i])
    
    def backprop(self,all_errors_in_order_of_training_data):
        errors = all_errors_in_order_of_training_data
        for error in reversed(list((errors))):
            self.backprop_single(error)

        
options = 2
sub_sequence_length = 5
sequence_length = sub_sequence_length*2

sequence = (np.random.random(sub_sequence_length)*options).astype(int)+1
sequence[-1] = 0
sequence

X = np.zeros((sub_sequence_length*2,options+1))
Y = np.zeros_like(X)
for i in xrange(len(sequence)):
    X[i][sequence[i]] = 1
    Y[-i][sequence[i]] = 1

sequence_length = len(X)
x_dim = X.shape[1]
h_dim = 16
o_prime_dim = 16
stack_width = options
y_dim = Y.shape[1]     


sub_sequence_length = 2

W_xh = (np.random.rand(x_dim,h_dim)*0.2) - 0.1
W_xh_update = np.zeros_like(W_xh)

W_hh = (np.random.rand(h_dim,h_dim)*0.2) - 0.1
W_hh_update = np.zeros_like(W_hh)

W_rh = (np.random.rand(stack_width,h_dim)*0.2) - 0.1
W_rh_update = np.zeros_like(W_rh)

b_h = (np.random.rand(h_dim)*0.2) - 0.1
b_h_update = np.zeros_like(b_h)

W_hop = (np.random.rand(h_dim,o_prime_dim) * 0.2) - 0.1
W_hop_update = np.zeros_like(W_hop)

b_op = (np.random.rand(o_prime_dim)*0.2) - 0.1
b_op_update = np.zeros_like(b_op)

W_op_d = (np.random.rand(o_prime_dim,1)*0.2) - 0.1
W_op_d_update = np.zeros_like(W_op_d)

W_op_u = (np.random.rand(o_prime_dim,1)*0.2) - 0.1
W_op_u_update = np.zeros_like(W_op_u)

W_op_v = (np.random.rand(o_prime_dim,stack_width)*0.2) - 0.1
W_op_v_update = np.zeros_like(W_op_v)

W_op_o = (np.random.rand(o_prime_dim,y_dim)*0.2) - 0.1
W_op_o_update = np.zeros_like(W_op_o)

b_d = (np.random.rand(1)*0.2)+0.1
b_d_update = np.zeros_like(b_d)

b_u = (np.random.rand(1)*0.2)-0.1
b_u_update = np.zeros_like(b_u)

b_v = (np.random.rand(stack_width)*0.2)-0.1
b_v_update = np.zeros_like(b_v)

b_o = (np.random.rand(y_dim)*0.2)-0.1
b_o_update = np.zeros_like(b_o)

error = 0
max_len = 1
batch_size = 10
for it in xrange(1000000000):
    
    sub_sequence_length = np.random.randint(max_len)+1
    sequence = (np.random.random(sub_sequence_length)*options).astype(int)+1
#     sequence[-1] = 0
    sequence
    
    X = np.zeros((sub_sequence_length*2,options+1))
    Y = np.zeros_like(X)
    for i in xrange(len(sequence)):
        X[i][sequence[i]] = 1
        X[i][0] = 1
        Y[-i-1][sequence[i]] = 1
    
    layers = list()
    stack = NeuralStack(stack_width=stack_width,o_prime_dim=o_prime_dim)    
    for i in xrange(len(X)):
        layer = {}

        layer['x'] = X[i]

        if(i == 0):
            layer['h_t-1'] = np.zeros(h_dim)
            layer['h_t-1'][0] = 1
            layer['r_t-1'] = np.zeros(stack_width)
            layer['r_t-1'][0] = 1
        else:
            layer['h_t-1'] = layers[i-1]['h_t']
            layer['r_t-1'] = layers[i-1]['r_t']

        layer['h_t'] = tanh(np.dot(layer['x'],W_xh) + np.dot(layer['h_t-1'],W_hh) + np.dot(layer['r_t-1'],W_rh) + b_h)
        layer['o_prime_t'] = tanh(np.dot(layer['h_t'],W_hop)+b_op)
        layer['o_t'] = tanh(np.dot(layer['o_prime_t'],W_op_o) + b_o)

        if(i &amp;lt; len(X)-1):
            layer['d_t'] = sigmoid(np.dot(layer['o_prime_t'],W_op_d) + b_d)
            layer['u_t'] = sigmoid(np.dot(layer['o_prime_t'],W_op_u) + b_u)
            layer['v_t'] = tanh(np.dot(layer['o_prime_t'],W_op_v) + b_v)

            layer['r_t'] = stack.pushAndPopForward(layer['v_t'],layer['d_t'],layer['u_t'])

        layers.append(layer)

    for i in list(reversed(xrange(len(X)))):
        layer = layers[i]

        layer['o_t_error'] = Y[i] - layer['o_t']
        error += np.sum(np.abs(layer['o_t_error']))
        if(it % 100 == 99):
            if(i == len(X)-1):
                if(it % 10000 == 9999):
                    print &quot;MaxLen:&quot;+str(max_len)+ &quot; Iter:&quot; + str(it) + &quot; Error:&quot; + str(error) + &quot;True:&quot; + str(sequence) + &quot; Pred:&quot; + str(map(lambda x:np.argmax(x['o_t']),layers[sub_sequence_length:]))
                if(error &amp;lt; (5*max_len)):
                    max_len+=1              
                error = 0

        layer['o_t_delta'] = layer['o_t_error'] * tanh_out2deriv(layer['o_t'])

        layer['o_prime_t_error'] = np.dot(layer['o_t_delta'],W_op_o.T)

        if(i &amp;lt; len(X)-1):
            layer['r_t_error'] = layers[i+1]['r_t-1_error']
            stack.backprop_single(layer['r_t_error'])

            layer['v_t_error'] = stack.V_delta[i][i]
            layer['v_t_delta'] = layer['v_t_error'] * tanh_out2deriv(layer['v_t'])
            layer['o_prime_t_error'] += np.dot(layer['v_t_delta'],W_op_v.T)

            layer['u_t_error'] = stack.u_error[i]
            layer['u_t_delta'] = layer['u_t_error'] * sigmoid_out2deriv(layer['u_t'])
            layer['o_prime_t_error'] += np.dot(layer['u_t_delta'],W_op_u.T)

            layer['d_t_error'] = stack.d_error[i]
            layer['d_t_delta'] = layer['d_t_error'] * sigmoid_out2deriv(layer['d_t'])
            layer['o_prime_t_error'] += np.dot(layer['d_t_delta'],W_op_d.T)


        layer['o_prime_t_delta'] = layer['o_prime_t_error'] * tanh_out2deriv(layer['o_prime_t'])
        layer['h_t_error'] = np.dot(layer['o_prime_t_delta'],W_hop.T)

        if(i &amp;lt; len(X)-1):
            layer['h_t_error'] += layers[i+1]['h_t-1_error']

        layer['h_t_delta'] = layer['h_t_error'] * tanh_out2deriv(layer['h_t'])
        layer['h_t-1_error'] = np.dot(layer['h_t_delta'],W_hh.T)
        layer['r_t-1_error'] = np.dot(layer['h_t_delta'],W_rh.T)

    for i in xrange(len(X)):
        layer = layers[i]
        max_alpha = 0.005 * batch_size
        alpha = max_alpha / sub_sequence_length

        W_xh_update += alpha * np.outer(layer['x'],layer['h_t_delta'])
        W_hh_update += alpha * np.outer(layer['h_t-1'],layer['h_t_delta'])
        W_rh_update += alpha * np.outer(layer['r_t-1'],layer['h_t_delta'])
        b_h_update += alpha * layer['h_t_delta']

        W_hop_update += alpha * np.outer(layer['h_t'],layer['o_prime_t_delta'])
        b_op_update += alpha * layer['o_prime_t_delta']

        if(i &amp;lt; len(X)-1):
            W_op_d_update += alpha * np.outer(layer['o_prime_t'],layer['d_t_delta'])
            W_op_u_update += alpha * np.outer(layer['o_prime_t'],layer['u_t_delta'])
            W_op_v_update += alpha * np.outer(layer['o_prime_t'],layer['v_t_delta'])

            b_d_update += alpha * layer['d_t_delta']
            b_u_update += alpha * layer['u_t_delta']
            b_v_update += alpha * layer['v_t_delta']

        W_op_o_update += alpha * np.outer(layer['o_prime_t'],layer['o_t_delta'])
        b_o_update += alpha * layer['o_t_delta']


    if(it % batch_size == (batch_size-1)):
        W_xh += W_xh_update/batch_size
        W_xh_update *= 0
        
        W_hh += W_hh_update/batch_size
        W_hh_update *= 0
        
        W_rh += W_rh_update/batch_size
        W_rh_update *= 0
        
        b_h += b_h_update/batch_size
        b_h_update *= 0
        
        W_hop += W_hop_update/batch_size
        W_hop_update *= 0
        
        b_op += b_op_update/batch_size
        b_op_update *= 0
        
        W_op_d += W_op_d_update/batch_size
        W_op_d_update *= 0
        
        W_op_u += W_op_u_update/batch_size
        W_op_u_update *= 0
        
        W_op_v += W_op_v_update/batch_size
        W_op_v_update *= 0
        
        b_d += b_d_update/batch_size
        b_d_update *= 0
        
        b_d += b_d * 0.00025 * batch_size
        b_u += b_u_update/batch_size
        b_u_update *= 0
        
        b_v += b_v_update/batch_size
        b_v_update *= 0
        
        W_op_o += W_op_o_update/batch_size
        W_op_o_update *= 0
        
        b_o += b_o_update/batch_size
        b_o_update *= 0
&lt;/pre&gt;
&lt;h3&gt;Expected Output:&lt;/h3&gt;
&lt;p&gt;If you run this code overnight on your CPU...you should see output that looks a lot like this. Note that the predictions are the reverse of the original sequence.&lt;/p&gt;
&lt;pre&gt;
.......
.......
.......
.......
MaxLen:19 Iter:2789999 Error:168.444794145True:[2 2 1 1 2 1 2 1 1 2] Pred:[2, 1, 1, 2, 1, 2, 1, 1, 2, 2]
MaxLen:19 Iter:2799999 Error:207.262352698True:[1] Pred:[1]
MaxLen:19 Iter:2809999 Error:182.105266119True:[1 1 2 1 2 2 2 1 1 2 1] Pred:[1, 2, 1, 1, 2, 2, 2, 1, 2, 1, 1]
MaxLen:19 Iter:2819999 Error:184.174791858True:[2 1 2 2] Pred:[2, 2, 1, 2]
MaxLen:19 Iter:2829999 Error:206.158101496True:[2 1 2 2 2 1 1 2] Pred:[2, 1, 1, 2, 2, 2, 1, 2]
MaxLen:19 Iter:2839999 Error:209.114103766True:[1 2 1 2 2 2 1 1 1 1 2] Pred:[2, 1, 1, 1, 1, 2, 2, 2, 1, 2, 1]
MaxLen:19 Iter:2849999 Error:167.128615254True:[2 1 2 1 1 2 1 2 1 2 1 1 2 2 2 1 2] Pred:[2, 1, 2, 2, 2, 1, 2, 2, 1, 2, 1, 2, 1, 1, 2, 1, 2]
MaxLen:19 Iter:2859999 Error:200.380921774True:[2 2 2 1 1] Pred:[1, 1, 2, 2, 2]
MaxLen:19 Iter:2869999 Error:112.94541202True:[2 2 1 2 2 1 2 2 1 1 2 1 2] Pred:[2, 1, 2, 1, 1, 2, 2, 1, 2, 2, 1, 2, 2]
MaxLen:19 Iter:2879999 Error:160.091183839True:[2 1 2 2 1 2] Pred:[2, 1, 2, 2, 1, 2]
MaxLen:19 Iter:2889999 Error:112.598129039True:[1 1 2] Pred:[2, 1, 1]
MaxLen:19 Iter:2899999 Error:186.041933391True:[2 2 2 1 1 2 1 2 2 1 1 2 2 1] Pred:[1, 2, 2, 1, 1, 2, 2, 1, 2, 1, 1, 2, 2, 2]
MaxLen:19 Iter:2909999 Error:236.064449725True:[2 2 2 1 1 2 2 1 2 2 1 1 1 1 1 2 2] Pred:[2, 2, 1, 1, 1, 1, 1, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1]
MaxLen:19 Iter:2919999 Error:152.776428031True:[1 1 2 1 1 1 1 2 2 1 1 1 2 2 1 2 2] Pred:[2, 2, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 2]
MaxLen:19 Iter:2929999 Error:143.007796452True:[1 2 1 1] Pred:[1, 1, 2, 1]
MaxLen:19 Iter:2939999 Error:255.744221264True:[2 2 1 1 1 2 1] Pred:[1, 2, 1, 1, 1, 2, 2]
MaxLen:19 Iter:2949999 Error:183.147078344True:[1 2 1 1 2 2 1 1 1 1 2 1 1 1 2 1] Pred:[1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 1, 2, 2]
MaxLen:19 Iter:2959999 Error:231.447857024True:[2 2 1 1] Pred:[1, 1, 2, 2]

&lt;/pre&gt;

&lt;h3&gt;Something Went Wrong!!!&lt;/h3&gt;

&lt;p&gt;At this point, I declared victory! I broke open a few brewskis and kicked back. Yay! Deepmind's Neural Stack before my very eyes! How bout it! Alas... I started taking things apart and realized that something was wrong... most notably these two things. Immediately after this log ending I printed out the following variables.&lt;/p&gt;

&lt;h4&gt;stack.u&lt;/h4&gt;
&lt;pre&gt;
[array([ 0.52627134]),
 array([ 0.48875265]),
 array([ 0.4833596]),
 array([ 0.51072936]),
 array([ 0.51525512]),
 array([ 0.55418935]),
 array([ 0.51561233]),
 array([ 0.54271031]),
 array([ 0.46972942]),
 array([ 0.50030726]),
 array([ 0.50420808]),
 array([ 0.51277284]),
 array([ 0.49249017]),
 array([ 0.52770061]),
 array([ 0.53647627]),
 array([ 0.52879516]),
 array([ 0.57190229]),
 array([ 0.51895631]),
 array([ 0.50232574]),
 array([ 0.44804661]),
 array([ 0.50789469]),
 array([ 0.53620111]),
 array([ 0.57897974]),
 array([ 0.53155877])]
&lt;/pre&gt;
&lt;h4&gt;satck.d&lt;/h4&gt;
&lt;pre&gt;
[array([ 1.]),
 array([ 1.]),
 array([ 1.]),
 array([ 1.]),
 array([ 1.]),
 array([ 1.]),
 array([ 1.]),
 array([ 1.]),
 array([ 1.]),
 array([ 1.]),
 array([ 1.]),
 array([ 1.]),
 array([ 1.]),
 array([ 1.]),
 array([ 1.]),
 array([ 1.]),
 array([ 1.]),
 array([ 1.]),
 array([ 1.]),
 array([ 1.]),
 array([ 1.]),
 array([ 1.]),
 array([ 1.]),
 array([ 1.])]
 &lt;/pre&gt;

&lt;p&gt;Disaster... the neural network somehow learned how to model these sequences by pushing all of them onto the stack and then only popping off each number half at a time. What does this mean? Honestly, it could certainly be that I didn't train long enough. What do we do? Andrew... why are you sharing this with us? Was this 30 pages of blogging all for nothing?!?!&lt;/p&gt;

&lt;p&gt;At this point, we have reached a very realistic point in a neural network researcher's lifecycle. Furthermore, it's one that the authors have discussed somewhat extensively both in the paper and in external presentations. If we're not careful, the network can discover less than expected ways of solving the problem that you give it. So, what do we do?&lt;/p&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;Part 6: When Things Really Get Interesting&lt;/h2&gt;

&lt;p&gt;I did end up getting the neural network to push and pop correctly. Here's the code. This blog is already like 80 pages long on my laptop so... Enjoy the puzzle!&lt;/p&gt;

&lt;p&gt;Hint: Autoencoder&lt;/p&gt;

&lt;pre class=&quot;brush: python&quot;&gt;

import numpy as np

def sigmoid(x):
    return 1/(1+np.exp(-x))

def sigmoid_out2deriv(out):
    return out * (1 - out)

def tanh(x):
    return np.tanh(x)

def tanh_out2deriv(out):
    return (1 - out**2)

def relu(x,deriv=False):
    if(deriv):
        return int(x &amp;gt;= 0)
    return max(0,x)

class NeuralStack():
    def __init__(self,stack_width=2,o_prime_dim=6):
        self.stack_width = stack_width
        self.o_prime_dim = o_prime_dim
        self.reset()
        
    def reset(self):
        # INIT STACK
        self.V = list() # stack states
        self.s = list() # stack strengths 
        self.d = list() # push strengths
        self.u = list() # pop strengths
        self.r = list()
        self.o = list()

        self.V_delta = list() # stack states
        self.s_delta = list() # stack strengths 
        self.d_error = list() # push strengths
        self.u_error = list() # pop strengths
        
        self.t = 0
        
    def pushAndPopForward(self,v_t,d_t,u_t):

        self.d.append(d_t)
        self.d_error.append(0)

        self.u.append(u_t)
        self.u_error.append(0)

        new_s = np.zeros(self.t+1)
        for i in xrange(self.t+1):
            new_s[i] = self.s_t(i)
        self.s.append(new_s)
        self.s_delta.append(np.zeros_like(new_s))

        if(len(self.V) == 0):
            V_t = np.zeros((0,self.stack_width))
        else:
            V_t = self.V[-1]
        self.V.append(np.concatenate((V_t,np.atleast_2d(v_t)),axis=0))
        self.V_delta.append(np.zeros_like(self.V[-1]))
        
        r_t = self.r_t()
        self.r.append(r_t)
        
        self.t += 1
        return r_t
    
    def s_t(self,i):
        if(i &amp;gt;= 0 and i &amp;lt; self.t):
            inner_sum = self.s[self.t-1][i+1:self.t-0]
            return relu(self.s[self.t-1][i] - relu(self.u[self.t] - np.sum(inner_sum)))
        elif(i == self.t):
            return self.d[self.t]
        else:
            print &quot;Problem&quot;
            
    def s_t_error(self,i,error):
        if(i &amp;gt;= 0 and i &amp;lt; self.t):
            if(self.s_t(i) &amp;gt;= 0):
                self.s_delta[self.t-1][i] += error
                if(relu(self.u[self.t] - np.sum(self.s[self.t-1][i+1:self.t-0])) &amp;gt;= 0):
                    self.u_error[self.t] -= error
                    self.s_delta[self.t-1][i+1:self.t-0] += error
        elif(i == self.t):
            self.d_error[self.t] += error
        else:
            print &quot;Problem&quot;
            
    def r_t(self):
        r_t_out = np.zeros(self.stack_width)
        for i in xrange(0,self.t+1):
            temp = min(self.s[self.t][i],relu(1 - np.sum(self.s[self.t][i+1:self.t+1])))
            r_t_out += temp * self.V[self.t][i]
        return r_t_out
            
    def r_t_error(self,r_t_error):
        for i in xrange(0, self.t+1):
            temp = min(self.s[self.t][i],relu(1 - np.sum(self.s[self.t][i+1:self.t+1])))
            self.V_delta[self.t][i] += temp * r_t_error
            temp_error = np.sum(r_t_error * self.V[self.t][i])

            if(self.s[self.t][i] &amp;lt; relu(1 - np.sum(self.s[self.t][i+1:self.t+1]))):
                self.s_delta[self.t][i] += temp_error
            else:
                if(relu(1 - np.sum(self.s[self.t][i+1:self.t+1])) &amp;gt; 0):
                    self.s_delta[self.t][i+1:self.t+1] -= temp_error # minus equal becuase of the (1-).. and drop the 1
    def backprop_single(self,r_t_error):
        self.t -= 1
        self.r_t_error(r_t_error)
        for i in reversed(xrange(self.t+1)):
            self.s_t_error(i,self.s_delta[self.t][i])
    
    def backprop(self,all_errors_in_order_of_training_data):
        errors = all_errors_in_order_of_training_data
        for error in reversed(list((errors))):
            self.backprop_single(error)

        
options = 2
sub_sequence_length = 5
sequence_length = sub_sequence_length*2

sequence = (np.random.random(sub_sequence_length)*options).astype(int)+2
sequence

X = np.zeros((sub_sequence_length*2,options+2))
Y = np.zeros_like(X)
for i in xrange(len(sequence)):
    X[i][sequence[i]] = 1
    X[-i-1][0] = 1
    X[i][1] = 1
    Y[-i-1][sequence[i]] = 1

sequence_length = len(X)
x_dim = X.shape[1]
h_dim = 8
o_prime_dim = 8
stack_width = 2
y_dim = Y.shape[1]


np.random.seed(1)
sub_sequence_length = 2

W_xh = (np.random.rand(x_dim,h_dim)*0.2) - 0.1
W_xh_update = np.zeros_like(W_xh)

W_hox = (np.random.rand(h_dim,x_dim)*0.2) - 0.1
W_hox_update = np.zeros_like(W_hox)

W_opx = (np.random.rand(o_prime_dim,x_dim)*0.2) - 0.1
W_opx_update = np.zeros_like(W_opx)

W_hh = (np.random.rand(h_dim,h_dim)*0.2) - 0.1
W_hh_update = np.zeros_like(W_hh)

W_rh = (np.random.rand(stack_width,h_dim)*0.2) - 0.1
W_rh_update = np.zeros_like(W_rh)

b_h = (np.random.rand(h_dim)*0.2) - 0.1
b_h_update = np.zeros_like(b_h)

W_hop = (np.random.rand(h_dim,o_prime_dim) * 0.2) - 0.1
W_hop_update = np.zeros_like(W_hop)

b_op = (np.random.rand(o_prime_dim)*0.2) - 0.1
b_op_update = np.zeros_like(b_op)

W_op_d = (np.random.rand(o_prime_dim,1)*0.2) - 0.1
W_op_d_update = np.zeros_like(W_op_d)

W_op_u = (np.random.rand(o_prime_dim,1)*0.2) - 0.1
W_op_u_update = np.zeros_like(W_op_u)

W_op_v = (np.random.rand(o_prime_dim,stack_width)*0.2) - 0.1
W_op_v_update = np.zeros_like(W_op_v)

W_op_o = (np.random.rand(o_prime_dim,y_dim)*0.2) - 0.1
W_op_o_update = np.zeros_like(W_op_o)

b_d = (np.random.rand(1)*0.2)+1
b_d_update = np.zeros_like(b_d)

b_u = (np.random.rand(1)*0.2)-1
b_u_update = np.zeros_like(b_u)

b_v = (np.random.rand(stack_width)*0.2)-0.1
b_v_update = np.zeros_like(b_v)

b_o = (np.random.rand(y_dim)*0.2)-0.1
b_o_update = np.zeros_like(b_o)

error = 0
reconstruct_error = 0
reconstruct_error_2 = 0
max_len = 3
batch_size = 50
for it in xrange(750000):
    
#     if(it % 100 == 0):
    sub_sequence_length = np.random.randint(max_len)+3
    sequence = (np.random.random(sub_sequence_length)*options).astype(int)+2
    sequence

    X = np.zeros((sub_sequence_length*2,options+2))
    Y = np.zeros_like(X)
    for i in xrange(len(sequence)):
        X[i][sequence[i]] = 1
        X[-i-1][0] = 1
        X[i][1] = 1
        Y[-i-1][sequence[i]] = 1
            

    layers = list()
    stack = NeuralStack(stack_width=stack_width,o_prime_dim=o_prime_dim)    
    for i in xrange(len(X)):
        layer = {}

        layer['x'] = X[i]

        if(i == 0):
            layer['h_t-1'] = np.zeros(h_dim)
#             layer['h_t-1'][0] = 1
            layer['r_t-1'] = np.zeros(stack_width)
#             layer['r_t-1'][0] = 1
        else:
            layer['h_t-1'] = layers[i-1]['h_t']
            layer['r_t-1'] = layers[i-1]['r_t']

        layer['h_t'] = tanh(np.dot(layer['x'],W_xh) + np.dot(layer['h_t-1'],W_hh) + np.dot(layer['r_t-1'],W_rh) + b_h)
        layer['xo_t'] = sigmoid(np.dot(layer['h_t'],W_hox))
        layer['o_prime_t'] = tanh(np.dot(layer['h_t'],W_hop)+b_op)
        layer['o_prime_x_t'] = sigmoid(np.dot(layer['o_prime_t'],W_opx))
        layer['o_t'] = sigmoid(np.dot(layer['o_prime_t'],W_op_o) + b_o)

        if(i &amp;lt; len(X)-1):
            layer['d_t'] = sigmoid(np.dot(layer['o_prime_t'],W_op_d) + b_d)
            layer['u_t'] = sigmoid(np.dot(layer['o_prime_t'],W_op_u) + b_u)
            layer['v_t'] = tanh(np.dot(layer['o_prime_t'],W_op_v) + b_v)

            layer['r_t'] = stack.pushAndPopForward(layer['v_t'],layer['d_t'],layer['u_t'])

        layers.append(layer)

    for i in list(reversed(xrange(len(X)))):
        layer = layers[i]

        layer['o_t_error'] = (Y[i] - layer['o_t'])

        if(i&amp;gt;0):
            layer['xo_t_error'] = layers[i-1]['x'] - layer['xo_t']
            layer['xo_t_delta'] = layer['xo_t_error'] * sigmoid_out2deriv(layer['xo_t'])            
            
            layer['x_o_prime_x_t_error'] = (layers[i-1]['x'] - layer['o_prime_x_t'])
            layer['x_o_prime_x_t_delta'] = layer['x_o_prime_x_t_error'] * sigmoid_out2deriv(layer['o_prime_x_t'])
        else:
            layer['xo_t_delta'] = np.zeros_like(layer['x'])
            layer['x_o_prime_x_t_delta'] = np.zeros_like(layer['x'])
#         if(it &amp;gt; 2000):
        layer['xo_t_delta'] *= 1
        layer['x_o_prime_x_t_delta'] *= 1
        

        error += np.sum(np.abs(layer['o_t_error']))
        if(i &amp;gt; 0):
            reconstruct_error += np.sum(np.abs(layer['xo_t_error']))
            reconstruct_error_2 += np.sum(np.abs(layer['x_o_prime_x_t_error']))
        if(it % 100 == 99):
            if(i == len(X)-1):
    
                if(it % 1000 == 999):
                    print &quot;MaxLen:&quot;+str(max_len)+ &quot; Iter:&quot; + str(it) + &quot; Error:&quot; + str(error)+ &quot; RecError:&quot; + str(reconstruct_error) + &quot; RecError2:&quot;+ str(reconstruct_error_2) + &quot; True:&quot; + str(sequence) + &quot; Pred:&quot; + str(map(lambda x:np.argmax(x['o_t']),layers[sub_sequence_length:]))
                    if(it % 10000 == 9999):
                        print &quot;U:&quot; + str(np.array(stack.u).T[0])
                        print &quot;D:&quot; + str(np.array(stack.d).T[0])
#                     print &quot;o_t:&quot;
#                     for l in layers[sub_sequence_length:]:
#                         print l['o_t'] 
#                     print &quot;V_t:&quot;
#                     for row in stack.V[-1]:
#                         print row
                if(error &amp;lt; max_len+4 and it &amp;gt; 10000):
                    max_len += 1
                    it = 0
                error = 0
                reconstruct_error = 0
                reconstruct_error_2 = 0

        layer['o_t_delta'] = layer['o_t_error'] * sigmoid_out2deriv(layer['o_t'])

        layer['o_prime_t_error'] = np.dot(layer['o_t_delta'],W_op_o.T)
        layer['o_prime_t_error'] += np.dot(layer['x_o_prime_x_t_delta'],W_opx.T)
        if(i &amp;lt; len(X)-1):
            layer['r_t_error'] = layers[i+1]['r_t-1_error']
            stack.backprop_single(layer['r_t_error'])

            layer['v_t_error'] = stack.V_delta[i][i]
            layer['v_t_delta'] = layer['v_t_error'] * tanh_out2deriv(layer['v_t'])
            layer['o_prime_t_error'] += np.dot(layer['v_t_delta'],W_op_v.T)

            layer['u_t_error'] = stack.u_error[i]
            layer['u_t_delta'] = layer['u_t_error'] * sigmoid_out2deriv(layer['u_t'])
            layer['o_prime_t_error'] += np.dot(layer['u_t_delta'],W_op_u.T)

            layer['d_t_error'] = stack.d_error[i]
            layer['d_t_delta'] = layer['d_t_error'] * sigmoid_out2deriv(layer['d_t'])
            layer['o_prime_t_error'] += np.dot(layer['d_t_delta'],W_op_d.T)


        layer['o_prime_t_delta'] = layer['o_prime_t_error'] * tanh_out2deriv(layer['o_prime_t'])
        layer['h_t_error'] = np.dot(layer['o_prime_t_delta'],W_hop.T)
        layer['h_t_error'] += np.dot(layer['xo_t_delta'],W_hox.T)
        if(i &amp;lt; len(X)-1):
            layer['h_t_error'] += layers[i+1]['h_t-1_error']

        layer['h_t_delta'] = layer['h_t_error'] * tanh_out2deriv(layer['h_t'])
        layer['h_t-1_error'] = np.dot(layer['h_t_delta'],W_hh.T)
        layer['r_t-1_error'] = np.dot(layer['h_t_delta'],W_rh.T)

    for i in xrange(len(X)):
        layer = layers[i]
        if(it&amp;lt;2000):
            max_alpha = 0.05 * batch_size
#         else:
#             max_alpha = 0.05 * batch_size
        alpha = max_alpha / sub_sequence_length

        W_xh_update += alpha * np.outer(layer['x'],layer['h_t_delta'])
        W_hh_update += alpha * np.outer(layer['h_t-1'],layer['h_t_delta'])
        W_rh_update += alpha * np.outer(layer['r_t-1'],layer['h_t_delta'])
        W_hox_update += alpha * np.outer(layer['h_t'],layer['xo_t_delta'])
        
        b_h_update += alpha * layer['h_t_delta']

        W_hop_update += alpha * np.outer(layer['h_t'],layer['o_prime_t_delta'])
        b_op_update += alpha * layer['o_prime_t_delta']
        
        W_opx_update += alpha * np.outer(layer['o_prime_t'],layer['x_o_prime_x_t_delta'])
        
        if(i &amp;lt; len(X)-1):
            W_op_d_update += alpha * np.outer(layer['o_prime_t'],layer['d_t_delta'])
            W_op_u_update += alpha * np.outer(layer['o_prime_t'],layer['u_t_delta'])
            W_op_v_update += alpha * np.outer(layer['o_prime_t'],layer['v_t_delta'])

            b_d_update += alpha * layer['d_t_delta']# * 10
            b_u_update += alpha * layer['u_t_delta']# * 10
            b_v_update += alpha * layer['v_t_delta']

        W_op_o_update += alpha * np.outer(layer['o_prime_t'],layer['o_t_delta'])
        b_o_update += alpha * layer['o_t_delta']


    if(it % batch_size == (batch_size-1)):
        W_xh += W_xh_update/batch_size
        W_xh_update *= 0
        
        W_hh += W_hh_update/batch_size
        W_hh_update *= 0
        
        W_rh += W_rh_update/batch_size
        W_rh_update *= 0
        
        b_h += b_h_update/batch_size
        b_h_update *= 0
        
        W_hop += W_hop_update/batch_size
        W_hop_update *= 0
        
        b_op += b_op_update/batch_size
        b_op_update *= 0
        
        W_op_d += W_op_d_update/batch_size
        W_op_d_update *= 0
        
        W_op_u += W_op_u_update/batch_size
        W_op_u_update *= 0
        
        W_op_v += W_op_v_update/batch_size
        W_op_v_update *= 0
        
        W_opx += W_opx_update/batch_size
        W_opx_update *= 0
        
        W_hox += W_hox_update/batch_size
        W_hox_update *= 0
        
        b_d += b_d_update/batch_size
        b_d_update *= 0
        
        b_u += b_u_update/batch_size
        b_u_update *= 0
        
        b_v += b_v_update/batch_size
        b_v_update *= 0
        
        W_op_o += W_op_o_update/batch_size
        W_op_o_update *= 0
        
        b_o += b_o_update/batch_size
        b_o_update *= 0

&lt;/pre&gt;
&lt;h3&gt;Training Time Output&lt;/h3&gt;
&lt;pre&gt;
....
....
....
....
MaxLen:3 Iter:745999 Error:7.56448795544 RecError:7.10891969494 RecError2:5.73615942287 True:[3 3 2 2 3] Pred:[3, 2, 2, 3, 3]
MaxLen:3 Iter:746999 Error:7.40633215737 RecError:6.69030096695 RecError2:6.19218015399 True:[3 2 3 2] Pred:[2, 3, 2, 3]
MaxLen:3 Iter:747999 Error:7.6670587332 RecError:7.00484905169 RecError2:5.98610855847 True:[2 2 2 2 2] Pred:[2, 2, 2, 2, 2]
MaxLen:3 Iter:748999 Error:7.58710695632 RecError:7.25143585612 RecError2:6.02631960485 True:[2 3 2] Pred:[2, 3, 2]
MaxLen:3 Iter:749999 Error:7.36136812467 RecError:7.05922903111 RecError2:5.87101840726 True:[3 3 2 3 2] Pred:[2, 3, 2, 3, 3]
U:[  1.42111936e-03   4.24234116e-05   4.38773521e-05   1.90306228e-03
   4.46779468e-05   1.61383041e-03   9.99610386e-01   9.76241526e-01
   9.99635875e-01]
D:[  9.96007159e-01   9.98850792e-01   9.98678243e-01   9.93183510e-01
   9.98787118e-01   2.95677776e-02   4.76367458e-04   4.53054877e-04
   5.11268758e-04]
&lt;/pre&gt;

&lt;h3&gt; Known Deviations / Ambiguities From the Paper (and Reasons)&lt;/h3&gt;
&lt;p&gt;&lt;b&gt;1: &lt;/b&gt;The Controller is an RNN instead of an LSTM. I haven't finished the blogpost on LSTMs yet, and I wanted to only used previous blogposts as pre-requisite information.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;2: &lt;/b&gt;Instead of padding using a single buffer token to signify when to repeat the sequence back, I turned the single buffer on turing all of encoding and off for all of decoding. This is related to not having an LSTM to save the binary state. RNNs lose this kind of information and I wanted the network to converge quickly when training on the CPUs of this blog's readership.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;3: &lt;/b&gt;I didn't see specifics on which nonlinearities were used in the RNN or how all the various weights were initialized. I chose to use best practices&lt;/p&gt;
&lt;p&gt;&lt;b&gt;4: &lt;/b&gt;I trained this with a minibatch size of 50 instead of 10.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;5: &lt;/b&gt;The hidden layers are considerably smaller. This also falls in the category of &quot;getting it to converge faster for readers&quot;. However, small hidden layers also force the network to use the stack, which seems like a good reason to use them.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;6: &lt;/b&gt;Not sure how many epochs this was trained on originally.
&lt;p&gt;&lt;b&gt;7: &lt;/b&gt;And of course... this was written in python using just a matrix library as opposed to Torch's deep learning framework. There are likely small things done as a best practice implicit into Torch's framework that might not be represented here.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;8: &lt;/b&gt;I haven't attempted Queues or DeQueues yet... but in theory it's just a matter of swapping out the Neural Stack... that'd be a great project for a reader if you want to take this to the next level!&lt;/p&gt;
&lt;p&gt;&lt;b&gt;9: &lt;/b&gt;My timeframe for writing this blogpost was quite short. The post itself was written in &amp;lt; 24 hours. I'd like to do further experimentation with LSTMs and more benchmarking relative to the posted results in the paper. This, however, is primarily a teaching tool.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;10: &lt;/b&gt;I haven't actually checked the backpropagation against the formulas in Appendix A of the paper. Again.. time constraint and I thought it would be more fun to try to figure them out independently.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;11: &lt;/b&gt;I wasn't sure if o_prime_t was really generated as a PART of the recurrent hidden layer or if it was supposed to be one layer deeper (with a matrix between the recurrent hidden layer and o_prime). I assumed the latter but the former could be possible. If you happen to be an author on the paper and you're reading this far, I'd love to know.&lt;/p&gt;

&lt;p&gt;If you have questions or comments, tweet &lt;a href=&quot;https://twitter.com/iamtrask&quot;&gt;&lt;b&gt;@iamtrask&lt;/b&gt;&lt;/a&gt; and I'll be happy to help.&lt;/p&gt;

&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/shCore.css&quot; /&gt;
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/shThemeDefault.css&quot; /&gt;
&lt;script src=&quot;/js/shCore.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/js/shLegacy.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/js/shBrushPython.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
	// SyntaxHighlighter.config.bloggerMode = true;
	SyntaxHighlighter.config.toolbar = true;
    SyntaxHighlighter.all();
&lt;/script&gt;
&lt;/p&gt;
</description>
        <pubDate>Thu, 25 Feb 2016 12:00:00 +0000</pubDate>
        <link>http://localhost:4000/2016/02/25/deepminds-neural-stack-machine/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/02/25/deepminds-neural-stack-machine/</guid>
        
        
      </item>
    
      <item>
        <title>Anyone Can Learn To Code an LSTM-RNN in Python (Part 1: RNN)</title>
        <description>&lt;p&gt;&lt;b&gt;Summary:&lt;/b&gt; I learn best with toy code that I can play with. This tutorial teaches Recurrent Neural Networks via a very simple toy example, a short python implementation.&lt;/p&gt;

&lt;p&gt;I'll tweet out &lt;b&gt;(Part 2: LSTM)&lt;/b&gt; when it's complete at &lt;a href=&quot;https://twitter.com/iamtrask&quot;&gt;@iamtrask&lt;/a&gt;. Feel free to follow if you'd be interested in reading it and thanks for all the feedback!
&lt;/p&gt;
&lt;h3&gt;Just Give Me The Code:&lt;/h3&gt;
&lt;pre class=&quot;brush: python&quot;&gt;
import copy, numpy as np
np.random.seed(0)

# compute sigmoid nonlinearity
def sigmoid(x):
    output = 1/(1+np.exp(-x))
    return output

# convert output of sigmoid function to its derivative
def sigmoid_output_to_derivative(output):
    return output*(1-output)


# training dataset generation
int2binary = {}
binary_dim = 8

largest_number = pow(2,binary_dim)
binary = np.unpackbits(
    np.array([range(largest_number)],dtype=np.uint8).T,axis=1)
for i in range(largest_number):
    int2binary[i] = binary[i]


# input variables
alpha = 0.1
input_dim = 2
hidden_dim = 16
output_dim = 1


# initialize neural network weights
synapse_0 = 2*np.random.random((input_dim,hidden_dim)) - 1
synapse_1 = 2*np.random.random((hidden_dim,output_dim)) - 1
synapse_h = 2*np.random.random((hidden_dim,hidden_dim)) - 1

synapse_0_update = np.zeros_like(synapse_0)
synapse_1_update = np.zeros_like(synapse_1)
synapse_h_update = np.zeros_like(synapse_h)

# training logic
for j in range(10000):
    
    # generate a simple addition problem (a + b = c)
    a_int = np.random.randint(largest_number/2) # int version
    a = int2binary[a_int] # binary encoding

    b_int = np.random.randint(largest_number/2) # int version
    b = int2binary[b_int] # binary encoding

    # true answer
    c_int = a_int + b_int
    c = int2binary[c_int]
    
    # where we'll store our best guess (binary encoded)
    d = np.zeros_like(c)

    overallError = 0
    
    layer_2_deltas = list()
    layer_1_values = list()
    layer_1_values.append(np.zeros(hidden_dim))
    
    # moving along the positions in the binary encoding
    for position in range(binary_dim):
        
        # generate input and output
        X = np.array([[a[binary_dim - position - 1],b[binary_dim - position - 1]]])
        y = np.array([[c[binary_dim - position - 1]]]).T

        # hidden layer (input ~+ prev_hidden)
        layer_1 = sigmoid(np.dot(X,synapse_0) + np.dot(layer_1_values[-1],synapse_h))

        # output layer (new binary representation)
        layer_2 = sigmoid(np.dot(layer_1,synapse_1))

        # did we miss?... if so, by how much?
        layer_2_error = y - layer_2
        layer_2_deltas.append((layer_2_error)*sigmoid_output_to_derivative(layer_2))
        overallError += np.abs(layer_2_error[0])
    
        # decode estimate so we can print it out
        d[binary_dim - position - 1] = np.round(layer_2[0][0])
        
        # store hidden layer so we can use it in the next timestep
        layer_1_values.append(copy.deepcopy(layer_1))
    
    future_layer_1_delta = np.zeros(hidden_dim)
    
    for position in range(binary_dim):
        
        X = np.array([[a[position],b[position]]])
        layer_1 = layer_1_values[-position-1]
        prev_layer_1 = layer_1_values[-position-2]
        
        # error at output layer
        layer_2_delta = layer_2_deltas[-position-1]
        # error at hidden layer
        layer_1_delta = (future_layer_1_delta.dot(synapse_h.T) + layer_2_delta.dot(synapse_1.T)) * sigmoid_output_to_derivative(layer_1)

        # let's update all our weights so we can try again
        synapse_1_update += np.atleast_2d(layer_1).T.dot(layer_2_delta)
        synapse_h_update += np.atleast_2d(prev_layer_1).T.dot(layer_1_delta)
        synapse_0_update += X.T.dot(layer_1_delta)
        
        future_layer_1_delta = layer_1_delta
    

    synapse_0 += synapse_0_update * alpha
    synapse_1 += synapse_1_update * alpha
    synapse_h += synapse_h_update * alpha    

    synapse_0_update *= 0
    synapse_1_update *= 0
    synapse_h_update *= 0
    
    # print out progress
    if(j % 1000 == 0):
        print &quot;Error:&quot; + str(overallError)
        print &quot;Pred:&quot; + str(d)
        print &quot;True:&quot; + str(c)
        out = 0
        for index,x in enumerate(reversed(d)):
            out += x*pow(2,index)
        print str(a_int) + &quot; + &quot; + str(b_int) + &quot; = &quot; + str(out)
        print &quot;------------&quot;

        
&lt;/pre&gt;
&lt;h3&gt;Runtime Output:&lt;/h3&gt;
&lt;pre&gt;
Error:[ 3.45638663]
Pred:[0 0 0 0 0 0 0 1]
True:[0 1 0 0 0 1 0 1]
9 + 60 = 1
------------
Error:[ 3.63389116]
Pred:[1 1 1 1 1 1 1 1]
True:[0 0 1 1 1 1 1 1]
28 + 35 = 255
------------
Error:[ 3.91366595]
Pred:[0 1 0 0 1 0 0 0]
True:[1 0 1 0 0 0 0 0]
116 + 44 = 72
------------
Error:[ 3.72191702]
Pred:[1 1 0 1 1 1 1 1]
True:[0 1 0 0 1 1 0 1]
4 + 73 = 223
------------
Error:[ 3.5852713]
Pred:[0 0 0 0 1 0 0 0]
True:[0 1 0 1 0 0 1 0]
71 + 11 = 8
------------
Error:[ 2.53352328]
Pred:[1 0 1 0 0 0 1 0]
True:[1 1 0 0 0 0 1 0]
81 + 113 = 162
------------
Error:[ 0.57691441]
Pred:[0 1 0 1 0 0 0 1]
True:[0 1 0 1 0 0 0 1]
81 + 0 = 81
------------
Error:[ 1.42589952]
Pred:[1 0 0 0 0 0 0 1]
True:[1 0 0 0 0 0 0 1]
4 + 125 = 129
------------
Error:[ 0.47477457]
Pred:[0 0 1 1 1 0 0 0]
True:[0 0 1 1 1 0 0 0]
39 + 17 = 56
------------
Error:[ 0.21595037]
Pred:[0 0 0 0 1 1 1 0]
True:[0 0 0 0 1 1 1 0]
11 + 3 = 14
------------
&lt;/pre&gt;

&lt;hr /&gt;

&lt;script async=&quot;&quot; src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;

&lt;!-- Part 1 --&gt;
&lt;p&gt;&lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px;text-align:center&quot; data-ad-client=&quot;ca-pub-6751104560361558&quot; data-ad-slot=&quot;2365390629&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;Part 1: What is Neural Memory?&lt;/h2&gt;

&lt;p&gt;List the alphabet forward.... you can do it, yes?&lt;/p&gt;
&lt;p&gt;List the alphabet backward.... hmmm... perhaps a bit tougher.&lt;/p&gt;
&lt;p&gt;Try with the lyrics of a song you know?.... Why is it easier to recall forward than it is to recall backward? Can you jump into the middle of the second verse?... hmm... also difficult. Why?&lt;/p&gt;
&lt;p&gt;There's a very logical reason for this....you haven't learned the letters of the alphabet or the lyrics of a song like a computer storing them as a set on a hard drive. You learned them as a &lt;b&gt;sequence&lt;/b&gt;. You are really good at indexing from one letter to the next. It's a kind of conditional memory... you only have it when you very recently had the previous memory. It's also a lot like a &lt;b&gt;linked list&lt;/b&gt; if you're familiar with that.&lt;/p&gt;

&lt;p&gt;However, it's not that you &lt;i&gt;don't&lt;/i&gt; have the song in your memory except when you're singing it. Instead, when you try to jump straight to the middle of the song, you simply have a hard time finding that representation in your brain (perhaps that set of neurons). It starts searching all over looking for the middle of the song, but it hasn't tried to look for it this way before, so it doesn't have a map to the location of the middle of the second verse. It's a lot like living in a neighborhood with lots of coves/cul-de-sacs. It's much easier to picture how to get to someone's house by following all the windy roads because you've done it many times, but knowing exactly where to cut straight across someone's backyard is really difficult. Your brain instead uses the &quot;directions&quot; that it knows... through the neurons at the beginning of a song. (for more on brain stuff, click &lt;a href=&quot;http://www.human-memory.net/processes_recall.html&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Much like a linked list, storing memory like this is very efficient. We will find that similar properties/advantages exist in giving our neural networks this type of memory as well. Some processes/problems/representations/searches are far more efficient if modeled as a sequence with a short term / pseudo conditional memory.&lt;/p&gt;

&lt;p&gt;Memory matters when your data is a &lt;b&gt;sequence&lt;/b&gt; of some kind. (It means you have something to remember!) Imagine having a video of a bouncing ball. (here... i'll help this time)&lt;br /&gt;&lt;br /&gt;
&lt;center&gt;&lt;iframe width=&quot;700&quot; height=&quot;525&quot; src=&quot;https://www.youtube.com/embed/UL0ZOgN2SqY?loop=1&amp;amp;autoplay=0&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;br /&gt;&lt;br /&gt;&lt;/center&gt;&lt;br /&gt;
Each data point is a frame of your video. If you wanted to train a neural network to predict where the ball would be in the next frame, it would be really helpful to know where the ball was in the last frame! Sequential data like this is why we build recurrent neural networks. So, how does a neural network remember what it saw in previous time steps?&lt;/p&gt;

&lt;p&gt;Neural networks have hidden layers. Normally, the state of your hidden layer is &lt;b&gt;based ONLY on your input data&lt;/b&gt;. So, normally a neural network's information flow would look like this:&lt;br /&gt;
&lt;center&gt;&lt;b&gt;input -&amp;gt; hidden -&amp;gt; output&lt;/b&gt;&lt;/center&gt;
&lt;br /&gt;

&lt;p&gt;This is straightforward. Certain types of input create certain types of hidden layers. Certain types of hidden layers create certain types of output layers. It's kindof a closed system. Memory changes this. Memory means that the hidden layer is a combination of your input data at the current timestep &lt;b&gt;and the hidden layer of the previous timestep&lt;/b&gt;.&lt;/p&gt;

&lt;center&gt;&lt;b&gt;(input + prev_hidden) -&amp;gt; hidden -&amp;gt; output&lt;/b&gt;&lt;/center&gt;
&lt;p&gt;
Why the hidden layer? Well, we could technically do this.
&lt;/p&gt;
&lt;center&gt;&lt;b&gt;(input + prev_input) -&amp;gt; hidden -&amp;gt; output&lt;/b&gt;&lt;/center&gt;

&lt;p&gt;However, we'd be missing out. I encourage you to sit and consider the difference between these two information flows. For a little helpful hint, consider how this plays out. Here, we have 4 timesteps of a recurrent neural network pulling information from the previous hidden layer.&lt;/p&gt;

&lt;center&gt;&lt;b&gt;(input + empty_hidden) -&amp;gt; hidden -&amp;gt; output&lt;/b&gt;&lt;/center&gt;
&lt;center&gt;&lt;b&gt;(input + prev_hidden) -&amp;gt; hidden -&amp;gt; output&lt;/b&gt;&lt;/center&gt;
&lt;center&gt;&lt;b&gt;(input + prev_hidden) -&amp;gt; hidden -&amp;gt; output&lt;/b&gt;&lt;/center&gt;
&lt;center&gt;&lt;b&gt;(input + prev_hidden) -&amp;gt; hidden -&amp;gt; output&lt;/b&gt;&lt;/center&gt;

&lt;p&gt;And here, we have 4 timesteps of a recurrent neural network pulling information from the previous input layer&lt;/p&gt;

&lt;center&gt;&lt;b&gt;(input + empty_input) -&amp;gt; hidden -&amp;gt; output&lt;/b&gt;&lt;/center&gt;
&lt;center&gt;&lt;b&gt;(input + prev_input) -&amp;gt; hidden -&amp;gt; output&lt;/b&gt;&lt;/center&gt;
&lt;center&gt;&lt;b&gt;(input + prev_input) -&amp;gt; hidden -&amp;gt; output&lt;/b&gt;&lt;/center&gt;
&lt;center&gt;&lt;b&gt;(input + prev_input) -&amp;gt; hidden -&amp;gt; output&lt;/b&gt;&lt;/center&gt;

&lt;p&gt;Maybe, if I colored things a bit, it would become more clear. Again, 4 timesteps with &lt;b&gt;hidden layer recurrence&lt;/b&gt;:&lt;/p&gt;

&lt;center&gt;&lt;b&gt;(&lt;font color=&quot;blue&quot;&gt;input&lt;/font&gt; + empty_hidden) -&amp;gt; &lt;font color=&quot;blue&quot;&gt;hidden&lt;/font&gt; -&amp;gt; output&lt;/b&gt;&lt;/center&gt;
&lt;center&gt;&lt;b&gt;(&lt;font color=&quot;red&quot;&gt;input&lt;/font&gt; + prev_&lt;font color=&quot;blue&quot;&gt;hidden&lt;/font&gt;) -&amp;gt; &lt;font color=&quot;red&quot;&gt;hid&lt;/font&gt;&lt;font color=&quot;blue&quot;&gt;den&lt;/font&gt; -&amp;gt; output&lt;/b&gt;&lt;/center&gt;
&lt;center&gt;&lt;b&gt;(&lt;font color=&quot;green&quot;&gt;input&lt;/font&gt; + prev_&lt;font color=&quot;red&quot;&gt;hid&lt;/font&gt;&lt;font color=&quot;blue&quot;&gt;den&lt;/font&gt;) -&amp;gt; &lt;font color=&quot;green&quot;&gt;hi&lt;/font&gt;&lt;font color=&quot;red&quot;&gt;dd&lt;/font&gt;&lt;font color=&quot;blue&quot;&gt;en&lt;/font&gt; -&amp;gt; output&lt;/b&gt;&lt;/center&gt;
&lt;center&gt;&lt;b&gt;(&lt;font color=&quot;purple&quot;&gt;input&lt;/font&gt; + prev_&lt;font color=&quot;green&quot;&gt;hi&lt;/font&gt;&lt;font color=&quot;red&quot;&gt;dd&lt;/font&gt;&lt;font color=&quot;blue&quot;&gt;en&lt;/font&gt; ) -&amp;gt; &lt;font color=&quot;purple&quot;&gt;hi&lt;/font&gt;&lt;font color=&quot;red&quot;&gt;d&lt;/font&gt;&lt;font color=&quot;green&quot;&gt;de&lt;/font&gt;&lt;font color=&quot;blue&quot;&gt;n&lt;/font&gt; -&amp;gt; output&lt;/b&gt;&lt;/center&gt;

&lt;p&gt;.... and 4 timesteps with &lt;b&gt;input layer recurrence&lt;/b&gt;....&lt;/p&gt;

&lt;center&gt;&lt;b&gt;(&lt;font color=&quot;blue&quot;&gt;input&lt;/font&gt; + empty_input) -&amp;gt; &lt;font color=&quot;blue&quot;&gt;hidden&lt;/font&gt; -&amp;gt; output&lt;/b&gt;&lt;/center&gt;
&lt;center&gt;&lt;b&gt;(&lt;font color=&quot;red&quot;&gt;input&lt;/font&gt; + prev_&lt;font color=&quot;blue&quot;&gt;input&lt;/font&gt;) -&amp;gt; &lt;font color=&quot;red&quot;&gt;hid&lt;/font&gt;&lt;font color=&quot;blue&quot;&gt;den&lt;/font&gt; -&amp;gt; output&lt;/b&gt;&lt;/center&gt;
&lt;center&gt;&lt;b&gt;(&lt;font color=&quot;green&quot;&gt;input&lt;/font&gt; + prev_&lt;font color=&quot;red&quot;&gt;input&lt;/font&gt;) -&amp;gt; &lt;font color=&quot;green&quot;&gt;hid&lt;/font&gt;&lt;font color=&quot;red&quot;&gt;den&lt;/font&gt; -&amp;gt; output&lt;/b&gt;&lt;/center&gt;
&lt;center&gt;&lt;b&gt;(&lt;font color=&quot;purple&quot;&gt;input&lt;/font&gt; + prev_&lt;font color=&quot;green&quot;&gt;input&lt;/font&gt;) -&amp;gt; &lt;font color=&quot;purple&quot;&gt;hid&lt;/font&gt;&lt;font color=&quot;green&quot;&gt;den&lt;/font&gt; -&amp;gt; output&lt;/b&gt;&lt;/center&gt;

&lt;p&gt;Focus on the last hidden layer (4th line). In the hidden layer recurrence, we see a presence of every input seen so far. In the input layer recurrence, it's exclusively defined by the current and previous inputs. This is why we model hidden recurrence. Hidden recurrence &lt;b&gt;learns what to remember&lt;/b&gt; whereas input recurrence is hard wired to just remember the immediately previous datapoint. &lt;/p&gt;

&lt;p&gt;Now compare and contrast these two approaches with the backwards alphabet and middle-of-song exercises. The hidden layer is constantly changing as it gets more inputs. Furthermore, the only way that we could reach these hidden states is with the correct &lt;b&gt;sequence&lt;/b&gt; of inputs. Now the money statement, the output is deterministic given the hidden layer, and the hidden layer is only reachable with the right &lt;b&gt;sequence&lt;/b&gt; of inputs. Sound familiar?&lt;/p&gt;

&lt;p&gt;What's the practical difference? Let's say we were trying to predict the next word in a song given the previous. The &quot;input layer recurrence&quot; would break down if the song accidentally had the same sequence of two words in multiple places. Think about it, if the song had the statements &quot;I love you&quot;, and &quot;I love carrots&quot;, and the network was trying to predict the next word, how would it know what follows &quot;I love&quot;? It could be carrots. It could be you. The network REALLY needs to know more about what part of the song its in. However, the &quot;hidden layer recurrence&quot; doesn't break down in this way. It subtely remembers everything it saw (with memories becoming more subtle as it they fade into the past). To see this in action, check out &lt;a href=&quot;http://karpathy.github.io/2015/05/21/rnn-effectiveness/&quot; target=&quot;_blank&quot;&gt; this&lt;/a&gt;. 

&lt;center&gt;&lt;b&gt;stop and make sure this feels comfortable in your mind&lt;/b&gt;&lt;/center&gt;&lt;br /&gt;

&lt;hr /&gt;
&lt;script async=&quot;&quot; src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- Part 2 --&gt;
&lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px;text-align:center&quot; data-ad-client=&quot;ca-pub-6751104560361558&quot; data-ad-slot=&quot;3842123822&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;hr /&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;Part 2: RNN - Neural Network Memory&lt;/h2&gt;

&lt;p&gt;Now that we have the intuition, let's dive down a layer (ba dum bump...). As described in the &lt;a href=&quot;http://iamtrask.github.io/2015/07/12/basic-python-network/&quot;&gt;&lt;u&gt;backpropagation post&lt;/u&gt;&lt;/a&gt;, our input layer to the neural network is determined by our input dataset. Each row of input data is used to generate the hidden layer (via forward propagation). Each hidden layer is then used to populate the output layer (assuming only 1 hidden layer). As we just saw, memory means that the hidden layer is a combination of the input data and the previous hidden layer. How is this done? Well, much like every other propagation in neural networks, it's done with a matrix. This matrix defines the relationship between the previous hidden layer and the current one.&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/basic_recurrence_singleton.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;Big thing to take from this picture, there are only three weight matrices. Two of them should be very familiar (same names too). SYNAPSE_0 propagates the input data to the hidden layer. SYNAPSE_1 propagates the hidden layer to the output data. The new matrix (SYNAPSE_h....the recurrent one), propagates from the hidden layer (layer_1) to the hidden layer at the next timestep (still layer_1).

&lt;center&gt;&lt;b&gt;stop and make sure this feels comfortable in your mind&lt;/b&gt;&lt;/center&gt;&lt;br /&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;95%&quot; src=&quot;/img/recurrence_gif.gif&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;The gif above reflects the magic of recurrent networks, and several very, very important properties. It depicts 4 timesteps. The first is exclusively influenced by the input data. The second one is a mixture of the first and second inputs. This continues on. You should recognize that, in some way, network 4 is &quot;full&quot;. Presumably, timestep 5 would have to choose which memories to keep and which ones to overwrite. This is very real. It's the notion of memory &quot;capacity&quot;. As you might expect, bigger layers can hold more memories for a longer period of time. Also, this is when the network learns to &lt;b&gt;forget irrelevant memories&lt;/b&gt; and &lt;b&gt;remember important memories&lt;/b&gt;. What significant thing do you notice in timestep 3? Why is there more &lt;font color=&quot;green&quot;&gt;green&lt;/font&gt; in the hidden layer than the other colors?&lt;/p&gt;

&lt;p&gt;Also notice that the hidden layer is the barrier between the input and the output. In reality, the output is no longer a pure function of the input. The input is just changing what's in the memory, and the output is exclusively based on the memory. Another interesting takeaway. If there was no input at timesteps 2,3,and 4, the hidden layer would still change from timestep to timestep.&lt;/p&gt;

&lt;center&gt;&lt;b&gt;i know i've been stopping... but really make sure you got that last bit&lt;/b&gt;&lt;/center&gt;&lt;br /&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;Part 3: Backpropagation Through Time:&lt;/h2&gt;

&lt;p&gt;So, how do recurrent neural networks learn? Check out this graphic. Black is the prediction, errors are bright yellow, derivatives are mustard colored.&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;95%&quot; src=&quot;/img/backprop_through_time.gif&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;They learn by fully propagating forward from 1 to 4 (through an entire sequence of arbitrary length), and then backpropagating all the derivatives from 4 back to 1. You can also pretend that it's just a funny shaped normal neural network, except that we're re-using the same weights (synapses 0,1,and h) in their respective places. Other than that, it's normal backpropagation.

&lt;hr /&gt;
&lt;script async=&quot;&quot; src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- Part 3 --&gt;
&lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px;text-align:center&quot; data-ad-client=&quot;ca-pub-6751104560361558&quot; data-ad-slot=&quot;5318857026&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;hr /&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;Part 4: Our Toy Code&lt;/h2&gt;

&lt;p&gt;We're going to be using a recurrent neural network to model &lt;b&gt;binary addition&lt;/b&gt;. Do you see the sequence below? What do the colored ones in squares at the top signify?&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;95%&quot; src=&quot;/img/binary_addition.GIF&quot; alt=&quot;&quot; /&gt;
&lt;font size=&quot;2&quot; color=&quot;gray&quot;&gt;source: angelfire.com&lt;/font&gt;

&lt;p&gt;The colorful 1s in boxes at the top signify the &quot;carry bit&quot;. They &quot;carry the one&quot; when the sum overfows at each place. This is the tiny bit of memory that we're going to teach our neural network how to model. It's going to &quot;carry the one&quot; when the sum requires it. (click &lt;a href=&quot;https://www.youtube.com/watch?v=jB_sRh5yoZk&quot;&gt;here&lt;/a&gt; to learn about when this happens)&lt;/p&gt;

&lt;p&gt;So, binary addition moves from right to left, where we try to predict the number beneath the line given the numbers above the line. We want the neural network to move along the binary sequences and remember when it has carried the 1 and when it hasn't, so that it can make the correct prediction. Don't get too caught up in the problem. The network actually doesn't care too much. Just recognize that we're going to have two inputs at each time step, (either a one or a zero from each number begin added). These two inputs will be propagated to the hidden layer, which will have to remember whether or not we carry. The prediction will take all of this information into account to predict the correct bit at the given position (time step).&lt;/p&gt;

&lt;center&gt;&lt;i&gt;At this point, I recommend opening this page in two windows so that you can follow along with the line numbers in the code example at the top. That's how I wrote it.&lt;/i&gt;&lt;/center&gt;

&lt;p&gt;&lt;b&gt;Lines 0-2:&lt;/b&gt; Importing our dependencies and seeding the random number generator. We will only use numpy and copy. Numpy is for matrix algebra. Copy is to copy things.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Lines 4-11:&lt;/b&gt; Our nonlinearity and derivative. For details, please read this &lt;a href=&quot;http://iamtrask.github.io/2015/07/12/basic-python-network/&quot;&gt; Neural Network Tutorial&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 15:&lt;/b&gt; We're going to create a lookup table that maps from an integer to its binary representation. The binary representations will be our input and output data for each math problem we try to get the network to solve. This lookup table will be very helpful in converting from integers to bit strings.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 16:&lt;/b&gt; This is where I set the maximum length of the binary numbers we'll be adding. If I've done everything right, you can adjust this to add potentially very large numbers.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 18:&lt;/b&gt; This computes the largest number that is possible to represent with the binary length we chose&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 19:&lt;/b&gt; This is a lookup table that maps from an integer to its binary representation. We copy it into the int2binary. This is kindof un-ncessary but I thought it made things more obvious looking.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 26:&lt;/b&gt; This is our learning rate.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 27:&lt;/b&gt; We are adding two numbers together, so we'll be feeding in two-bit strings one character at the time each. Thus, we need to have two inputs to the network (one for each of the numbers being added).&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 28:&lt;/b&gt; This is the size of the hidden layer that will be storing our carry bit. Notice that it is way larger than it theoretically needs to be. Play with this and see how it affects the speed of convergence. Do larger hidden dimensions make things train faster or slower? More iterations or fewer?&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 29:&lt;/b&gt; Well, we're only predicting the sum, which is one number. Thus, we only need one output&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 33:&lt;/b&gt; This is the matrix of weights that connects our input layer and our hidden layer. Thus, it has &quot;input_dim&quot; rows and &quot;hidden_dim&quot; columns. (2 x 16 unless you change it). If you forgot what it does, look for it in the pictures in Part 2 of this blogpost.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 34:&lt;/b&gt; This is the matrix of weights that connects the hidden layer to the output layer. Thus, it has &quot;hidden_dim&quot; rows and &quot;output_dim&quot; columns. (16 x 1 unless you change it). If you forgot what it does, look for it in the pictures in Part 2 of this blogpost.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 35:&lt;/b&gt; This is the matrix of weights that connects the hidden layer in the previous time-step to the hidden layer in the current timestep. It also connects the hidden layer in the current timestep to the hidden layer in the next timestep (we keep using it). Thus, it has the dimensionality of &quot;hidden_dim&quot; rows and &quot;hidden_dim&quot; columns. (16 x 16 unless you change it). If you forgot what it does, look for it in the pictures in Part 2 of this blogpost.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 37 - 39:&lt;/b&gt; These store the weight updates that we would like to make for each of the weight matrices. After we've accumulated several weight updates, we'll actually update the matrices. More on this later.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 42:&lt;/b&gt; We're iterating over 100,000 training examples&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 45:&lt;/b&gt; We're going to generate a random addition problem. So, we're initializing an integer randomly between 0 and half of the largest value we can represent. If we allowed the network to represent more than this, than adding two number could theoretically overflow (be a bigger number than we have bits to represent). Thus, we only add numbers that are less than half of the largest number we can represent.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 46:&lt;/b&gt; We lookup the binary form for &quot;a_int&quot; and store it in &quot;a&quot;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 48:&lt;/b&gt; Same thing as line 45, just getting another random number.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 49:&lt;/b&gt; Same thing as line 46, looking up the binary representation.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 52:&lt;/b&gt; We're computing what the correct answer should be for this addition&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 53:&lt;/b&gt; Converting the true answer to its binary representation&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 56:&lt;/b&gt; Initializing an empty binary array where we'll store the neural network's predictions (so we can see it at the end). You could get around doing this if you want...but i thought it made things more intuitive&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 58:&lt;/b&gt; Resetting the error measure (which we use as a means to track convergence... see my tutorial on backpropagation and gradient descent to learn more about this)&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Lines 60-61:&lt;/b&gt; These two lists will keep track of the layer 2 derivatives and layer 1 values at each time step.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 62:&lt;/b&gt; Time step zero has no previous hidden layer, so we initialize one that's off.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 65:&lt;/b&gt; This for loop iterates through the binary representation&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 68:&lt;/b&gt; X is the same as &quot;layer_0&quot; in the pictures. X is a list of 2 numbers, one from a and one from b. It's indexed according to the &quot;position&quot; variable, but we index it in such a way that it goes from right to left. So, when position == 0, this is the farhest bit to the right in &quot;a&quot; and the farthest bit to the right in &quot;b&quot;. When position equals 1, this shifts to the left one bit.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 69:&lt;/b&gt; Same indexing as line 62, but instead it's the value of the correct answer (either a 1 or a 0)&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 72:&lt;/b&gt; This is the magic!!! Make sure you understand this line!!! To construct the hidden layer, we first do two things. First, we propagate from the input to the hidden layer (np.dot(X,synapse_0)). Then, we propagate from the previous hidden layer to the current hidden layer (np.dot(prev_layer_1, synapse_h)). Then WE SUM THESE TWO VECTORS!!!!... and pass through the sigmoid function.&lt;/p&gt;

&lt;p&gt;So, how do we combine the information from the previous hidden layer and the input? After each has been propagated through its various matrices (read: interpretations), we sum the information. &lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 75:&lt;/b&gt; This should look very familiar. It's the same as previous tutorials. It propagates the hidden layer to the output to make a prediction&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 78:&lt;/b&gt; Compute by how much the prediction missed&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 79:&lt;/b&gt; We're going to store the derivative (mustard orange in the graphic above) in a list, holding the derivative at each timestep.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 80:&lt;/b&gt; Calculate the sum of the absolute errors so that we have a scalar error (to track propagation). We'll end up with a sum of the error at each binary position.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 83&lt;/b&gt; Rounds the output (to a binary value, since it is between 0 and 1) and stores it in the designated slot of d.

&lt;p&gt;&lt;b&gt;Line 86&lt;/b&gt; Copies the layer_1 value into an array so that at the next time step we can apply the hidden layer at the current one.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 90:&lt;/b&gt; So, we've done all the forward propagating for all the time steps, and we've computed the derivatives at the output layers and stored them in a list. Now we need to backpropagate, starting with the last timestep, backpropagating to the first&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 92:&lt;/b&gt; Indexing the input data like we did before&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Line 93:&lt;/b&gt; Selecting the current hidden layer from the list.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Line 94:&lt;/b&gt; Selecting the previous hidden layer from the list&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Line 97:&lt;/b&gt; Selecting the current output error from the list&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Line 99:&lt;/b&gt; this computes the current hidden layer error given the error at the hidden layer from the future and the error at the current output layer.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Line 102-104:&lt;/b&gt; Now that we have the derivatives backpropagated at this current time step, we can construct our weight updates (but not actually update the weights just yet). We don't actually update our weight matrices until after we've fully backpropagated everything. Why? Well, we use the weight matrices for the backpropagation. Thus, we don't want to go changing them yet until the actual backprop is done. See the &lt;a href=&quot;http://iamtrask.github.io/2015/07/12/basic-python-network/&quot;&gt;backprop blog post&lt;/a&gt; for more details.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 109 - 115&lt;/b&gt; Now that we've backpropped everything and created our weight updates. It's time to update our weights (and empty the update variables).&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 118 - end&lt;/b&gt; Just some nice logging to show progress&lt;/p&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;Part 5: Questions / Comments&lt;/h2&gt;

If you have questions or comments, tweet &lt;a href=&quot;https://twitter.com/iamtrask&quot;&gt;&lt;b&gt;@iamtrask&lt;/b&gt;&lt;/a&gt; and I'll be happy to help.

&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/shCore.css&quot; /&gt;
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/shThemeDefault.css&quot; /&gt;
&lt;script src=&quot;/js/shCore.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/js/shLegacy.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/js/shBrushPython.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
	// SyntaxHighlighter.config.bloggerMode = true;
	SyntaxHighlighter.config.toolbar = true;
    SyntaxHighlighter.all();
&lt;/script&gt;
&lt;/p&gt;&lt;/p&gt;&lt;/p&gt;&lt;/p&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 15 Nov 2015 12:00:00 +0000</pubDate>
        <link>http://localhost:4000/2015/11/15/anyone-can-code-lstm/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/11/15/anyone-can-code-lstm/</guid>
        
        
      </item>
    
      <item>
        <title>Hinton's Dropout in 3 Lines of Python</title>
        <description>&lt;p&gt;&lt;b&gt;Summary:&lt;/b&gt; Dropout is a vital feature in almost every state-of-the-art neural network implementation. This tutorial teaches how to install Dropout into a neural network in only a few lines of Python code. Those who walk through this tutorial will finish with a working Dropout implementation and will be empowered with the intuitions to install it and tune it in any neural network they encounter.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Followup Post:&lt;/b&gt; I intend to write a followup post to this one adding popular features leveraged by &lt;a href=&quot;http://rodrigob.github.io/are_we_there_yet/build/classification_datasets_results.html&quot;&gt;state-of-the-art approaches&lt;/a&gt;. I'll tweet it out when it's complete &lt;a href=&quot;https://twitter.com/iamtrask&quot;&gt;@iamtrask&lt;/a&gt;. Feel free to follow if you'd be interested in reading more and thanks for all the feedback!&lt;/p&gt;

&lt;p&gt;&lt;h3&gt;Just Give Me The Code:&lt;/h3&gt;
&lt;pre class=&quot;brush:python; highlight:[4,9,10]&quot;&gt;
import numpy as np
X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])
y = np.array([[0,1,1,0]]).T
alpha,hidden_dim,dropout_percent,do_dropout = (0.5,4,0.2,True)
synapse_0 = 2*np.random.random((3,hidden_dim)) - 1
synapse_1 = 2*np.random.random((hidden_dim,1)) - 1
for j in xrange(60000):
    layer_1 = (1/(1+np.exp(-(np.dot(X,synapse_0)))))
    if(do_dropout):
        layer_1 *= np.random.binomial([np.ones((len(X),hidden_dim))],1-dropout_percent)[0] * (1.0/(1-dropout_percent))
    layer_2 = 1/(1+np.exp(-(np.dot(layer_1,synapse_1))))
    layer_2_delta = (layer_2 - y)*(layer_2*(1-layer_2))
    layer_1_delta = layer_2_delta.dot(synapse_1.T) * (layer_1 * (1-layer_1))
    synapse_1 -= (alpha * layer_1.T.dot(layer_2_delta))
    synapse_0 -= (alpha * X.T.dot(layer_1_delta))
&lt;/pre&gt;
&lt;/p&gt;
&lt;hr /&gt;

&lt;script async=&quot;&quot; src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;

&lt;!-- Part 1 --&gt;
&lt;p&gt;&lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-6751104560361558&quot; data-ad-slot=&quot;2365390629&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;Part 1: What is Dropout?&lt;/h2&gt;

&lt;p&gt;As discovered in the &lt;a href=&quot;http://iamtrask.github.io/2015/07/27/python-network-part2/&quot;&gt;previous post&lt;/a&gt;, a neural network is a glorified search problem. Each node in the neural network is searching for correlation between the input data and the correct output data.&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/sgd_randomness_ensemble.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;
Consider the graphic above from the previous post. The line represents the error the network generates for every value of a particular weight. The low-points (READ: low error) in that line signify the weight &quot;finding&quot; points of correlation between the input and output data. The balls in the picture signify various weights. They are trying to find those low points.&lt;/p&gt;

&lt;p&gt;Consider the color. The ball's initial positions are randomly generated (just like weights in a neural network). If two balls randomly start in the same colored zone, they will converge to the same point. This makes them redundant! They're wasting computation and memory! This is exactly what happens in neural networks.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Why Dropout:&lt;/b&gt; Dropout helps prevent weights from converging to identical positions. It does this by &lt;b&gt;randomly turning nodes off&lt;/b&gt; when forward propagating. It then back-propagates with all the nodes turned on. Let’s take a closer look.&lt;/p&gt;
&lt;hr /&gt;

&lt;script async=&quot;&quot; src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;

&lt;!-- Part 2 --&gt;
&lt;p&gt;&lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-6751104560361558&quot; data-ad-slot=&quot;3842123822&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;Part 2: How Do I Install and Tune Dropout?&lt;/h2&gt;

&lt;p&gt;The highlighted code above demonstrates how to install dropout. To perform dropout on a layer, you randomly set some of the layer's values to 0 during forward propagation. This is demonstrated on &lt;b&gt;line 10&lt;/b&gt;.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 9:&lt;/b&gt; parameterizes using dropout at all. You see, you only want to use Dropout during &lt;b&gt;training&lt;/b&gt;. Do not use it at runtime or on your testing dataset.  &lt;/p&gt;

&lt;p&gt;&lt;b&gt;EDIT: Line 9:&lt;/b&gt; has a second portion to increase the size of the values being propagated forward. This happens in proportion to the number of values being turned off. A simple intuition is that if you're turning off half of your hidden layer, you want to double the values that ARE pushing forward so that the output compensates correctly. Many thanks to &lt;a href=&quot;https://twitter.com/karpathy&quot;&gt;@karpathy&lt;/a&gt; for catching this one.&lt;/p&gt;

&lt;h3&gt;Tuning Best Practice&lt;/h3&gt;

&lt;p&gt;&lt;b&gt;Line 4:&lt;/b&gt; parameterizes the dropout_percent. This affects the probability that any one node will be turned off. A good initial configuration for this for hidden layers is 50%. If applying dropout to an input layer, it's best to not exceed 25%.&lt;/p&gt;

&lt;p&gt;Hinton advocates tuning dropout in conjunction with tuning the size of your hidden layer. Increase your hidden layer size(s) with dropout turned off until you perfectly fit your data. Then, using the same hidden layer size, train with dropout turned on. This should be a nearly optimal configuration. Turn off dropout as soon as you're done training and voila! You have a working neural network!&lt;/p&gt;

&lt;hr /&gt;

&lt;script async=&quot;&quot; src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;

&lt;!-- Part 3 --&gt;
&lt;p&gt;&lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-6751104560361558&quot; data-ad-slot=&quot;5318857026&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!-- 
&lt;h3 class=&quot;section-heading&quot;&gt;Part 3: Why does Dropout Work?&lt;/h3&gt;

&lt;i&gt; (This section builds upon concepts laid out in the &lt;a href=&quot;http://iamtrask.github.io/2015/07/27/python-network-part2/&quot;&gt;previous post&lt;/a&gt;.)&lt;/i&gt;

&lt;p&gt;Imagine that you had two identical values in your hidden layer. By &quot;idential&quot;, I mean that their input weights were the same, so they turned on and off at exactly the same time. Given what we learned in Section 1 of this post, we know that this is a very real possibility.&lt;/p&gt;

&lt;p&gt;This means that each weight was contributing half of an identical &quot;vote&quot; to the output. What if we turned one off and kept training? In this case, the network would start making errors because it was trained to expect two nodes to make this vote. In response, it would &lt;b&gt;turn up the volume&lt;/b&gt; on the node that was still turned on until it was casting a &lt;i&gt;full vote&lt;/i&gt; instead of a &lt;i&gt;half vote&lt;/i&gt;.&lt;/p&gt;

&lt;p&gt;So, what happens to the node that's turned off? Well, under the dropout approach, it's not turned off all the time. It's only turned off in the &quot;forward propagation&quot; step. It's not turned off in the &quot;backward propagation&quot; step. This means that it still updates its weights to account for the error in the network. However, since it's turned off, each of its updates doesn't actually affect the error of the network. So, we're updating a weight that's actually quite irrelevant to the quality of the network. Why would we do this?&lt;/p&gt;

&lt;p&gt;Remember that when we update a weight, it converges to reduce the error. Once it has reduced the error, the network doesn't backprop anything in that direction anymore. So, when our &quot;turned on&quot; node starts having a &quot;full vote&quot;, the &quot;turned off&quot; node doesn't feel the pull in that direction anymore.&lt;/p&gt;

&lt;p&gt;So if the turned off node is feeling the pull of the network's error, EXCEPT for the pull in the direction of the &quot;turned on&quot; node, then it is free to ESCAPE to find a unique position in the network! &lt;b&gt;This is why dropout works!&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Another intuitive perspective on dropout is that it is a form of &lt;b&gt;model averaging&lt;/b&gt;. Basically, if you force the network to converge using random subsets of its hidden nodes, you're forcing nodes to not have to &quot;rely&quot; on each other, because you don't know if your neighbor is going to be turned on or off. This forces each node to be a very valuable &quot;individual contributer&quot; instead of converging to similar places as its neighbors. (This is the more common explanation.)&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Wallah!&lt;/b&gt; Now we know how dropout works! Well done!&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/ford.jpg&quot; alt=&quot;&quot;&gt;

&lt;hr /&gt;
 --&gt;
&lt;h2 class=&quot;section-heading&quot;&gt;Want to Work in Machine Learning?&lt;/h2&gt;

&lt;p&gt;
One of the best things you can do to learn Machine Learning is to have a job where you're &lt;b&gt;practicing Machine Learning professionally&lt;/b&gt;. I'd encourage you to check out the &lt;a href=&quot;http://www.digitalreasoning.com/careers&quot;&gt;positions at Digital Reasoning&lt;/a&gt; in your job hunt. If you have questions about any of the positions or about life at Digital Reasoning, feel free to send me a message on &lt;a href=&quot;https://www.linkedin.com/profile/view?id=226572677&amp;amp;trk=nav_responsive_tab_profile&quot;&gt;my LinkedIn&lt;/a&gt;. I'm happy to hear about where you want to go in life, and help you evaluate whether Digital Reasoning could be a good fit.
&lt;/p&gt;

&lt;p&gt;If none of the positions above feel like a good fit. Continue your search! Machine Learning expertise is one of the &lt;b&gt;most valuable skills in the job market today&lt;/b&gt;, and there are many firms looking for practitioners. Perhaps some of these services below will help you in your hunt.

&lt;style type=&quot;text/css&quot;&gt;#indJobContent{padding-bottom: 5px;}#indJobContent .company_location{font-size: 11px;overflow: hidden;display:block;}#indJobContent.wide .job{display:block;float:left;margin-right: 5px;width: 135px;overflow: hidden}#indeed_widget_wrapper{position: relative;font-family: 'Helvetica Neue',Helvetica,Arial,sans-serif;font-size: 13px;font-weight: normal;line-height: 18px;padding: 10px;height: auto;overflow: hidden;}#indeed_widget_header{font-size:18px; padding-bottom: 5px; }#indeed_search_wrapper{clear: both;font-size: 12px;margin-top: 5px;padding-top: 5px;}#indeed_search_wrapper label{font-size: 12px;line-height: inherit;text-align: left; margin-right: 5px;}#indeed_search_wrapper input[type='text']{width: 100px; font-size: 11px; }#indeed_search_wrapper #qc{float:left;}#indeed_search_wrapper #lc{float:right;}#indeed_search_wrapper.stacked #qc, #indeed_search_wrapper.stacked #lc{float: none; clear: both;}#indeed_search_wrapper.stacked input[type='text']{width: 150px;}#indeed_search_wrapper.stacked label{display: block;padding-bottom: 5px;}#indeed_search_footer{width:295px; padding-top: 5px; clear: both;}#indeed_link{position: absolute;bottom: 1px;right: 5px;clear: both;font-size: 11px; }#indeed_link a{text-decoration: none;}#results .job{padding: 1px 0px;}#pagination { clear: both; }&lt;/style&gt;&lt;style type=&quot;text/css&quot;&gt;
#indeed_widget_wrapper{ width: 50%; height: 600px; background: #FFFFFF;}
#indeed_widget_wrapper{ border: 1px solid #DDDDDD; }
#indeed_widget_wrapper, #indeed_link a{ color: #000000;}
#indJobContent, #indeed_search_wrapper{ border-top: 1px solid #DDDDDD; }
#indJobContent a { color: #00c; }
#indeed_widget_header{ color: #000000; }
&lt;/style&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var ind_pub = '9172611916208179';
var ind_el = 'indJobContent';
var ind_pf = '';
var ind_q = 'Machine Learning';
var ind_l = '';
var ind_chnl = 'none';
var ind_n = 15;
var ind_d = 'http://www.indeed.com';
var ind_t = 40;
var ind_c = 30;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.indeed.com/ads/jobroll-widget-v3.js&quot;&gt;&lt;/script&gt;

&lt;div id=&quot;indeed_widget_wrapper&quot; style=&quot;&quot;&gt;
&lt;div id=&quot;indeed_widget_header&quot;&gt;Machine Learning Jobs&lt;/div&gt;

&lt;div id=&quot;indJobContent&quot; class=&quot;&quot;&gt;&lt;/div&gt;

&lt;div id=&quot;indeed_search_wrapper&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
function clearDefaults() {
var formInputs = document.getElementById('indeed_jobform').elements;
for(var i = 0; i &lt; formInputs.length; i++) {
if(formInputs[i].value == 'title, keywords' || formInputs[i].value == 'city, state, or zip') {
formInputs[i].value = '';
}
}
}
&lt;/script&gt;
&lt;form onsubmit=&quot;clearDefaults();&quot; method=&quot;get&quot; action=&quot;http://www.indeed.com/jobs&quot; id=&quot;indeed_jobform&quot; target=&quot;_new&quot;&gt;
&lt;div id=&quot;qc&quot;&gt;&lt;label&gt;What:&lt;/label&gt;&lt;input type=&quot;text&quot; onfocus=&quot;this.value=&amp;quot;&amp;quot;&quot; value=&quot;title, keywords&quot; name=&quot;q&quot; id=&quot;q&quot; /&gt;&lt;/div&gt;
&lt;div id=&quot;lc&quot;&gt;&lt;label&gt;Where:&lt;/label&gt;&lt;input type=&quot;text&quot; onfocus=&quot;this.value=&amp;quot;&amp;quot;&quot; value=&quot;city, state, or zip&quot; name=&quot;l&quot; id=&quot;l&quot; /&gt;&lt;/div&gt;
&lt;div id=&quot;indeed_search_footer&quot;&gt;
&lt;div style=&quot;float:left&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;Find Jobs&quot; class=&quot;findjobs&quot; /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;input type=&quot;hidden&quot; name=&quot;indpubnum&quot; id=&quot;indpubnum&quot; value=&quot;9172611916208179&quot; /&gt;
&lt;/form&gt;
&lt;/div&gt;

&lt;div id=&quot;indeed_link&quot;&gt;
&lt;a title=&quot;Job Search&quot; href=&quot;http://www.indeed.com/&quot; target=&quot;_new&quot;&gt;jobs by &lt;img alt=&quot;Indeed&quot; src=&quot;http://www.indeed.com/p/jobsearch.gif&quot; style=&quot;border: 0;vertical-align: bottom;&quot; /&gt;
&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div style=&quot;position:absolute; margin-top:-600px; margin-left:400px&quot; id=&quot;MonsterJobSearchResultPlaceHolderNXAAAA_e_e&quot; class=&quot;xmns_distroph&quot;&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
(function() {
  var oScript = document.createElement('script');
  oScript.type = 'text/javascript';
  oScript.async = true;
  oScript.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'publisher.monster.com/Services/WidgetHandler.ashx?WidgetID=EAAQUeLsOxB7mqhf97nwIpkVXQ--&amp;Verb=Initialize';
  var oParent = document.getElementsByTagName('script')[0];
  oParent.parentNode.insertBefore(oScript, oParent);
})();
&lt;/script&gt;
&lt;a id=&quot;monsterBrowseLinkNXAAAA_e_e&quot; class=&quot;monsterBrowseLink fnt4&quot; href=&quot;http://jobsearch.monster.com/jobs/?q=Machine-Learning&quot;&gt;View More Job Search Results&lt;/a&gt;

&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/shCore.css&quot; /&gt;
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/shThemeDefault.css&quot; /&gt;
&lt;script src=&quot;/js/shCore.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/js/shLegacy.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/js/shBrushPython.js&quot;&gt;&lt;/script&gt;


&lt;script type=&quot;text/javascript&quot;&gt;
	// SyntaxHighlighter.config.bloggerMode = true;
	SyntaxHighlighter.config.toolbar = true;
    SyntaxHighlighter.all();
&lt;/script&gt;
&lt;/p&gt;
</description>
        <pubDate>Tue, 28 Jul 2015 13:00:00 +0100</pubDate>
        <link>http://localhost:4000/2015/07/28/dropout/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/07/28/dropout/</guid>
        
        
      </item>
    
      <item>
        <title>A Neural Network in 13 lines of Python (Part 2 - Gradient Descent)</title>
        <description>&lt;p&gt;&lt;b&gt;Summary:&lt;/b&gt; I learn best with toy code that I can play with. This tutorial teaches gradient descent via a very simple toy example, a short python implementation. 

&lt;p&gt;&lt;b&gt;Followup Post:&lt;/b&gt; I intend to write a followup post to this one adding popular features leveraged by &lt;a href=&quot;http://rodrigob.github.io/are_we_there_yet/build/classification_datasets_results.html&quot;&gt;state-of-the-art approaches&lt;/a&gt; (likely Dropout, DropConnect, and Momentum). I'll tweet it out when it's complete &lt;a href=&quot;https://twitter.com/iamtrask&quot;&gt;@iamtrask&lt;/a&gt;. Feel free to follow if you'd be interested in reading more and thanks for all the feedback!&lt;/p&gt;

&lt;p&gt;&lt;h3&gt;Just Give Me The Code:&lt;/h3&gt;
&lt;pre class=&quot;brush:python&quot;&gt;
import numpy as np
X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])
y = np.array([[0,1,1,0]]).T
alpha,hidden_dim = (0.5,4)
synapse_0 = 2*np.random.random((3,hidden_dim)) - 1
synapse_1 = 2*np.random.random((hidden_dim,1)) - 1
for j in xrange(60000):
    layer_1 = 1/(1+np.exp(-(np.dot(X,synapse_0))))
    layer_2 = 1/(1+np.exp(-(np.dot(layer_1,synapse_1))))
    layer_2_delta = (layer_2 - y)*(layer_2*(1-layer_2))
    layer_1_delta = layer_2_delta.dot(synapse_1.T) * (layer_1 * (1-layer_1))
    synapse_1 -= (alpha * layer_1.T.dot(layer_2_delta))
    synapse_0 -= (alpha * X.T.dot(layer_1_delta))
&lt;/pre&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;script async=&quot;&quot; src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- Part 1 --&gt;
&lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-6751104560361558&quot; data-ad-slot=&quot;2365390629&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;hr /&gt;


&lt;h2 class=&quot;section-heading&quot;&gt;Part 1: Optimization&lt;/h2&gt;

&lt;p&gt;In &lt;a href=&quot;http://iamtrask.github.io/2015/07/12/basic-python-network/&quot;&gt;Part 1&lt;/a&gt;, I laid out the basis for backpropagation in a simple neural network. Backpropagation allowed us to measure how each weight in the network contributed to the overall error. This ultimately allowed us to change these weights using a different algorithm, &lt;b&gt;Gradient Descent&lt;/b&gt;.

&lt;p&gt;The takeaway here is that &lt;b&gt;backpropagation doesn't optimize&lt;/b&gt;! It moves the error information from the end of the network to all the weights inside the network so that a different algorithm can optimize those weights to fit our data. We actually have a plethora of different &lt;b&gt;nonlinear optimization methods&lt;/b&gt; that we could use with backpropagation:&lt;/p&gt;
&lt;p style=&quot;margin-left:40px&quot;&gt;
&lt;b&gt;A Few Optimization Methods:&lt;/b&gt;&lt;br /&gt;
• &lt;a href=&quot;http://www.heatonresearch.com/articles/9&quot;&gt;Annealing&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&quot;https://en.wikipedia.org/wiki/Stochastic_gradient_descent&quot;&gt;Stochastic Gradient Descent&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&quot;http://arxiv.org/pdf/1506.09016v1.pdf&quot;&gt;AW-SGD (new!)&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&quot;http://jmlr.org/proceedings/papers/v28/sutskever13.pdf&quot;&gt;Momentum (SGD)&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&quot;http://jmlr.org/proceedings/papers/v28/sutskever13.pdf&quot;&gt;Nesterov Momentum (SGD)&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&quot;http://www.magicbroom.info/Papers/DuchiHaSi10.pdf&quot;&gt;AdaGrad&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&quot;http://arxiv.org/abs/1212.5701&quot;&gt;AdaDelta&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&quot;http://arxiv.org/abs/1412.6980&quot;&gt;ADAM&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&quot;https://en.wikipedia.org/wiki/Broyden%E2%80%93Fletcher%E2%80%93Goldfarb%E2%80%93Shanno_algorithm&quot;&gt;BFGS&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&quot;https://en.wikipedia.org/wiki/Limited-memory_BFGS&quot;&gt;LBFGS&lt;/a&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;b&gt;Visualizing the Difference:&lt;/b&gt;&lt;br /&gt;
• &lt;a href=&quot;http://cs.stanford.edu/people/karpathy/convnetjs/demo/trainers.html&quot;&gt;ConvNet.js&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&quot;http://www.robertsdionne.com/bouncingball/&quot;&gt;RobertsDionne&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;Many of these optimizations are good for different purposes, and in some cases several can be used together. In this tutorial, we will walk through Gradient Descent, which is arguably the simplest and most widely used neural network optimization algorithm. By learning about Gradient Descent, we will then be able to improve our toy neural network through parameterization and tuning, and ultimately make it a &lt;b&gt;lot more powerful&lt;/b&gt;.
&lt;/p&gt;

&lt;hr /&gt;
&lt;script async=&quot;&quot; src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- Part 2 --&gt;
&lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-6751104560361558&quot; data-ad-slot=&quot;3842123822&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;hr /&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;Part 2: Gradient Descent&lt;/h2&gt;

&lt;p&gt;Imagine that you had a red ball inside of a rounded bucket like in the picture below. Imagine further that the red ball is trying to find the bottom of the bucket. This is &lt;b&gt;optimization&lt;/b&gt;. In our case, the ball is optimizing it's position (from left to right) to find the lowest point in the bucket.&lt;/p&gt; 

&lt;p style=&quot;text-align:center&quot;&gt;&lt;i&gt;(pause here.... make sure you got that last sentence.... got it?)&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;So, to gamify this a bit. The ball has two options, left or right. It has one goal, get as low as possible. So, it needs to press the left and right buttons correctly to find the lowest spot&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/sgd_no_lines.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;So, what information does the ball use to adjust its position to find the lowest point? The only information it has is the &lt;b&gt;slope&lt;/b&gt; of the side of the bucket at its current position, pictured below with the blue line. Notice that when the slope is negative (downward from left to right), the ball should move to the right. However, when the slope is positive, the ball should move to the left. As you can see, this is more than enough information to find the bottom of the bucket in a few iterations. This is a sub-field of optimization called &lt;b&gt;gradient optimization&lt;/b&gt;. (Gradient is just a fancy word for slope or steepness).
&lt;/p&gt;


&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/sgd_optimal.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;
	&lt;h4&gt;Oversimplified Gradient Descent:&lt;/h4&gt;
	&lt;ul&gt;
	  &lt;li&gt;Calculate slope at current position&lt;/li&gt;
	  &lt;li&gt;If slope is negative, move right&lt;/li&gt;
	  &lt;li&gt;If slope is positive, move left&lt;/li&gt;
	  &lt;li&gt;(Repeat until slope == 0)&lt;/li&gt;
	&lt;/ul&gt;

&lt;/p&gt;


&lt;p&gt;The question is, however, &lt;b&gt;how much should the ball move &lt;/b&gt;at each time step? Look at the bucket again. The steeper the slope, the farther the ball is from the bottom. That's helpful! Let's improve our algorithm to leverage this new information. Also, let's assume that the bucket is on an (x,y) plane. So, it's location is x (along the bottom). Increasing the ball's &quot;x&quot; position moves it to the right. Decreasing the ball's &quot;x&quot; position moves it to the left.&lt;/p&gt;

&lt;p&gt;
&lt;h4&gt;Naive Gradient Descent:&lt;/h4&gt;
&lt;ul&gt;
	&lt;li&gt;Calculate &quot;slope&quot; at current &quot;x&quot; position&lt;/li&gt;
	&lt;li&gt;Change x by the negative of the slope. (x = x - slope)&lt;/li&gt;
	&lt;li&gt;(Repeat until slope == 0)&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;

&lt;p&gt;Make sure you can picture this process in your head before moving on. This is a considerable improvement to our algorithm. For very positive slopes, we move left by a lot. For only slightly positive slopes, we move left by only a little. As it gets closer and closer to the bottom, it takes smaller and smaller steps until the slope equals zero, at which point it stops. This stopping point is called &lt;b&gt;convergence&lt;/b&gt;.&lt;/p&gt;

&lt;hr /&gt;
&lt;script async=&quot;&quot; src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- Part 3 --&gt;
&lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-6751104560361558&quot; data-ad-slot=&quot;5318857026&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;hr /&gt;
&lt;h2 class=&quot;section-heading&quot;&gt;Part 3: Sometimes It Breaks&lt;/h2&gt;

&lt;p&gt;Gradient Descent isn't perfect. Let's take a look at its issues and how people get around them. This will allow us to improve our network to overcome these issues.&lt;/p&gt;

&lt;h3&gt;Problem 1: When slopes are too big&lt;/h3&gt;

&lt;p&gt;How big is too big? Remember our step size is based on the steepness of the slope. Sometimes the slope is so steep that we overshoot by a lot. Overshooting by a little is ok, but sometimes we overshoot by so much that we're even farther away than we started! See below. &lt;br /&gt;&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/sgd_high.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;What makes this problem so destructive is that overshooting this far means we land at an &lt;i&gt;EVEN STEEPER&lt;/i&gt; slope in the opposite direction. This causes us to overshoot again &lt;i&gt;EVEN FARTHER&lt;/i&gt;. This viscious cycle of overshooting leading to more overshooting is called &lt;b&gt;divergence&lt;/b&gt;.&lt;/p&gt;

&lt;h3&gt;Solution 1: Make Slopes Smaller&lt;/h3&gt;

&lt;p&gt;Lol. This may seem too simple to be true, but it's used in pretty much every neural network. If our gradients are too big, we make them smaller! We do this by multiplying them (all of them) by a single number between 0 and 1 (such as 0.01). This fraction is typically a single float called &lt;b&gt;alpha&lt;/b&gt;. When we do this, we don't overshoot and our network converges.

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/sgd_optimal.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;
&lt;h4&gt;Improved Gradient Descent:&lt;/h4&gt;
alpha = 0.1 (or some number between 0 and 1)
&lt;ul&gt;
	&lt;li&gt;Calculate &quot;slope&quot; at current &quot;x&quot; position&lt;/li&gt;
	&lt;li&gt;x = x - (alpha*slope)&lt;/li&gt;
	&lt;li&gt;(Repeat until slope == 0)&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;

&lt;h3&gt;Problem 2: Local Minimums&lt;/h3&gt;

&lt;p&gt;Sometimes your bucket has a funny shape, and following the slope doesn't take you to the absolute lowest point. Consider the picture below.&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/sgd_local_min.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;
This is by far the most difficult problem with gradient descent. There are a myriad of options to try to overcome this. Generally speaking, they all involve an element of random searching to try lots of different parts of the bucket. 
&lt;/p&gt;

&lt;h3&gt;Solution 2: Multiple Random Starting States&lt;/h3&gt;

&lt;p&gt;
There are a myriad of ways in which randomness is used to overcome getting stuck in a local minimum. It begs the question, if we have to use randomness to find the global minimum, why are we still optimizing in the first place? Why not just try randomly? The answer lies in the graph below.
&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/sgd_randomness_ensemble.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;
Imagine that we randomly placed 100 balls on this line and started optimizing all of them. If we did so, they would all end up in only 5 positions, mapped out by the five colored balls above. The colored regions represent the domain of each local minimum. For example, if a ball randomly falls within the blue domain, it will converge to the blue minimum. This means that to search the entire space, we only have to randomly find 5 spaces! This is far better than pure random searching, which has to randomly try EVERY space (which could easily be millions of places on this black line depending on the granularity). 
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;In Neural Networks:&lt;/b&gt; One way that neural networks accomplish this is by having very large hidden layers. You see, each hidden node in a layer starts out in a different random starting state. This allows each hidden node to converge to different patterns in the network. Parameterizing this size allows the neural network user to potentially try thousands &lt;a href=&quot;http://www.digitalreasoning.com/buzz/digital-reasoning-trains-worlds-largest-neural-network-shatters-record-previously-set-by-google.1672770&quot;&gt;(or tens of billions)&lt;/a&gt; of different local minima in a single neural network.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Sidenote 1:&lt;/b&gt; &lt;b&gt;This is why neural networks are so powerful!&lt;/b&gt; They have the ability to search far more of the space than they actually compute! We can search the entire black line above with (in theory) only 5 balls and a handful of iterations. Searching that same space in a brute force fashion could easily take orders of magnitude more computation.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Sidenote 2:&lt;/b&gt; A close eye might ask, &quot;Well, why would we allow a lot of nodes to converge to the same spot? That's actually wasting computational power!&quot; That's an excellent point. The current state-of-the-art approaches to avoiding hidden nodes coming up with the same answer (by searching the same space) are Dropout and Drop-Connect, which I intend to cover in a later post.&lt;/p&gt;

&lt;h3&gt;Problem 3: When Slopes are Too Small&lt;/h3&gt;

&lt;p&gt;Neural networks sometimes suffer from the slopes being too small. The answer is also obvious but I wanted to mention it here to expand on its symptoms. Consider the following graph.&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/sgd_small.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;Our little red ball up there is just stuck! If your alpha is too small, this can happen. The ball just drops right into an instant local minimum and ignores the big picture. It doesn't have the &lt;b&gt;umph&lt;/b&gt; to get out of the rut.&lt;/p&gt;
&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/sgd_small2.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;And perhaps the more obvious symptom of deltas that are too small is that the convergence will just take a very, very long time.

&lt;h3&gt;Solution 3: Increase the Alpha&lt;/h3&gt;

&lt;p&gt;As you might expect, the solution to both of these symptoms is to increase the alpha. We might even multiply our deltas by a weight higher than 1. This is very rare, but it does sometimes happen.&lt;/p&gt;

&lt;!-- &lt;h3&gt;Problem 3: When some slopes are too small AND others are too big!&lt;/h3&gt;

&lt;p&gt;This one might sound a bit ridiculous. How can a single ball have more than one slope? In two dimensions where one is being optimized, this isn't possible. However, if a ball is sitting on a 3 dimensional hill, it has a coordinate for x,y,and z. Thus, if z is the height (which we're optimizing for), then both x and y can have slopes! Consider the following shape.

 --&gt;
&lt;h2 class=&quot;section-heading&quot;&gt;Part 4: SGD in Neural Networks&lt;/h2&gt;

&lt;p&gt;So at this point you might be wondering, how does this relate to neural networks and backpropagation? This is the hardest part, so get ready to hold on tight and take things slow. It's also quite important.&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/sgd_local_min.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;
That big nasty curve? In a neural network, we're trying to minimize the &lt;b&gt;error with respect to the weights&lt;/b&gt;. So, what that curve represents is the network's error relative to the position of a single weight. So, if we computed the network's error for every possible value of a single weight, it would generate the curve you see above. We would then pick the value of the single weight that has the lowest error (the lowest part of the curve). I say &lt;i&gt;single&lt;/i&gt; weight because it's a two-dimensional plot. Thus, the x dimension is the value of the weight and the y dimension is the neural network's error when the weight is at that position.&lt;/p&gt;

&lt;center&gt;&lt;b&gt;&lt;i&gt;Stop and make sure you got that last paragraph. It's key. &lt;/i&gt;&lt;/b&gt;&lt;/center&gt;

&lt;p&gt;Let's take a look at what this process looks like in a simple 2 layer neural network.&lt;/p&gt;

&lt;h3&gt;2 Layer Neural Network:&lt;/h3&gt;
&lt;pre class=&quot;brush: python&quot;&gt;
import numpy as np

# compute sigmoid nonlinearity
def sigmoid(x):
    output = 1/(1+np.exp(-x))
    return output

# convert output of sigmoid function to its derivative
def sigmoid_output_to_derivative(output):
    return output*(1-output)
    
# input dataset
X = np.array([  [0,1],
                [0,1],
                [1,0],
                [1,0] ])
    
# output dataset            
y = np.array([[0,0,1,1]]).T

# seed random numbers to make calculation
# deterministic (just a good practice)
np.random.seed(1)

# initialize weights randomly with mean 0
synapse_0 = 2*np.random.random((2,1)) - 1

for iter in xrange(10000):

    # forward propagation
    layer_0 = X
    layer_1 = sigmoid(np.dot(layer_0,synapse_0))

    # how much did we miss?
    layer_1_error = layer_1 - y

    # multiply how much we missed by the 
    # slope of the sigmoid at the values in l1
    layer_1_delta = layer_1_error * sigmoid_output_to_derivative(layer_1)
    synapse_0_derivative = np.dot(layer_0.T,layer_1_delta)

    # update weights
    synapse_0 -= synapse_0_derivative

print &quot;Output After Training:&quot;
print layer_1


&lt;/pre&gt;

&lt;p&gt;So, in this case, we have a single error at the output (single value), which is computed on line 35. Since we have 2 weights, the output &quot;error plane&quot; is a 3 dimensional space. We can think of this as an (x,y,z) plane, where vertical is the error, and x and y are the values of our two weights in syn0.&lt;/p&gt;

&lt;p&gt;Let's try to plot what the error plane looks like for the network/dataset above. So, how do we compute the error for a given set of weights? Lines 31,32,and 35 show us that. If we take that logic and plot the overall error (a single scalar representing the network error over the entire dataset) for every possible set of weights (from -10 to 10 for x and y), it looks something like this.&lt;/p&gt;

&lt;center&gt;
&lt;img class=&quot;img-responsive&quot; width=&quot;50%&quot; src=&quot;/img/3d_error_plane.gif&quot; alt=&quot;&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;Don't be intimidated by this. It really is as simple as computing every possible set of weights, and the error that the network generates at each set. x is the first synapse_0 weight and y is the second synapse_0 weight. z is the overall error. As you can see, our output data is &lt;b&gt;positively correlated&lt;/b&gt; with the first input data. Thus, the error is minimized when x (the first synapse_0 weight) is high. What about the second synapse_0 weight? How is it optimal?&lt;/p&gt;

&lt;h3&gt;How Our 2 Layer Neural Network Optimizes&lt;/h3&gt;

&lt;p&gt;So, given that lines 31,32,and 35 end up computing the error. It can be natural to see that lines 39, 40, and 43 optimize to reduce the error. This is where Gradient Descent is happening! Remember our pseudocode?

&lt;p&gt;
&lt;h4&gt;Naive Gradient Descent:&lt;/h4&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;b&gt;Lines 39 and 40: &lt;/b&gt;Calculate &quot;slope&quot; at current &quot;x&quot; position&lt;/li&gt;
	&lt;li&gt;&lt;b&gt;Line 43: &lt;/b&gt;Change x by the negative of the slope. (x = x - slope)&lt;/li&gt;
	&lt;li&gt;&lt;b&gt;Line 28: &lt;/b&gt;(Repeat until slope == 0)&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;

&lt;p&gt;It's exactly the same thing! The only thing that has changed is that we have 2 weights that we're optimizing instead of just 1. The logic, however, is identical.&lt;/p&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;Part 5: Improving our Neural Network&lt;/h2&gt;

&lt;p&gt;Remember that Gradient Descent had some weaknesses. Now that we have seen how our neural network leverages Gradient Descent, we can improve our network to overcome these weaknesses in the same way that we improved Gradient Descent in Part 3 (the 3 problems and solutions).&lt;/p&gt;

&lt;h3&gt;Improvement 1: Adding and Tuning the Alpha Parameter&lt;/h3&gt;

&lt;!-- &lt;p&gt;
If you have ever tuned an iterative algorithm, you have probably come across the shrouded, hand-wavey mystery around tuning the alpha parameter. Neural networks are the poster child of seemingly random optimal tuning. Quite frequently, authors of famous papers will later post that better tuning has lead to increased quality with the same algorithm long after their publication.
&lt;/p&gt; --&gt;

&lt;p&gt;&lt;b&gt;What is Alpha?&lt;/b&gt; As described above, the alpha parameter reduces the size of each iteration's update in the simplest way possible. At the very last minute, right before we update the weights, we multiply the weight update by alpha (usually between 0 and 1, thus reducing the size of the weight update). This tiny change to the code has absolutely &lt;b&gt;massive&lt;/b&gt; impact on its ability to train. 
&lt;/p&gt;


&lt;p&gt;We're going to jump back to our 3 layer neural network from the first post and add in an alpha parameter at the appropriate place. Then, we're going to run a series of experiments to align all the intuition we developed around alpha with its behavior in live code.&lt;/p&gt;

&lt;p&gt;
&lt;h4&gt;Improved Gradient Descent:&lt;/h4&gt;
&lt;ul&gt;
	&lt;li&gt;Calculate &quot;slope&quot; at current &quot;x&quot; position&lt;/li&gt;
	&lt;li&gt;&lt;b&gt;Lines 56 and 57: &lt;/b&gt;Change x by the negative of the slope scaled by alpha. (x = x - (alpha*slope) )&lt;/li&gt;
	&lt;li&gt;(Repeat until slope == 0)&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;

&lt;pre class=&quot;brush:python; highlight:[56,57]&quot;&gt;
import numpy as np

alphas = [0.001,0.01,0.1,1,10,100,1000]

# compute sigmoid nonlinearity
def sigmoid(x):
    output = 1/(1+np.exp(-x))
    return output

# convert output of sigmoid function to its derivative
def sigmoid_output_to_derivative(output):
    return output*(1-output)
    
X = np.array([[0,0,1],
            [0,1,1],
            [1,0,1],
            [1,1,1]])
                
y = np.array([[0],
			[1],
			[1],
			[0]])

for alpha in alphas:
    print &quot;\nTraining With Alpha:&quot; + str(alpha)
    np.random.seed(1)

    # randomly initialize our weights with mean 0
    synapse_0 = 2*np.random.random((3,4)) - 1
    synapse_1 = 2*np.random.random((4,1)) - 1

    for j in xrange(60000):

        # Feed forward through layers 0, 1, and 2
        layer_0 = X
        layer_1 = sigmoid(np.dot(layer_0,synapse_0))
        layer_2 = sigmoid(np.dot(layer_1,synapse_1))

        # how much did we miss the target value?
        layer_2_error = layer_2 - y

        if (j% 10000) == 0:
            print &quot;Error after &quot;+str(j)+&quot; iterations:&quot; + str(np.mean(np.abs(layer_2_error)))

        # in what direction is the target value?
        # were we really sure? if so, don't change too much.
        layer_2_delta = layer_2_error*sigmoid_output_to_derivative(layer_2)

        # how much did each l1 value contribute to the l2 error (according to the weights)?
        layer_1_error = layer_2_delta.dot(synapse_1.T)

        # in what direction is the target l1?
        # were we really sure? if so, don't change too much.
        layer_1_delta = layer_1_error * sigmoid_output_to_derivative(layer_1)

        synapse_1 -= alpha * (layer_1.T.dot(layer_2_delta))
        synapse_0 -= alpha * (layer_0.T.dot(layer_1_delta))


&lt;/pre&gt;
&lt;pre&gt;

Training With Alpha:0.001
Error after 0 iterations:0.496410031903
Error after 10000 iterations:0.495164025493
Error after 20000 iterations:0.493596043188
Error after 30000 iterations:0.491606358559
Error after 40000 iterations:0.489100166544
Error after 50000 iterations:0.485977857846

Training With Alpha:0.01
Error after 0 iterations:0.496410031903
Error after 10000 iterations:0.457431074442
Error after 20000 iterations:0.359097202563
Error after 30000 iterations:0.239358137159
Error after 40000 iterations:0.143070659013
Error after 50000 iterations:0.0985964298089

Training With Alpha:0.1
Error after 0 iterations:0.496410031903
Error after 10000 iterations:0.0428880170001
Error after 20000 iterations:0.0240989942285
Error after 30000 iterations:0.0181106521468
Error after 40000 iterations:0.0149876162722
Error after 50000 iterations:0.0130144905381

Training With Alpha:1
Error after 0 iterations:0.496410031903
Error after 10000 iterations:0.00858452565325
Error after 20000 iterations:0.00578945986251
Error after 30000 iterations:0.00462917677677
Error after 40000 iterations:0.00395876528027
Error after 50000 iterations:0.00351012256786

Training With Alpha:10
Error after 0 iterations:0.496410031903
Error after 10000 iterations:0.00312938876301
Error after 20000 iterations:0.00214459557985
Error after 30000 iterations:0.00172397549956
Error after 40000 iterations:0.00147821451229
Error after 50000 iterations:0.00131274062834

Training With Alpha:100
Error after 0 iterations:0.496410031903
Error after 10000 iterations:0.125476983855
Error after 20000 iterations:0.125330333528
Error after 30000 iterations:0.125267728765
Error after 40000 iterations:0.12523107366
Error after 50000 iterations:0.125206352756

Training With Alpha:1000
Error after 0 iterations:0.496410031903
Error after 10000 iterations:0.5
Error after 20000 iterations:0.5
Error after 30000 iterations:0.5
Error after 40000 iterations:0.5
Error after 50000 iterations:0.5
&lt;/pre&gt;

&lt;p&gt;So, what did we observe with the different alpha sizes?&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Alpha = 0.001&lt;/b&gt; &lt;br /&gt;The network with a crazy small alpha didn't hardly converge! This is because we made the weight updates so small that they hardly changed anything, even after 60,000 iterations! This is textbook &lt;b&gt;Problem 3:When Slopes Are Too Small&lt;/b&gt;.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Alpha = 0.01&lt;/b&gt; &lt;br /&gt;This alpha made a rather pretty convergence. It was quite smooth over the course of the 60,000 iterations but ultimately didn't converge as far as some of the others. This still is textbook &lt;b&gt;Problem 3:When Slopes Are Too Small&lt;/b&gt;.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Alpha = 0.1&lt;/b&gt;&lt;br /&gt;This alpha made some of progress very quickly but then slowed down a bit. This is still &lt;b&gt;Problem 3&lt;/b&gt;. We need to increase alpha some more. &lt;/p&gt;

&lt;p&gt;&lt;b&gt;Alpha = 1&lt;/b&gt;&lt;br /&gt;As a clever eye might suspect, this had the exact convergence as if we had no alpha at all! Multiplying our weight updates by 1 doesn't change anything. :)&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Alpha = 10&lt;/b&gt;&lt;br /&gt;Perhaps you were surprised that an alpha that was greater than 1 achieved the best score after only 10,000 iterations! This tells us that our weight updates were being too conservative with smaller alphas. This means that in the smaller alpha parameters (less than 10), the network's weights were generally headed in the right direction, they just needed to hurry up and get there!&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Alpha = 100&lt;/b&gt;&lt;br /&gt;
Now we can see that taking steps that are too large can be very counterproductive. The network's steps are so large that it can't find a reasonable lowpoint in the error plane. This is textbook &lt;b&gt;Problem 1&lt;/b&gt;. The Alpha is too big so it just jumps around on the error plane and never &quot;settles&quot; into a local minimum.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Alpha = 1000&lt;/b&gt;&lt;br /&gt;
And with an extremely large alpha, we see a textbook example of divergence, with the error increasing instead of decreasing... hardlining at 0.5. This is a more extreme version of &lt;b&gt;Problem 3&lt;/b&gt; where it overcorrectly whildly and ends up very far away from any local minimums.
&lt;/p&gt;

&lt;h3&gt;Let's Take a Closer Look&lt;/h3&gt;

&lt;pre class=&quot;brush:python&quot;&gt;
import numpy as np

alphas = [0.001,0.01,0.1,1,10,100,1000]

# compute sigmoid nonlinearity
def sigmoid(x):
    output = 1/(1+np.exp(-x))
    return output

# convert output of sigmoid function to its derivative
def sigmoid_output_to_derivative(output):
    return output*(1-output)
    
X = np.array([[0,0,1],
            [0,1,1],
            [1,0,1],
            [1,1,1]])
                
y = np.array([[0],
			[1],
			[1],
			[0]])



for alpha in alphas:
    print &quot;\nTraining With Alpha:&quot; + str(alpha)
    np.random.seed(1)

    # randomly initialize our weights with mean 0
    synapse_0 = 2*np.random.random((3,4)) - 1
    synapse_1 = 2*np.random.random((4,1)) - 1
        
    prev_synapse_0_weight_update = np.zeros_like(synapse_0)
    prev_synapse_1_weight_update = np.zeros_like(synapse_1)

    synapse_0_direction_count = np.zeros_like(synapse_0)
    synapse_1_direction_count = np.zeros_like(synapse_1)
        
    for j in xrange(60000):

        # Feed forward through layers 0, 1, and 2
        layer_0 = X
        layer_1 = sigmoid(np.dot(layer_0,synapse_0))
        layer_2 = sigmoid(np.dot(layer_1,synapse_1))

        # how much did we miss the target value?
        layer_2_error = y - layer_2

        if (j% 10000) == 0:
            print &quot;Error:&quot; + str(np.mean(np.abs(layer_2_error)))

        # in what direction is the target value?
        # were we really sure? if so, don't change too much.
        layer_2_delta = layer_2_error*sigmoid_output_to_derivative(layer_2)

        # how much did each l1 value contribute to the l2 error (according to the weights)?
        layer_1_error = layer_2_delta.dot(synapse_1.T)

        # in what direction is the target l1?
        # were we really sure? if so, don't change too much.
        layer_1_delta = layer_1_error * sigmoid_output_to_derivative(layer_1)
        
        synapse_1_weight_update = (layer_1.T.dot(layer_2_delta))
        synapse_0_weight_update = (layer_0.T.dot(layer_1_delta))
        
        if(j &amp;gt; 0):
            synapse_0_direction_count += np.abs(((synapse_0_weight_update &amp;gt; 0)+0) - ((prev_synapse_0_weight_update &amp;gt; 0) + 0))
            synapse_1_direction_count += np.abs(((synapse_1_weight_update &amp;gt; 0)+0) - ((prev_synapse_1_weight_update &amp;gt; 0) + 0))        
        
        synapse_1 += alpha * synapse_1_weight_update
        synapse_0 += alpha * synapse_0_weight_update
        
        prev_synapse_0_weight_update = synapse_0_weight_update
        prev_synapse_1_weight_update = synapse_1_weight_update
    
    print &quot;Synapse 0&quot;
    print synapse_0
    
    print &quot;Synapse 0 Update Direction Changes&quot;
    print synapse_0_direction_count
    
    print &quot;Synapse 1&quot;
    print synapse_1

    print &quot;Synapse 1 Update Direction Changes&quot;
    print synapse_1_direction_count
&lt;/pre&gt;
&lt;pre&gt;


Training With Alpha:0.001
Error:0.496410031903
Error:0.495164025493
Error:0.493596043188
Error:0.491606358559
Error:0.489100166544
Error:0.485977857846
Synapse 0
[[-0.28448441  0.32471214 -1.53496167 -0.47594822]
 [-0.7550616  -1.04593014 -1.45446052 -0.32606771]
 [-0.2594825  -0.13487028 -0.29722666  0.40028038]]
Synapse 0 Update Direction Changes
[[ 0.  0.  0.  0.]
 [ 0.  0.  0.  0.]
 [ 1.  0.  1.  1.]]
Synapse 1
[[-0.61957526]
 [ 0.76414675]
 [-1.49797046]
 [ 0.40734574]]
Synapse 1 Update Direction Changes
[[ 1.]
 [ 1.]
 [ 0.]
 [ 1.]]

Training With Alpha:0.01
Error:0.496410031903
Error:0.457431074442
Error:0.359097202563
Error:0.239358137159
Error:0.143070659013
Error:0.0985964298089
Synapse 0
[[ 2.39225985  2.56885428 -5.38289334 -3.29231397]
 [-0.35379718 -4.6509363  -5.67005693 -1.74287864]
 [-0.15431323 -1.17147894  1.97979367  3.44633281]]
Synapse 0 Update Direction Changes
[[ 1.  1.  0.  0.]
 [ 2.  0.  0.  2.]
 [ 4.  2.  1.  1.]]
Synapse 1
[[-3.70045078]
 [ 4.57578637]
 [-7.63362462]
 [ 4.73787613]]
Synapse 1 Update Direction Changes
[[ 2.]
 [ 1.]
 [ 0.]
 [ 1.]]

Training With Alpha:0.1
Error:0.496410031903
Error:0.0428880170001
Error:0.0240989942285
Error:0.0181106521468
Error:0.0149876162722
Error:0.0130144905381
Synapse 0
[[ 3.88035459  3.6391263  -5.99509098 -3.8224267 ]
 [-1.72462557 -5.41496387 -6.30737281 -3.03987763]
 [ 0.45953952 -1.77301389  2.37235987  5.04309824]]
Synapse 0 Update Direction Changes
[[ 1.  1.  0.  0.]
 [ 2.  0.  0.  2.]
 [ 4.  2.  1.  1.]]
Synapse 1
[[-5.72386389]
 [ 6.15041318]
 [-9.40272079]
 [ 6.61461026]]
Synapse 1 Update Direction Changes
[[ 2.]
 [ 1.]
 [ 0.]
 [ 1.]]

Training With Alpha:1
Error:0.496410031903
Error:0.00858452565325
Error:0.00578945986251
Error:0.00462917677677
Error:0.00395876528027
Error:0.00351012256786
Synapse 0
[[ 4.6013571   4.17197193 -6.30956245 -4.19745118]
 [-2.58413484 -5.81447929 -6.60793435 -3.68396123]
 [ 0.97538679 -2.02685775  2.52949751  5.84371739]]
Synapse 0 Update Direction Changes
[[ 1.  1.  0.  0.]
 [ 2.  0.  0.  2.]
 [ 4.  2.  1.  1.]]
Synapse 1
[[ -6.96765763]
 [  7.14101949]
 [-10.31917382]
 [  7.86128405]]
Synapse 1 Update Direction Changes
[[ 2.]
 [ 1.]
 [ 0.]
 [ 1.]]

Training With Alpha:10
Error:0.496410031903
Error:0.00312938876301
Error:0.00214459557985
Error:0.00172397549956
Error:0.00147821451229
Error:0.00131274062834
Synapse 0
[[ 4.52597806  5.77663165 -7.34266481 -5.29379829]
 [ 1.66715206 -7.16447274 -7.99779235 -1.81881849]
 [-4.27032921 -3.35838279  3.44594007  4.88852208]]
Synapse 0 Update Direction Changes
[[  7.  19.   2.   6.]
 [  7.   2.   0.  22.]
 [ 19.  26.   9.  17.]]
Synapse 1
[[ -8.58485788]
 [ 10.1786297 ]
 [-14.87601886]
 [  7.57026121]]
Synapse 1 Update Direction Changes
[[ 22.]
 [ 15.]
 [  4.]
 [ 15.]]

Training With Alpha:100
Error:0.496410031903
Error:0.125476983855
Error:0.125330333528
Error:0.125267728765
Error:0.12523107366
Error:0.125206352756
Synapse 0
[[-17.20515374   1.89881432 -16.95533155  -8.23482697]
 [  5.70240659 -17.23785161  -9.48052574  -7.92972576]
 [ -4.18781704  -0.3388181    2.82024759  -8.40059859]]
Synapse 0 Update Direction Changes
[[  8.   7.   3.   2.]
 [ 13.   8.   2.   4.]
 [ 16.  13.  12.   8.]]
Synapse 1
[[  9.68285369]
 [  9.55731916]
 [-16.0390702 ]
 [  6.27326973]]
Synapse 1 Update Direction Changes
[[ 13.]
 [ 11.]
 [ 12.]
 [ 10.]]

Training With Alpha:1000
Error:0.496410031903
Error:0.5
Error:0.5
Error:0.5
Error:0.5
Error:0.5
Synapse 0
[[-56.06177241  -4.66409623  -5.65196179 -23.05868769]
 [ -4.52271708  -4.78184499 -10.88770202 -15.85879101]
 [-89.56678495  10.81119741  37.02351518 -48.33299795]]
Synapse 0 Update Direction Changes
[[ 3.  2.  4.  1.]
 [ 1.  2.  2.  1.]
 [ 6.  6.  4.  1.]]
Synapse 1
[[  25.16188889]
 [  -8.68235535]
 [-116.60053379]
 [  11.41582458]]
Synapse 1 Update Direction Changes
[[ 7.]
 [ 7.]
 [ 7.]
 [ 3.]]
&lt;/pre&gt;

&lt;p&gt;What I did in the above code was count the &lt;b&gt;number of times a derivative changed direction&lt;/b&gt;. That's the &quot;Update Direction Changes&quot; readout at the end of training. If a slope (derivative) changes direction, it means that it passed OVER the local minimum and needs to go back. If it never changes direction, it means that it probably didn't go far enough.&lt;/p&gt;

&lt;h4&gt;A Few Takeaways:&lt;/h4&gt;
&lt;ul&gt;
	&lt;li&gt;When the alpha was tiny, the derivatives almost never changed direction.&lt;/li&gt;
	&lt;li&gt;When the alpha was optimal, the derivative changed directions a TON.&lt;/li&gt;
	&lt;li&gt;When the alpha was huge, the derivative changed directions a medium amount.&lt;/li&gt;
	&lt;li&gt;When the alph was tiny, the weights ended up being reasonably small too&lt;/li&gt;
	&lt;li&gt;When the alpha was huge, the weights got huge too!&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Improvement 2: Parameterizing the Size of the Hidden Layer&lt;/h3&gt;

&lt;p&gt;Being able to increase the size of the hidden layer increases the amount of search space that we converge to in each iteration. Consider the network and output&lt;/p&gt;

&lt;pre class=&quot;brush:python&quot;&gt;
import numpy as np

alphas = [0.001,0.01,0.1,1,10,100,1000]
hiddenSize = 32

# compute sigmoid nonlinearity
def sigmoid(x):
    output = 1/(1+np.exp(-x))
    return output

# convert output of sigmoid function to its derivative
def sigmoid_output_to_derivative(output):
    return output*(1-output)
    
X = np.array([[0,0,1],
            [0,1,1],
            [1,0,1],
            [1,1,1]])
                
y = np.array([[0],
			[1],
			[1],
			[0]])

for alpha in alphas:
    print &quot;\nTraining With Alpha:&quot; + str(alpha)
    np.random.seed(1)

    # randomly initialize our weights with mean 0
    synapse_0 = 2*np.random.random((3,hiddenSize)) - 1
    synapse_1 = 2*np.random.random((hiddenSize,1)) - 1

    for j in xrange(60000):

        # Feed forward through layers 0, 1, and 2
        layer_0 = X
        layer_1 = sigmoid(np.dot(layer_0,synapse_0))
        layer_2 = sigmoid(np.dot(layer_1,synapse_1))

        # how much did we miss the target value?
        layer_2_error = layer_2 - y

        if (j% 10000) == 0:
            print &quot;Error after &quot;+str(j)+&quot; iterations:&quot; + str(np.mean(np.abs(layer_2_error)))

        # in what direction is the target value?
        # were we really sure? if so, don't change too much.
        layer_2_delta = layer_2_error*sigmoid_output_to_derivative(layer_2)

        # how much did each l1 value contribute to the l2 error (according to the weights)?
        layer_1_error = layer_2_delta.dot(synapse_1.T)

        # in what direction is the target l1?
        # were we really sure? if so, don't change too much.
        layer_1_delta = layer_1_error * sigmoid_output_to_derivative(layer_1)

        synapse_1 -= alpha * (layer_1.T.dot(layer_2_delta))
        synapse_0 -= alpha * (layer_0.T.dot(layer_1_delta))

&lt;/pre&gt;
&lt;pre&gt;
Training With Alpha:0.001
Error after 0 iterations:0.496439922501
Error after 10000 iterations:0.491049468129
Error after 20000 iterations:0.484976307027
Error after 30000 iterations:0.477830678793
Error after 40000 iterations:0.46903846539
Error after 50000 iterations:0.458029258565

Training With Alpha:0.01
Error after 0 iterations:0.496439922501
Error after 10000 iterations:0.356379061648
Error after 20000 iterations:0.146939845465
Error after 30000 iterations:0.0880156127416
Error after 40000 iterations:0.065147819275
Error after 50000 iterations:0.0529658087026

Training With Alpha:0.1
Error after 0 iterations:0.496439922501
Error after 10000 iterations:0.0305404908386
Error after 20000 iterations:0.0190638725334
Error after 30000 iterations:0.0147643907296
Error after 40000 iterations:0.0123892429905
Error after 50000 iterations:0.0108421669738

Training With Alpha:1
Error after 0 iterations:0.496439922501
Error after 10000 iterations:0.00736052234249
Error after 20000 iterations:0.00497251705039
Error after 30000 iterations:0.00396863978159
Error after 40000 iterations:0.00338641021983
Error after 50000 iterations:0.00299625684932

Training With Alpha:10
Error after 0 iterations:0.496439922501
Error after 10000 iterations:0.00224922117381
Error after 20000 iterations:0.00153852153014
Error after 30000 iterations:0.00123717718456
Error after 40000 iterations:0.00106119569132
Error after 50000 iterations:0.000942641990774

Training With Alpha:100
Error after 0 iterations:0.496439922501
Error after 10000 iterations:0.5
Error after 20000 iterations:0.5
Error after 30000 iterations:0.5
Error after 40000 iterations:0.5
Error after 50000 iterations:0.5

Training With Alpha:1000
Error after 0 iterations:0.496439922501
Error after 10000 iterations:0.5
Error after 20000 iterations:0.5
Error after 30000 iterations:0.5
Error after 40000 iterations:0.5
Error after 50000 iterations:0.5
&lt;/pre&gt;

&lt;p&gt;Notice that the best error with 32 nodes is 0.0009 whereas the best error with 4 hidden nodes was only 0.0013. This might not seem like much, but it's an important lesson. We &lt;b&gt;do not need any more than 3 nodes to represent this dataset&lt;/b&gt;. However, because we had more nodes when we started, we searched more of the space in each iteration and ultimately converged faster. Even though this is very marginal in this toy problem, this affect plays a huge role when modeling very complex datasets.&lt;/p&gt;

&lt;h2&gt;Part 6: Conclusion and Future Work&lt;/h2&gt;
&lt;br /&gt;

&lt;p&gt;&lt;h3&gt;My Recommendation:&lt;/h3&gt;

If you're serious about neural networks, I have one recommendation. &lt;b&gt;Try to rebuild this network from memory.&lt;/b&gt; I know that might sound a bit crazy, but it seriously helps. If you want to be able to create arbitrary architectures based on new academic papers or read and understand sample code for these different architectures, I think that it's a killer exercise. I think it's useful even if you're using frameworks like &lt;a href=&quot;http://torch.ch/&quot;&gt;Torch&lt;/a&gt;, &lt;a href=&quot;http://caffe.berkeleyvision.org/&quot;&gt;Caffe&lt;/a&gt;, or &lt;a href=&quot;http://deeplearning.net/software/theano/&quot;&gt;Theano&lt;/a&gt;. I worked with neural networks for a couple years before performing this exercise, and it was the best investment of time I've made in the field (and it didn't take long). 
&lt;/p&gt;


&lt;p&gt;&lt;h3&gt;Future Work&lt;/h3&gt;
This toy example still needs quite a few bells and whistles to really approach the state-of-the-art architectures. Here's a few things you can look into if you want to further improve your network. (Perhaps I will in a followup post.)&lt;/p&gt;

&lt;p style=&quot;padding-left:20px&quot;&gt;
• &lt;a href=&quot;http://stackoverflow.com/questions/2480650/role-of-bias-in-neural-networks&quot;&gt;Bias Units&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&quot;https://class.coursera.org/ml-003/lecture/106&quot;&gt;Mini-Batches&lt;/a&gt;&lt;br /&gt;
• Delta Trimming &lt;br /&gt;
• &lt;a href=&quot;https://www.youtube.com/watch?v=XqRUHEeiyCs&quot;&gt;Parameterized Layer Sizes&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&quot;https://class.coursera.org/ml-003/lecture/63&quot;&gt;Regularization&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&quot;http://videolectures.net/nips2012_hinton_networks/&quot;&gt;Dropout&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&quot;https://www.youtube.com/watch?v=XqRUHEeiyCs&quot;&gt;Momentum&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&quot;http://arxiv.org/abs/1502.03167&quot;&gt;Batch Normalization&lt;/a&gt; &lt;br /&gt;
• GPU Compatability&lt;br /&gt;
• Other Awesomeness You Implement&lt;br /&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;Want to Work in Machine Learning?&lt;/h2&gt;


&lt;p&gt;
One of the best things you can do to learn Machine Learning is to have a job where you're &lt;b&gt;practicing Machine Learning professionally&lt;/b&gt;. I'd encourage you to check out the &lt;a href=&quot;https://www.linkedin.com/vsearch/j?page_num=1&amp;amp;locationType=Y&amp;amp;f_C=74158&amp;amp;trk=jobs_biz_prem_all_header&quot;&gt;positions at Digital Reasoning&lt;/a&gt; in your job hunt. If you have questions about any of the positions or about life at Digital Reasoning, feel free to send me a message on &lt;a href=&quot;https://www.linkedin.com/profile/view?id=226572677&amp;amp;trk=nav_responsive_tab_profile&quot;&gt;my LinkedIn&lt;/a&gt;. I'm happy to hear about where you want to go in life, and help you evaluate whether Digital Reasoning could be a good fit.
&lt;/p&gt;

&lt;p&gt;If none of the positions above feel like a good fit. Continue your search! Machine Learning expertise is one of the &lt;b&gt;most valuable skills in the job market today&lt;/b&gt;, and there are many firms looking for practitioners. Perhaps some of these services below will help you in your hunt.

&lt;style type=&quot;text/css&quot;&gt;#indJobContent{padding-bottom: 5px;}#indJobContent .company_location{font-size: 11px;overflow: hidden;display:block;}#indJobContent.wide .job{display:block;float:left;margin-right: 5px;width: 135px;overflow: hidden}#indeed_widget_wrapper{position: relative;font-family: 'Helvetica Neue',Helvetica,Arial,sans-serif;font-size: 13px;font-weight: normal;line-height: 18px;padding: 10px;height: auto;overflow: hidden;}#indeed_widget_header{font-size:18px; padding-bottom: 5px; }#indeed_search_wrapper{clear: both;font-size: 12px;margin-top: 5px;padding-top: 5px;}#indeed_search_wrapper label{font-size: 12px;line-height: inherit;text-align: left; margin-right: 5px;}#indeed_search_wrapper input[type='text']{width: 100px; font-size: 11px; }#indeed_search_wrapper #qc{float:left;}#indeed_search_wrapper #lc{float:right;}#indeed_search_wrapper.stacked #qc, #indeed_search_wrapper.stacked #lc{float: none; clear: both;}#indeed_search_wrapper.stacked input[type='text']{width: 150px;}#indeed_search_wrapper.stacked label{display: block;padding-bottom: 5px;}#indeed_search_footer{width:295px; padding-top: 5px; clear: both;}#indeed_link{position: absolute;bottom: 1px;right: 5px;clear: both;font-size: 11px; }#indeed_link a{text-decoration: none;}#results .job{padding: 1px 0px;}#pagination { clear: both; }&lt;/style&gt;&lt;style type=&quot;text/css&quot;&gt;
#indeed_widget_wrapper{ width: 50%; height: 600px; background: #FFFFFF;}
#indeed_widget_wrapper{ border: 1px solid #DDDDDD; }
#indeed_widget_wrapper, #indeed_link a{ color: #000000;}
#indJobContent, #indeed_search_wrapper{ border-top: 1px solid #DDDDDD; }
#indJobContent a { color: #00c; }
#indeed_widget_header{ color: #000000; }
&lt;/style&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var ind_pub = '9172611916208179';
var ind_el = 'indJobContent';
var ind_pf = '';
var ind_q = 'Machine Learning';
var ind_l = '';
var ind_chnl = 'none';
var ind_n = 15;
var ind_d = 'http://www.indeed.com';
var ind_t = 40;
var ind_c = 30;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.indeed.com/ads/jobroll-widget-v3.js&quot;&gt;&lt;/script&gt;

&lt;div id=&quot;indeed_widget_wrapper&quot; style=&quot;&quot;&gt;
&lt;div id=&quot;indeed_widget_header&quot;&gt;Machine Learning Jobs&lt;/div&gt;

&lt;div id=&quot;indJobContent&quot; class=&quot;&quot;&gt;&lt;/div&gt;

&lt;div id=&quot;indeed_search_wrapper&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
function clearDefaults() {
var formInputs = document.getElementById('indeed_jobform').elements;
for(var i = 0; i &lt; formInputs.length; i++) {
if(formInputs[i].value == 'title, keywords' || formInputs[i].value == 'city, state, or zip') {
formInputs[i].value = '';
}
}
}
&lt;/script&gt;
&lt;form onsubmit=&quot;clearDefaults();&quot; method=&quot;get&quot; action=&quot;http://www.indeed.com/jobs&quot; id=&quot;indeed_jobform&quot; target=&quot;_new&quot;&gt;
&lt;div id=&quot;qc&quot;&gt;&lt;label&gt;What:&lt;/label&gt;&lt;input type=&quot;text&quot; onfocus=&quot;this.value=&amp;quot;&amp;quot;&quot; value=&quot;title, keywords&quot; name=&quot;q&quot; id=&quot;q&quot; /&gt;&lt;/div&gt;
&lt;div id=&quot;lc&quot;&gt;&lt;label&gt;Where:&lt;/label&gt;&lt;input type=&quot;text&quot; onfocus=&quot;this.value=&amp;quot;&amp;quot;&quot; value=&quot;city, state, or zip&quot; name=&quot;l&quot; id=&quot;l&quot; /&gt;&lt;/div&gt;
&lt;div id=&quot;indeed_search_footer&quot;&gt;
&lt;div style=&quot;float:left&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;Find Jobs&quot; class=&quot;findjobs&quot; /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;input type=&quot;hidden&quot; name=&quot;indpubnum&quot; id=&quot;indpubnum&quot; value=&quot;9172611916208179&quot; /&gt;
&lt;/form&gt;
&lt;/div&gt;

&lt;div id=&quot;indeed_link&quot;&gt;
&lt;a title=&quot;Job Search&quot; href=&quot;http://www.indeed.com/&quot; target=&quot;_new&quot;&gt;jobs by &lt;img alt=&quot;Indeed&quot; src=&quot;http://www.indeed.com/p/jobsearch.gif&quot; style=&quot;border: 0;vertical-align: bottom;&quot; /&gt;
&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div style=&quot;position:absolute; margin-top:-600px; margin-left:400px&quot; id=&quot;MonsterJobSearchResultPlaceHolderNXAAAA_e_e&quot; class=&quot;xmns_distroph&quot;&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
(function() {
  var oScript = document.createElement('script');
  oScript.type = 'text/javascript';
  oScript.async = true;
  oScript.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'publisher.monster.com/Services/WidgetHandler.ashx?WidgetID=EAAQUeLsOxB7mqhf97nwIpkVXQ--&amp;Verb=Initialize';
  var oParent = document.getElementsByTagName('script')[0];
  oParent.parentNode.insertBefore(oScript, oParent);
})();
&lt;/script&gt;
&lt;a id=&quot;monsterBrowseLinkNXAAAA_e_e&quot; class=&quot;monsterBrowseLink fnt4&quot; href=&quot;http://jobsearch.monster.com/jobs/?q=Machine-Learning&quot;&gt;View More Job Search Results&lt;/a&gt;

&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/shCore.css&quot; /&gt;
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/shThemeDefault.css&quot; /&gt;
&lt;script src=&quot;/js/shCore.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/js/shLegacy.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/js/shBrushPython.js&quot;&gt;&lt;/script&gt;


&lt;script type=&quot;text/javascript&quot;&gt;
	// SyntaxHighlighter.config.bloggerMode = true;
	SyntaxHighlighter.config.toolbar = true;
    SyntaxHighlighter.all();
&lt;/script&gt;
&lt;/p&gt;&lt;/p&gt;&lt;/p&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 27 Jul 2015 13:00:00 +0100</pubDate>
        <link>http://localhost:4000/2015/07/27/python-network-part2/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/07/27/python-network-part2/</guid>
        
        
      </item>
    
      <item>
        <title>A Neural Network in 11 lines of Python (Part 1)</title>
        <description>&lt;p&gt;&lt;b&gt;Summary:&lt;/b&gt; I learn best with toy code that I can play with. This tutorial teaches backpropagation via a very simple toy example, a short python implementation.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Edit:&lt;/b&gt; Some folks have asked about a followup article, and I'm planning to write one. I'll tweet it out when it's complete at &lt;a href=&quot;https://twitter.com/iamtrask&quot;&gt;@iamtrask&lt;/a&gt;. Feel free to follow if you'd be interested in reading it and thanks for all the feedback!
&lt;/p&gt;
&lt;h3&gt;Just Give Me The Code:&lt;/h3&gt;
&lt;pre class=&quot;brush: python&quot;&gt;
X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])
y = np.array([[0,1,1,0]]).T
syn0 = 2*np.random.random((3,4)) - 1
syn1 = 2*np.random.random((4,1)) - 1
for j in xrange(60000):
    l1 = 1/(1+np.exp(-(np.dot(X,syn0))))
    l2 = 1/(1+np.exp(-(np.dot(l1,syn1))))
    l2_delta = (y - l2)*(l2*(1-l2))
    l1_delta = l2_delta.dot(syn1.T) * (l1 * (1-l1))
    syn1 += l1.T.dot(l2_delta)
    syn0 += X.T.dot(l1_delta)
&lt;/pre&gt;

&lt;p&gt;&lt;b&gt;Other Languages: &lt;/b&gt;&lt;a href=&quot;https://github.com/Marenz/neural_net_examples&quot;&gt;D&lt;/a&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;However, this is a bit terse…. let’s break it apart into a few simple parts.&lt;/p&gt;

&lt;hr /&gt;

&lt;script async=&quot;&quot; src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;

&lt;!-- Part 1 --&gt;
&lt;p&gt;&lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px;text-align:center&quot; data-ad-client=&quot;ca-pub-6751104560361558&quot; data-ad-slot=&quot;2365390629&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;Part 1: A Tiny Toy Network&lt;/h2&gt;

&lt;p&gt;A neural network trained with backpropagation is attempting to use input to predict output.&lt;/p&gt;
&lt;center&gt;
&lt;style type=&quot;text/css&quot;&gt;
.tg  {border-collapse:collapse;border-spacing:0;border-color:#ccc;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#ccc;color:#333;background-color:#fff;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#ccc;color:#333;background-color:#f0f0f0;}
.tg .tg-5rcs{font-weight:bold;font-size:20px;}
.tg .tg-4kyz{font-size:20px;text-align:center;}
&lt;/style&gt;
&lt;table class=&quot;tg&quot;&gt;
  &lt;tr&gt;
    &lt;th class=&quot;tg-5rcs&quot; colspan=&quot;3&quot;&gt;Inputs&lt;/th&gt;
    &lt;th class=&quot;tg-5rcs&quot;&gt;Output&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/center&gt;

&lt;p&gt;Consider trying to predict the output column given the three input columns. We could solve this problem by simply &lt;b&gt;measuring statistics&lt;/b&gt; between the input values and the output values. If we did so, we would see that the leftmost input column is &lt;i&gt;perfectly correlated&lt;/i&gt; with the output. Backpropagation, in its simplest form, measures statistics like this to make a model. Let's jump right in and use it to do this.&lt;/p&gt;
&lt;h3&gt;2 Layer Neural Network:&lt;/h3&gt;
&lt;pre class=&quot;brush: python&quot;&gt;
import numpy as np

# sigmoid function
def nonlin(x,deriv=False):
    if(deriv==True):
        return x*(1-x)
    return 1/(1+np.exp(-x))
    
# input dataset
X = np.array([  [0,0,1],
                [0,1,1],
                [1,0,1],
                [1,1,1] ])
    
# output dataset            
y = np.array([[0,0,1,1]]).T

# seed random numbers to make calculation
# deterministic (just a good practice)
np.random.seed(1)

# initialize weights randomly with mean 0
syn0 = 2*np.random.random((3,1)) - 1

for iter in xrange(10000):

    # forward propagation
    l0 = X
    l1 = nonlin(np.dot(l0,syn0))

    # how much did we miss?
    l1_error = y - l1

    # multiply how much we missed by the 
    # slope of the sigmoid at the values in l1
    l1_delta = l1_error * nonlin(l1,True)

    # update weights
    syn0 += np.dot(l0.T,l1_delta)

print &quot;Output After Training:&quot;
print l1

&lt;/pre&gt;
&lt;pre&gt;
Output After Training:
[[ 0.00966449]
 [ 0.00786506]
 [ 0.99358898]
 [ 0.99211957]]
&lt;/pre&gt;
&lt;center&gt;
&lt;style type=&quot;text/css&quot;&gt;
.tg  {border-collapse:collapse;border-spacing:0;border-color:#ccc;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#ccc;color:#333;background-color:#fff;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#ccc;color:#333;background-color:#f0f0f0;}
.tg .tg-5rcs{font-weight:bold;font-size:20px; text-align:center; padding-left:20px; padding-right: 20px;}
.tg .tg-4kyx{font-size:20px;text-align:center;font-weight:italic; padding-left:20px; padding-right: 20px;}
.tg .tg-4kyz{font-size:20px;text-align:left; padding-left: 20px;}
&lt;/style&gt;
&lt;table class=&quot;tg&quot;&gt;
  &lt;tr&gt;
    &lt;th class=&quot;tg-5rcs&quot; colspan=&quot;1&quot;&gt;Variable&lt;/th&gt;
    &lt;th class=&quot;tg-5rcs&quot;&gt;Definition&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyx&quot;&gt;X&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;Input dataset matrix where each row is a training example&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyx&quot;&gt;y&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;Output dataset matrix where each row is a training example&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyx&quot;&gt;l0&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;First Layer of the Network, specified by the input data&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyx&quot;&gt;l1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;Second Layer of the Network, otherwise known as the hidden layer&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyx&quot;&gt;syn0&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;First layer of weights, Synapse 0, connecting l0 to l1.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyx&quot;&gt;*&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;Elementwise multiplication, so two vectors of equal size are multiplying corresponding values 1-to-1 to generate a final vector of identical size.&lt;/td&gt;
  &lt;/tr&gt;
  
    &lt;tr&gt;
    &lt;td class=&quot;tg-4kyx&quot;&gt;-&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;Elementwise subtraction, so two vectors of equal size are subtracting corresponding values 1-to-1 to generate a final vector of identical size.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyx&quot;&gt;x.dot(y)&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;If x and y are vectors, this is a dot product. If both are matrices, it's a matrix-matrix multiplication. If only one is a matrix, then it's vector matrix multiplication.&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/center&gt;

&lt;p&gt;As you can see in the &quot;Output After Training&quot;, it works!!! Before I describe processes, I recommend playing around with the code to get an intuitive feel for how it works. You should be able to run it &quot;as is&quot; in an &lt;a href=&quot;http://ipython.org/notebook.html&quot;&gt;ipython notebook&lt;/a&gt; (or a script if you must, but I HIGHLY recommend the notebook). Here are some good places to look in the code: &lt;br /&gt;
&lt;div style=&quot;padding-left:20px&quot;&gt;
• Compare l1 after the first iteration and after the last iteration. &lt;br /&gt;
• Check out the &quot;nonlin&quot; function. This is what gives us a probability as output.&lt;br /&gt;
• Check out how l1_error changes as you iterate. &lt;br /&gt;
• Take apart line 36. Most of the secret sauce is here. &lt;br /&gt;
• Check out line 39. Everything in the network prepares for this operation. &lt;br /&gt;
&lt;br /&gt;
&lt;/div&gt;

&lt;p&gt;
Let's walk through the code line by line.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Recommendation:&lt;/b&gt; open this blog in two screens so you can see the code while you read it. That's kinda what I did while I wrote it. :)&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 01:&lt;/b&gt;
This imports numpy, which is a linear algebra library. This is our only dependency.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 04:&lt;/b&gt;
This is our &quot;nonlinearity&quot;. While it can be several kinds of functions, this nonlinearity maps a function called a &quot;sigmoid&quot;. A &lt;a href=&quot;https://en.wikipedia.org/wiki/Sigmoid_function&quot;&gt;sigmoid function&lt;/a&gt; maps any value to a value between 0 and 1. We use it to convert numbers to probabilities. It also has several other desirable properties for training neural networks.
&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/sigmoid.png&quot; alt=&quot;&quot; /&gt;

&lt;p&gt;&lt;b&gt;Line 05:&lt;/b&gt;
Notice that this function can also generate the derivative of a sigmoid (when deriv=True). One of the desirable properties of a sigmoid function is that its output can be used to create its derivative. If the sigmoid's output is a variable &quot;out&quot;, then the derivative is simply out * (1-out). This is very efficient. &lt;br /&gt;&lt;br /&gt;

If you're unfamililar with derivatives, just think about it as the slope of the sigmoid function at a given point (as you can see above, different points have different slopes). For more on derivatives, check out this &lt;a href=&quot;https://www.khanacademy.org/math/differential-calculus/taking-derivatives/derivative_intro/v/calculus-derivatives-1&quot;&gt; derivatives tutorial&lt;/a&gt; from Khan Academy.

&lt;p&gt;&lt;b&gt;Line 10:&lt;/b&gt;
This initializes our input dataset as a numpy matrix. Each row is a single &quot;training example&quot;. Each column corresponds to one of our input nodes. Thus, we have 3 input nodes to the network and 4 training examples.  
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 16:&lt;/b&gt;
This initializes our output dataset. In this case, I generated the dataset horizontally (with a single row and 4 columns) for space. &quot;.T&quot; is the transpose function. After the transpose, this y matrix has 4 rows with one column. Just like our input, each row is a training example, and each column (only one) is an output node. So, our network has 3 inputs and 1 output.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 20:&lt;/b&gt;
It's good practice to seed your random numbers. Your numbers will still be randomly distributed, but they'll be randomly distributed in &lt;b&gt;exactly the same way&lt;/b&gt; each time you train. This makes it easier to see how your changes affect the network.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 23:&lt;/b&gt;
This is our weight matrix for this neural network. It's called &quot;syn0&quot; to imply &quot;synapse zero&quot;. Since we only have 2 layers (input and output), we only need one matrix of weights to connect them. Its dimension is (3,1) because we have 3 inputs and 1 output. Another way of looking at it is that l0 is of size 3 and l1 is of size 1. Thus, we want to connect every node in l0 to every node in l1, which requires a matrix of dimensionality (3,1). :)
&lt;br /&gt;&lt;br /&gt;
Also notice that it is initialized randomly with a mean of zero. There is quite a bit of theory that goes into weight initialization. For now, just take it as a best practice that it's a good idea to have a mean of zero in weight initialization.
&lt;br /&gt;&lt;br /&gt;
Another note is that the &quot;neural network&quot; is really just this matrix. We have &quot;layers&quot; l0 and l1 but they are transient values based on the dataset. We don't save them. All of the learning is stored in the syn0 matrix.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 25:&lt;/b&gt;
This begins our actual network training code. This for loop &quot;iterates&quot; multiple times over the training code to optimize our network to the dataset.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 28:&lt;/b&gt;
Since our first layer, l0, is simply our data. We explicitly describe it as such at this point. Remember that X contains 4 training examples (rows). We're going to process all of them at the same time in this implementation. This is known as &quot;full batch&quot; training. Thus, we have 4 different l0 rows, but you can think of it as a single training example if you want. It makes no difference at this point. (We could load in 1000 or 10,000 if we wanted to without changing any of the code).
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 29:&lt;/b&gt;
This is our prediction step. Basically, we first let the network &quot;try&quot; to predict the output given the input. We will then study how it performs so that we can adjust it to do a bit better for each iteration. &lt;br /&gt;&lt;br /&gt;

This line contains 2 steps. The first matrix multiplies l0 by syn0. The second passes our output through the sigmoid function. Consider the dimensions of each:&lt;br /&gt;&lt;br /&gt;
(4 x 3) dot (3 x 1) = (4 x 1) &lt;br /&gt;&lt;br /&gt;
Matrix multiplication is ordered, such the dimensions in the middle of the equation must be the same. The final matrix generated is thus the number of rows of the first matrix and the number of columns of the second matrix.&lt;br /&gt;&lt;br /&gt;
Since we loaded in 4 training examples, we ended up with 4 guesses for the correct answer, a (4 x 1) matrix. Each output corresponds with the network's guess for a given input. Perhaps it becomes intuitive why we could have &quot;loaded in&quot; an arbitrary number of training examples. The matrix multiplication would still work out. :)
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 32:&lt;/b&gt;
So, given that l1 had a &quot;guess&quot; for each input. We can now compare how well it did by subtracting the true answer (y) from the guess (l1). l1_error is just a vector of positive and negative numbers reflecting how much the network missed.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Line 36:&lt;/b&gt;
Now we're getting to the good stuff! This is the secret sauce! There's a lot going on in this line, so let's further break it into two parts. 
&lt;h4&gt;First Part: The Derivative&lt;/h4&gt;
&lt;pre class=&quot;brush:python&quot;&gt;
nonlin(l1,True)
&lt;/pre&gt;
&lt;/p&gt;

&lt;p&gt;
If l1 represents these three dots, the code above generates the slopes of the lines below. Notice that very high values such as x=2.0 (green dot) and very low values such as x=-1.0 (purple dot) have rather shallow slopes. The highest slope you can have is at x=0 (blue dot). This plays an important role. Also notice that all derivatives are between 0 and 1.
&lt;/p&gt;

&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/sigmoid-deriv-2.png&quot; alt=&quot;&quot; /&gt;

&lt;h4&gt;Entire Statement: The Error Weighted Derivative&lt;/h4&gt;
&lt;pre class=&quot;brush:python&quot;&gt;
l1_delta = l1_error * nonlin(l1,True)
&lt;/pre&gt;
&lt;p&gt;There are more &quot;mathematically precise&quot; ways than &quot;The Error Weighted Derivative&quot; but I think that this captures the intuition. l1_error is a (4,1) matrix. nonlin(l1,True) returns a (4,1) matrix. What we're doing is multiplying them &lt;a href=&quot;http://nl.mathworks.com/help/matlab/ref/times.html&quot;&gt;&quot;elementwise&quot;&lt;/a&gt;. This returns a (4,1) matrix &lt;b&gt;l1_delta&lt;/b&gt; with the multiplied values. &lt;br /&gt;&lt;br /&gt;

When we multiply the &quot;slopes&quot; by the error, we are &lt;b&gt;reducing the error of high confidence predictions&lt;/b&gt;. Look at the sigmoid picture again! If the slope was really shallow (close to 0), then the network either had a very high value, or a very low value. This means that the network was quite confident one way or the other. However, if the network guessed something close to (x=0, y=0.5) then it isn't very confident. We update these &quot;wishy-washy&quot; predictions most heavily, and we tend to leave the confident ones alone by multiplying them by a number close to 0.

&lt;p&gt;&lt;b&gt;Line 39:&lt;/b&gt;
We are now ready to update our network! Let's take a look at a single training example.
&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/toy_network_deriv.png&quot; alt=&quot;&quot; /&gt;
In this training example, we're all setup to update our weights. Let's update the far left weight (9.5).&lt;br /&gt;&lt;br /&gt;
&lt;b&gt;weight_update = input_value * l1_delta&lt;/b&gt;
&lt;br /&gt;&lt;br /&gt;
For the far left weight, this would multiply 1.0 * the l1_delta. Presumably, this would increment 9.5 ever so slightly. Why only a small ammount? Well, the prediction was already very confident, and the prediction was largely correct. A small error and a small slope means a VERY small update. Consider all the weights. It would ever so slightly increase all three.
&lt;/p&gt;
&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/toy_network_batch.png&quot; alt=&quot;&quot; /&gt;
&lt;p&gt;
However, because we're using a &quot;full batch&quot; configuration, we're doing the above step on all four training examples. So, it looks a lot more like the image above. So, what does line 39 do? It computes the weight updates for each weight for each training example, sums them, and updates the weights, all in a simple line. Play around with the matrix multiplication and you'll see it do this! 
&lt;/p&gt;

&lt;p&gt;&lt;h3&gt;Takeaways:&lt;/h3&gt;
So, now that we've looked at how the network updates, let's look back at our training data and reflect. When both an input and a output are 1, we increase the weight between them. When an input is 1 and an output is 0, we decrease the weight between them. &lt;/p&gt;

&lt;center&gt;
&lt;style type=&quot;text/css&quot;&gt;
.tg  {border-collapse:collapse;border-spacing:0;border-color:#ccc;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#ccc;color:#333;background-color:#fff;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#ccc;color:#333;background-color:#f0f0f0;}
.tg .tg-5rcs{font-weight:bold;font-size:20px;}
.tg .tg-4kyz{font-size:20px;text-align:center;}
&lt;/style&gt;
&lt;table class=&quot;tg&quot;&gt;
  &lt;tr&gt;
    &lt;th class=&quot;tg-5rcs&quot; colspan=&quot;3&quot;&gt;Inputs&lt;/th&gt;
    &lt;th class=&quot;tg-5rcs&quot;&gt;Output&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/center&gt;
&lt;p&gt;
Thus, in our four training examples below, the weight from the first input to the output would &lt;b&gt;consistently increment or remain unchanged&lt;/b&gt;, whereas the other two weights would find themselves &lt;b&gt;both increasing and decreasing across training examples&lt;/b&gt; (cancelling out progress). This phenomenon is what causes our network to learn based on correlations between the input and output.
&lt;/p&gt;

&lt;hr /&gt;
&lt;script async=&quot;&quot; src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- Part 2 --&gt;
&lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px;text-align:center&quot; data-ad-client=&quot;ca-pub-6751104560361558&quot; data-ad-slot=&quot;3842123822&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;hr /&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;Part 2: A Slightly Harder Problem&lt;/h2&gt;
&lt;br /&gt;
&lt;center&gt;
&lt;style type=&quot;text/css&quot;&gt;
.tg  {border-collapse:collapse;border-spacing:0;border-color:#ccc;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#ccc;color:#333;background-color:#fff;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#ccc;color:#333;background-color:#f0f0f0;}
.tg .tg-5rcs{font-weight:bold;font-size:20px;}
.tg .tg-4kyz{font-size:20px;text-align:center}
&lt;/style&gt;
&lt;table class=&quot;tg&quot;&gt;
  &lt;tr&gt;
    &lt;th class=&quot;tg-5rcs&quot; colspan=&quot;3&quot;&gt;Inputs&lt;/th&gt;
    &lt;th class=&quot;tg-5rcs&quot;&gt;Output&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/center&gt;


&lt;p&gt;Consider trying to predict the output column given the two input columns. A key takeway should be that neither columns have any correlation to the output. Each column has a 50% chance of predicting a 1 and a 50% chance of predicting a 0. &lt;/p&gt;

&lt;p&gt;
So, what's the pattern? It appears to be completely unrelated to column three, which is always 1. However, columns 1 and 2 give more clarity. If either column 1 or 2 are a 1 (but not both!) then the output is a 1. This is our pattern. 
&lt;/p&gt;
&lt;p&gt;
This is considered a &quot;nonlinear&quot; pattern because there isn't a direct one-to-one relationship between the input and output. Instead, there is a &lt;b&gt;one-to-one relationship between a combination of inputs&lt;/b&gt;, namely columns 1 and 2.
&lt;/p&gt;



&lt;div id=&quot;pic1&quot; style=&quot;float:left;width:50%&quot;&gt;&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/rcnn.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div id=&quot;pic2&quot; style=&quot;float:right;width:50%;&quot;&gt;&lt;img class=&quot;img-responsive&quot; width=&quot;100%&quot; src=&quot;/img/margritti-this-is-not-a-pipe.jpg&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;&lt;/div&gt;

&lt;p&gt;Believe it or not, image recognition is a similar problem. If one had 100 identically sized images of pipes and bicycles, no individual pixel position would directly correlate with the presence of a bicycle or pipe. The pixels might as well be random from a purely statistical point of view. However, certain &lt;b&gt;combinations of pixels&lt;/b&gt; are not random, namely the combination that forms the image of a bicycle or a person.&lt;/p&gt;

&lt;h3&gt;Our Strategy&lt;/h3&gt;

&lt;p&gt; In order to first combine pixels into something that can then have a one-to-one relationship with the output, we need to add another layer. Our first layer will combine the inputs, and our second layer will then map them to the output using the output of the first layer as input. Before we jump into an implementation though, take a look at this table.&lt;/p&gt;

&lt;center&gt;
&lt;style type=&quot;text/css&quot;&gt;
.tg  {border-collapse:collapse;border-spacing:0;border-color:#ccc;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#ccc;color:#333;background-color:#fff;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#ccc;color:#333;background-color:#f0f0f0;}
.tg .tg-5rcs{font-weight:bold;font-size:20px;}
.tg .tg-4kyz{font-size:20px;text-align:center}
&lt;/style&gt;
&lt;table class=&quot;tg&quot;&gt;
  &lt;tr&gt;
    &lt;th class=&quot;tg-5rcs&quot; colspan=&quot;3&quot;&gt;Inputs (l0)&lt;/th&gt;
    &lt;th class=&quot;tg-5rcs&quot; colspan=&quot;4&quot;&gt;Hidden Weights (l1)&lt;/th&gt;
    &lt;th class=&quot;tg-5rcs&quot;&gt;Output (l2)&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0.1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0.2&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0.5&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0.2&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0.2&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0.6&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0.7&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0.1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0.3&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0.2&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0.3&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0.9&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0.2&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0.1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0.3&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0.8&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;0&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/center&gt;

&lt;p&gt;
If we randomly initialize our weights, we will get hidden state values for layer 1. Notice anything? &lt;b&gt;The second column (second hidden node), has a slight correlation with the output already!&lt;/b&gt; It's not perfect, but it's there. Believe it or not, this is a huge part of how neural networks train. (Arguably, it's the only way that neural networks train.) What the training below is going to do is amplify that correlation. It's both going to update syn1 to map it to the output, and update syn0 to be better at producing it from the input!
&lt;/p&gt;

&lt;p&gt;
Note: The field of adding more layers to model more combinations of relationships such as this is known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Deep_learning&quot;&gt;&quot;deep learning&quot;&lt;/a&gt; because of the increasingly deep layers being modeled.&lt;/p&gt;

&lt;h3&gt;3 Layer Neural Network:&lt;/h3&gt;
&lt;pre class=&quot;brush: python&quot;&gt;
import numpy as np

def nonlin(x,deriv=False):
	if(deriv==True):
	    return x*(1-x)

	return 1/(1+np.exp(-x))
    
X = np.array([[0,0,1],
            [0,1,1],
            [1,0,1],
            [1,1,1]])
                
y = np.array([[0],
			[1],
			[1],
			[0]])

np.random.seed(1)

# randomly initialize our weights with mean 0
syn0 = 2*np.random.random((3,4)) - 1
syn1 = 2*np.random.random((4,1)) - 1

for j in xrange(60000):

	# Feed forward through layers 0, 1, and 2
    l0 = X
    l1 = nonlin(np.dot(l0,syn0))
    l2 = nonlin(np.dot(l1,syn1))

    # how much did we miss the target value?
    l2_error = y - l2
    
    if (j% 10000) == 0:
        print &quot;Error:&quot; + str(np.mean(np.abs(l2_error)))
        
    # in what direction is the target value?
    # were we really sure? if so, don't change too much.
    l2_delta = l2_error*nonlin(l2,deriv=True)

    # how much did each l1 value contribute to the l2 error (according to the weights)?
    l1_error = l2_delta.dot(syn1.T)
    
    # in what direction is the target l1?
    # were we really sure? if so, don't change too much.
    l1_delta = l1_error * nonlin(l1,deriv=True)

    syn1 += l1.T.dot(l2_delta)
    syn0 += l0.T.dot(l1_delta)

&lt;/pre&gt;
&lt;!-- &lt;h3&gt;Runtime Output:&lt;/h3&gt; --&gt;
&lt;pre&gt;
Error:0.496410031903
Error:0.00858452565325
Error:0.00578945986251
Error:0.00462917677677
Error:0.00395876528027
Error:0.00351012256786
&lt;/pre&gt;
&lt;center&gt;
&lt;style type=&quot;text/css&quot;&gt;
.tg  {border-collapse:collapse;border-spacing:0;border-color:#ccc;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#ccc;color:#333;background-color:#fff;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#ccc;color:#333;background-color:#f0f0f0;}
.tg .tg-5rcs{font-weight:bold;font-size:20px; text-align:center; padding-left:20px; padding-right: 20px;}
.tg .tg-4kyx{font-size:20px;text-align:center;font-weight:italic; padding-left:20px; padding-right: 20px;}
.tg .tg-4kyz{font-size:20px;text-align:left; padding-left: 20px;}
&lt;/style&gt;
&lt;table class=&quot;tg&quot;&gt;
  &lt;tr&gt;
    &lt;th class=&quot;tg-5rcs&quot; colspan=&quot;1&quot;&gt;Variable&lt;/th&gt;
    &lt;th class=&quot;tg-5rcs&quot;&gt;Definition&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyx&quot;&gt;X&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;Input dataset matrix where each row is a training example&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyx&quot;&gt;y&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;Output dataset matrix where each row is a training example&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyx&quot;&gt;l0&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;First Layer of the Network, specified by the input data&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyx&quot;&gt;l1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;Second Layer of the Network, otherwise known as the hidden layer&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyx&quot;&gt;l2&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;Final Layer of the Network, which is our hypothesis, and should approximate the correct answer as we train.&lt;/td&gt;
  &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td class=&quot;tg-4kyx&quot;&gt;syn0&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;First layer of weights, Synapse 0, connecting l0 to l1.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyx&quot;&gt;syn1&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;Second layer of weights, Synapse 1 connecting l1 to l2.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyx&quot;&gt;l2_error&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;This is the amount that the neural network &quot;missed&quot;.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyx&quot;&gt;l2_delta&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;This is the error of the network scaled by the confidence. It's almost identical to the error except that very confident errors are muted.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyx&quot;&gt;l1_error&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;Weighting l2_delta by the weights in syn1, we can calculate the error in the middle/hidden layer.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-4kyx&quot;&gt;l1_delta&lt;/td&gt;
    &lt;td class=&quot;tg-4kyz&quot;&gt;This is the l1 error of the network scaled by the confidence. Again, it's almost identical to the l1_error except that confident errors are muted.&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/center&gt;
&lt;p&gt;&lt;b&gt;Recommendation:&lt;/b&gt; open this blog in two screens so you can see the code while you read it. That's kinda what I did while I wrote it. :)&lt;/p&gt;

&lt;p&gt;
Everything should look very familiar! It's really just 2 of the previous implementation stacked on top of each other. The output of the first layer (l1) is the input to the second layer. The only new thing happening here is on line 43.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Line 43:&lt;/b&gt; uses the &quot;confidence weighted error&quot; from l2 to establish an error for l1. To do this, it simply sends the error across the weights from l2 to l1. This gives what you could call a &quot;contribution weighted error&quot; because we learn how much each node value in l1 &quot;contributed&quot; to the error in l2. This step is called &quot;backpropagating&quot; and is the namesake of the algorithm. We then update syn0 using the same steps we did in the 2 layer implementation.
&lt;/p&gt;

&lt;hr /&gt;
&lt;script async=&quot;&quot; src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- Part 3 --&gt;
&lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px;text-align:center&quot; data-ad-client=&quot;ca-pub-6751104560361558&quot; data-ad-slot=&quot;5318857026&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;hr /&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;Part 3: Conclusion and Future Work&lt;/h2&gt;
&lt;br /&gt;

&lt;p&gt;&lt;h3&gt;My Recommendation:&lt;/h3&gt;

If you're serious about neural networks, I have one recommendation. &lt;b&gt;Try to rebuild this network from memory.&lt;/b&gt; I know that might sound a bit crazy, but it seriously helps. If you want to be able to create arbitrary architectures based on new academic papers or read and understand sample code for these different architectures, I think that it's a killer exercise. I think it's useful even if you're using frameworks like &lt;a href=&quot;http://torch.ch/&quot;&gt;Torch&lt;/a&gt;, &lt;a href=&quot;http://caffe.berkeleyvision.org/&quot;&gt;Caffe&lt;/a&gt;, or &lt;a href=&quot;http://deeplearning.net/software/theano/&quot;&gt;Theano&lt;/a&gt;. I worked with neural networks for a couple years before performing this exercise, and it was the best investment of time I've made in the field (and it didn't take long). 
&lt;/p&gt;


&lt;p&gt;&lt;h3&gt;Future Work&lt;/h3&gt;
This toy example still needs quite a few bells and whistles to really approach the state-of-the-art architectures. Here's a few things you can look into if you want to further improve your network. (Perhaps I will in a followup post.)&lt;/p&gt;

&lt;p style=&quot;padding-left:20px&quot;&gt;
• Alpha &lt;br /&gt;
• &lt;a href=&quot;http://stackoverflow.com/questions/2480650/role-of-bias-in-neural-networks&quot;&gt;Bias Units&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&quot;https://class.coursera.org/ml-003/lecture/106&quot;&gt;Mini-Batches&lt;/a&gt;&lt;br /&gt;
• Delta Trimming &lt;br /&gt;
• &lt;a href=&quot;https://www.youtube.com/watch?v=XqRUHEeiyCs&quot;&gt;Parameterized Layer Sizes&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&quot;https://class.coursera.org/ml-003/lecture/63&quot;&gt;Regularization&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&quot;http://videolectures.net/nips2012_hinton_networks/&quot;&gt;Dropout&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&quot;https://www.youtube.com/watch?v=XqRUHEeiyCs&quot;&gt;Momentum&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&quot;http://arxiv.org/abs/1502.03167&quot;&gt;Batch Normalization&lt;/a&gt; &lt;br /&gt;
• GPU Compatability&lt;br /&gt;
• Other Awesomeness You Implement&lt;br /&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;Want to Work in Machine Learning?&lt;/h2&gt;


&lt;p&gt;
One of the best things you can do to learn Machine Learning is to have a job where you're &lt;b&gt;practicing Machine Learning professionally&lt;/b&gt;. I'd encourage you to check out the &lt;a href=&quot;https://www.linkedin.com/vsearch/j?page_num=1&amp;amp;locationType=Y&amp;amp;f_C=74158&amp;amp;trk=jobs_biz_prem_all_header&quot;&gt;positions at Digital Reasoning&lt;/a&gt; in your job hunt. If you have questions about any of the positions or about life at Digital Reasoning, feel free to send me a message on &lt;a href=&quot;https://www.linkedin.com/profile/view?id=226572677&amp;amp;trk=nav_responsive_tab_profile&quot;&gt;my LinkedIn&lt;/a&gt;. I'm happy to hear about where you want to go in life, and help you evaluate whether Digital Reasoning could be a good fit.
&lt;/p&gt;

&lt;p&gt;If none of the positions above feel like a good fit. Continue your search! Machine Learning expertise is one of the &lt;b&gt;most valuable skills in the job market today&lt;/b&gt;, and there are many firms looking for practitioners. Perhaps some of these services below will help you in your hunt.

&lt;style type=&quot;text/css&quot;&gt;#indJobContent{padding-bottom: 5px;}#indJobContent .company_location{font-size: 11px;overflow: hidden;display:block;}#indJobContent.wide .job{display:block;float:left;margin-right: 5px;width: 135px;overflow: hidden}#indeed_widget_wrapper{position: relative;font-family: 'Helvetica Neue',Helvetica,Arial,sans-serif;font-size: 13px;font-weight: normal;line-height: 18px;padding: 10px;height: auto;overflow: hidden;}#indeed_widget_header{font-size:18px; padding-bottom: 5px; }#indeed_search_wrapper{clear: both;font-size: 12px;margin-top: 5px;padding-top: 5px;}#indeed_search_wrapper label{font-size: 12px;line-height: inherit;text-align: left; margin-right: 5px;}#indeed_search_wrapper input[type='text']{width: 100px; font-size: 11px; }#indeed_search_wrapper #qc{float:left;}#indeed_search_wrapper #lc{float:right;}#indeed_search_wrapper.stacked #qc, #indeed_search_wrapper.stacked #lc{float: none; clear: both;}#indeed_search_wrapper.stacked input[type='text']{width: 150px;}#indeed_search_wrapper.stacked label{display: block;padding-bottom: 5px;}#indeed_search_footer{width:295px; padding-top: 5px; clear: both;}#indeed_link{position: absolute;bottom: 1px;right: 5px;clear: both;font-size: 11px; }#indeed_link a{text-decoration: none;}#results .job{padding: 1px 0px;}#pagination { clear: both; }&lt;/style&gt;&lt;style type=&quot;text/css&quot;&gt;
#indeed_widget_wrapper{ width: 50%; height: 600px; background: #FFFFFF;}
#indeed_widget_wrapper{ border: 1px solid #DDDDDD; }
#indeed_widget_wrapper, #indeed_link a{ color: #000000;}
#indJobContent, #indeed_search_wrapper{ border-top: 1px solid #DDDDDD; }
#indJobContent a { color: #00c; }
#indeed_widget_header{ color: #000000; }
&lt;/style&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var ind_pub = '9172611916208179';
var ind_el = 'indJobContent';
var ind_pf = '';
var ind_q = 'Machine Learning';
var ind_l = '';
var ind_chnl = 'none';
var ind_n = 15;
var ind_d = 'http://www.indeed.com';
var ind_t = 40;
var ind_c = 30;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.indeed.com/ads/jobroll-widget-v3.js&quot;&gt;&lt;/script&gt;
&lt;div id=&quot;indeed_widget_wrapper&quot; style=&quot;&quot;&gt;
&lt;div id=&quot;indeed_widget_header&quot;&gt;Machine Learning Jobs&lt;/div&gt;

&lt;div id=&quot;indJobContent&quot; class=&quot;&quot;&gt;&lt;/div&gt;

&lt;div id=&quot;indeed_search_wrapper&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
function clearDefaults() {
var formInputs = document.getElementById('indeed_jobform').elements;
for(var i = 0; i &lt; formInputs.length; i++) {
if(formInputs[i].value == 'title, keywords' || formInputs[i].value == 'city, state, or zip') {
formInputs[i].value = '';
}
}
}
&lt;/script&gt;
&lt;form onsubmit=&quot;clearDefaults();&quot; method=&quot;get&quot; action=&quot;http://www.indeed.com/jobs&quot; id=&quot;indeed_jobform&quot; target=&quot;_new&quot;&gt;
&lt;div id=&quot;qc&quot;&gt;&lt;label&gt;What:&lt;/label&gt;&lt;input type=&quot;text&quot; onfocus=&quot;this.value=&amp;quot;&amp;quot;&quot; value=&quot;title, keywords&quot; name=&quot;q&quot; id=&quot;q&quot; /&gt;&lt;/div&gt;
&lt;div id=&quot;lc&quot;&gt;&lt;label&gt;Where:&lt;/label&gt;&lt;input type=&quot;text&quot; onfocus=&quot;this.value=&amp;quot;&amp;quot;&quot; value=&quot;city, state, or zip&quot; name=&quot;l&quot; id=&quot;l&quot; /&gt;&lt;/div&gt;
&lt;div id=&quot;indeed_search_footer&quot;&gt;
&lt;div style=&quot;float:left&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;Find Jobs&quot; class=&quot;findjobs&quot; /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;input type=&quot;hidden&quot; name=&quot;indpubnum&quot; id=&quot;indpubnum&quot; value=&quot;9172611916208179&quot; /&gt;
&lt;/form&gt;
&lt;/div&gt;

&lt;div id=&quot;indeed_link&quot;&gt;
&lt;a title=&quot;Job Search&quot; href=&quot;http://www.indeed.com/&quot; target=&quot;_new&quot;&gt;jobs by &lt;img alt=&quot;Indeed&quot; src=&quot;http://www.indeed.com/p/jobsearch.gif&quot; style=&quot;border: 0;vertical-align: bottom;&quot; /&gt;
&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div style=&quot;position:absolute; margin-top:-600px; margin-left:400px&quot; id=&quot;MonsterJobSearchResultPlaceHolderNXAAAA_e_e&quot; class=&quot;xmns_distroph&quot;&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
(function() {
  var oScript = document.createElement('script');
  oScript.type = 'text/javascript';
  oScript.async = true;
  oScript.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'publisher.monster.com/Services/WidgetHandler.ashx?WidgetID=EAAQUeLsOxB7mqhf97nwIpkVXQ--&amp;Verb=Initialize';
  var oParent = document.getElementsByTagName('script')[0];
  oParent.parentNode.insertBefore(oScript, oParent);
})();
&lt;/script&gt;
&lt;a id=&quot;monsterBrowseLinkNXAAAA_e_e&quot; class=&quot;monsterBrowseLink fnt4&quot; href=&quot;http://jobsearch.monster.com/jobs/?q=Machine-Learning&quot;&gt;View More Job Search Results&lt;/a&gt;


&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/shCore.css&quot; /&gt;
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/shThemeDefault.css&quot; /&gt;
&lt;script src=&quot;/js/shCore.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/js/shLegacy.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/js/shBrushPython.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
	// SyntaxHighlighter.config.bloggerMode = true;
	SyntaxHighlighter.config.toolbar = true;
    SyntaxHighlighter.all();
&lt;/script&gt;
&lt;/p&gt;&lt;/p&gt;&lt;/p&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 12 Jul 2015 13:00:00 +0100</pubDate>
        <link>http://localhost:4000/2015/07/12/basic-python-network/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/07/12/basic-python-network/</guid>
        
        
      </item>
    
      <item>
        <title>Word2Vec Analysis of Harry Potter</title>
        <description>&lt;p&gt;Word2vec is a very cool algorithm that uses neural networks to map words to feature vectors. Those vectors then have interesting properties. You can use these vectors to cluster words into groups… find words that are most similar in an unsupervised fashion.&lt;/p&gt;

&lt;p&gt;I ran &lt;a href=&quot;https://code.google.com/p/word2vec/&quot;&gt;word2vec&lt;/a&gt; on the 7 harry potter books and ran some cosine similarities on words i thought might be interesting. (using the open source &lt;a href=&quot;http://radimrehurek.com/gensim/&quot;&gt;Gensim&lt;/a&gt; library I love) My favorite is the word “password” below… which revealed a list of passwords to the Gryffendor Common Room.&lt;/p&gt;

&lt;p&gt;The top word of each list is the focus word… and then a list of the most similar words thereafter.&lt;/p&gt;

&lt;p&gt;(64 dimensions : 1 epoch)&lt;br /&gt;
&lt;b&gt;1.0000000000000002:&amp;lt;expecto&lt;/b&gt; &lt;br /&gt;
0.8790060473734644:&amp;lt;patronum &lt;br /&gt;
0.755879251292692:&amp;lt;pettigrews &lt;br /&gt;
0.6931649914220047:&amp;lt;scabbers &lt;br /&gt;
0.6921019768155199:&amp;lt;pettigrew &lt;br /&gt;
0.6854965539870754:&amp;lt;lumos &lt;br /&gt;
0.6800035990521911:&amp;lt;groped &lt;br /&gt;
0.664763725362591:&amp;lt;buckbeaks &lt;br /&gt;
0.6386204400460198:&amp;lt;lupins &lt;br /&gt;
0.6368874336372525:&amp;lt;forcing &lt;br /&gt;
&lt;br /&gt;
(256 dimensions : 10 epochs)&lt;br /&gt;
&lt;b&gt;1.0000000000000002:&amp;lt;expecto&lt;/b&gt; &lt;br /&gt;
0.881676712172453:&amp;lt;patronum &lt;br /&gt;
0.66633365764735:&amp;lt;expec &lt;br /&gt;
0.5100899639798923:&amp;lt;patrono &lt;br /&gt;
0.4183506799917183:&amp;lt;poppy &lt;br /&gt;
0.4151233329572086:&amp;lt;wailed &lt;br /&gt;
0.4093665595659816:&amp;lt;nicknamed &lt;br /&gt;
0.3973543132151556:&amp;lt;riddikulus &lt;br /&gt;
0.3944545196592748:&amp;lt;fistbeating &lt;br /&gt;
0.39103755743544927:&amp;lt;bristling &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(256 dimensions : 10 epochs)&lt;br /&gt;
&lt;b&gt;1.0:&amp;lt;lumos&lt;/b&gt; &lt;br /&gt;
0.42209239730743003:&amp;lt;imperio &lt;br /&gt;
0.40507159450163904:&amp;lt;ignited &lt;br /&gt;
0.3758083182732268:&amp;lt;tergeo &lt;br /&gt;
0.3744004687853999:&amp;lt;episkey &lt;br /&gt;
0.3658264199741773:&amp;lt;portus &lt;br /&gt;
0.35926607923955595:&amp;lt;uhoh &lt;br /&gt;
0.3574845249683229:&amp;lt;serpensortia &lt;br /&gt;
0.35644744188201566:&amp;lt;wandtip &lt;br /&gt;
0.3503601500539219:&amp;lt;dissendium &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(64 dimensions : 1 epoch)&lt;br /&gt;
&lt;b&gt;1.0:&amp;lt;weasley&lt;/b&gt; &lt;br /&gt;
0.7899136471577068:&amp;lt;cole &lt;br /&gt;
0.7580984973288645:&amp;lt;weasleys &lt;br /&gt;
0.704308962845765:&amp;lt;cattermole &lt;br /&gt;
0.696147590313737:&amp;lt;figg &lt;br /&gt;
0.6615516871288135:&amp;lt;bill &lt;br /&gt;
0.5775892972766857:&amp;lt;mr &lt;br /&gt;
0.5623844627363042:&amp;lt;mrs &lt;br /&gt;
0.547272989628803:&amp;lt;crouch &lt;br /&gt;
0.5346744691953205:&amp;lt;brightly &lt;br /&gt;
&lt;br /&gt;
(256 dimensions : 10 epochs)&lt;br /&gt;
&lt;b&gt;1.0:&amp;lt;weasley&lt;/b&gt; &lt;br /&gt;
0.5571492216402788:&amp;lt;mrs &lt;br /&gt;
0.525661506461713:&amp;lt;mr &lt;br /&gt;
0.5122609732187181:&amp;lt;redheads &lt;br /&gt;
0.47470149235833253:&amp;lt;greatauntie &lt;br /&gt;
0.4636894081306857:&amp;lt;basil &lt;br /&gt;
0.4615857402277965:&amp;lt;wwhats &lt;br /&gt;
0.44954942844918266:&amp;lt;whew &lt;br /&gt;
0.44593325992665894:&amp;lt;pranksters &lt;br /&gt;
0.4366713328133361:&amp;lt;weasleys &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(64 dimensions : 1 epoch)&lt;br /&gt;
&lt;b&gt;1.0000000000000002:&amp;lt;potter&lt;/b&gt; &lt;br /&gt;
0.7040619432963181:&amp;lt;severus &lt;br /&gt;
0.6994994807105462:&amp;lt;thank &lt;br /&gt;
0.6875348923351211:&amp;lt;sir &lt;br /&gt;
0.6822709821434811:&amp;lt;please &lt;br /&gt;
0.632136736822497:&amp;lt;may &lt;br /&gt;
0.6291806648311767:&amp;lt;cannot &lt;br /&gt;
0.6284403688596681:&amp;lt;yes &lt;br /&gt;
0.624241093676769:&amp;lt;kindly &lt;br /&gt;
0.6217287188964961:&amp;lt;will &lt;br /&gt;
&lt;br /&gt;
(256 dimensions : 10 epochs)&lt;br /&gt;
&lt;b&gt;0.9999999999999999:&amp;lt;potter &lt;/b&gt;&lt;br /&gt;
0.3901893042844876:&amp;lt;humble &lt;br /&gt;
0.38913611920424174:&amp;lt;rotter &lt;br /&gt;
0.36768347738598195:&amp;lt;heed &lt;br /&gt;
0.3666138243923663:&amp;lt;heroworshipped &lt;br /&gt;
0.3587120147197108:&amp;lt;woooooooo &lt;br /&gt;
0.34933445012876724:&amp;lt;characters &lt;br /&gt;
0.3440882110680894:&amp;lt;dunderbore &lt;br /&gt;
0.344022635479845:&amp;lt;questionall &lt;br /&gt;
0.34103571192794435:&amp;lt;pining &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(64 dimensions : 1 epoch)&lt;br /&gt;
&lt;b&gt;1.0000000000000002:&amp;lt;gryffindor&lt;/b&gt; &lt;br /&gt;
0.74139062089133:&amp;lt;team &lt;br /&gt;
0.734880573018089:&amp;lt;tower &lt;br /&gt;
0.7231970430099021:&amp;lt;slytherin &lt;br /&gt;
0.7021615040969098:&amp;lt;common &lt;br /&gt;
0.7018928824840882:&amp;lt;ravenclaw &lt;br /&gt;
0.6585783668158374:&amp;lt;points &lt;br /&gt;
0.6540640450146518:&amp;lt;spinnet &lt;br /&gt;
0.64507063817762:&amp;lt;bell &lt;br /&gt;
0.6289645923037345:&amp;lt;goal &lt;br /&gt;
&lt;br /&gt;
(256 dimensions : 10 epochs)&lt;br /&gt;
&lt;b&gt;1.0:&amp;lt;gryffindor&lt;/b&gt; &lt;br /&gt;
0.4581853977277023:&amp;lt;hufflepuff &lt;br /&gt;
0.4420478362268596:&amp;lt;tower &lt;br /&gt;
0.44149319299048684:&amp;lt;points &lt;br /&gt;
0.4410251892894441:&amp;lt;slytherin &lt;br /&gt;
0.4188516239321704:&amp;lt;ravenclaw &lt;br /&gt;
0.3600329597460896:&amp;lt;gryffindors &lt;br /&gt;
0.35418207017889025:&amp;lt;team &lt;br /&gt;
0.34891474092816965:&amp;lt;wellearned &lt;br /&gt;
0.3404098626732141:&amp;lt;penalty &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(64 dimensions : 1 epoch)&lt;br /&gt;
&lt;b&gt;0.9999999999999999:&amp;lt;ravenclaw&lt;/b&gt; &lt;br /&gt;
0.781214400477696:&amp;lt;hufflepuff &lt;br /&gt;
0.7512446691492253:&amp;lt;slytherin &lt;br /&gt;
0.7254427881734692:&amp;lt;captain &lt;br /&gt;
0.7208340720937167:&amp;lt;oclock &lt;br /&gt;
0.7147691706800555:&amp;lt;lee &lt;br /&gt;
0.7147331227062966:&amp;lt;montague &lt;br /&gt;
0.7018928824840882:&amp;lt;gryffindor &lt;br /&gt;
0.697691445889272:&amp;lt;team &lt;br /&gt;
0.6839508546137936:&amp;lt;wednesday &lt;br /&gt;
&lt;br /&gt;
(256 dimensions : 10 epochs) &lt;br /&gt;
&lt;b&gt;1.0:&amp;lt;ravenclaw&lt;/b&gt; &lt;br /&gt;
0.5732267167869871:&amp;lt;hufflepuff &lt;br /&gt;
0.43935832571981465:&amp;lt;slytherin &lt;br /&gt;
0.43555165040705907:&amp;lt;rowena &lt;br /&gt;
0.4188516239321704:&amp;lt;gryffindor &lt;br /&gt;
0.407678924818592:&amp;lt;turpin &lt;br /&gt;
0.38709404961590305:&amp;lt;helga &lt;br /&gt;
0.3708434204576607:&amp;lt;seeker &lt;br /&gt;
0.35874384841804063:&amp;lt;huffepuff &lt;br /&gt;
0.35602194786273583:&amp;lt;loses &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(64 dimensions : 1 epoch)&lt;br /&gt;
&lt;b&gt;1.0:&amp;lt;hufflepuff&lt;/b&gt; &lt;br /&gt;
0.7921196174194491:&amp;lt;fifth &lt;br /&gt;
0.7848088164254446:&amp;lt;seventh &lt;br /&gt;
0.781214400477696:&amp;lt;ravenclaw &lt;br /&gt;
0.7780135594276192:&amp;lt;fourth &lt;br /&gt;
0.7568581966579454:&amp;lt;hufflepuffs &lt;br /&gt;
0.7452088578170768:&amp;lt;slytherin &lt;br /&gt;
0.7329618627066322:&amp;lt;slytherins &lt;br /&gt;
0.7241609971259948:&amp;lt;thursday &lt;br /&gt;
0.7202963910695652:&amp;lt;gryffindors &lt;br /&gt;
&lt;br /&gt;
(256 dimensions : 10 epochs) &lt;br /&gt;
&lt;b&gt;1.0:&amp;lt;hufflepuff&lt;/b&gt; &lt;br /&gt;
0.5732267167869871:&amp;lt;ravenclaw &lt;br /&gt;
0.560598634502152:&amp;lt;slytherin &lt;br /&gt;
0.4581853977277023:&amp;lt;gryffindor &lt;br /&gt;
0.41404169865069024:&amp;lt;points &lt;br /&gt;
0.41335251749481483:&amp;lt;helga &lt;br /&gt;
0.40705600406104697:&amp;lt;pushover &lt;br /&gt;
0.3964490683438199:&amp;lt;applauding &lt;br /&gt;
0.39567843096475613:&amp;lt;loses &lt;br /&gt;
0.39244432848771427:&amp;lt;match &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(64 dimensions : 1 epoch)&lt;br /&gt;
&lt;b&gt;1.0000000000000002:&amp;lt;slytherin&lt;/b&gt; &lt;br /&gt;
0.7512446691492253:&amp;lt;ravenclaw &lt;br /&gt;
0.7452088578170768:&amp;lt;hufflepuff &lt;br /&gt;
0.7238327202395243:&amp;lt;team &lt;br /&gt;
0.7231970430099021:&amp;lt;gryffindor &lt;br /&gt;
0.7165509326427633:&amp;lt;captain &lt;br /&gt;
0.7030698136643037:&amp;lt;bell &lt;br /&gt;
0.6922161358648197:&amp;lt;goal &lt;br /&gt;
0.6914818449404438:&amp;lt;montague &lt;br /&gt;
0.6612854741883617:&amp;lt;pucey &lt;br /&gt;
&lt;br /&gt;
(256 dimensions : 10 epochs) &lt;br /&gt;
&lt;b&gt;1.0:&amp;lt;slytherin&lt;/b&gt; &lt;br /&gt;
0.560598634502152:&amp;lt;hufflepuff &lt;br /&gt;
0.44370546214405354:&amp;lt;slytherins &lt;br /&gt;
0.4410251892894441:&amp;lt;gryffindor &lt;br /&gt;
0.43935832571981465:&amp;lt;ravenclaw &lt;br /&gt;
0.4111100118874837:&amp;lt;team &lt;br /&gt;
0.3960522941982452:&amp;lt;captain &lt;br /&gt;
0.3834171440911241:&amp;lt;gains &lt;br /&gt;
0.3816636526374869:&amp;lt;pushover &lt;br /&gt;
0.37815919943099136:&amp;lt;fen &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(64 dimensions : 1 epoch)&lt;br /&gt;
1.0:&amp;lt;hermione &lt;br /&gt;
&lt;b&gt;0.6373033872867323:&amp;lt;she&lt;/b&gt; &lt;br /&gt;
0.5360344746735539:&amp;lt;neville &lt;br /&gt;
0.5274756001139249:&amp;lt;he &lt;br /&gt;
0.5214301504925287:&amp;lt;ginny &lt;br /&gt;
0.5109574888160943:&amp;lt;ron &lt;br /&gt;
0.4999163834053927:&amp;lt;luna &lt;br /&gt;
0.49574563180394704:&amp;lt;harry &lt;br /&gt;
0.451967913703171:&amp;lt;romilda &lt;br /&gt;
0.446476077232399:&amp;lt;her &lt;br /&gt;
&lt;br /&gt;
(256 dimensions : 10 epochs) &lt;br /&gt;
&lt;b&gt;1.0000000000000002:&lt;/b&gt;&amp;lt;hermione &lt;br /&gt;
0.5042554769286905:&amp;lt;ron &lt;br /&gt;
0.4808255935304602:&amp;lt;she &lt;br /&gt;
0.3717110232643911:&amp;lt;ginny &lt;br /&gt;
0.35913453543144513:&amp;lt;acidly &lt;br /&gt;
0.35306516236363134:&amp;lt;ermyknee &lt;br /&gt;
0.3515929674760651:&amp;lt;encouragingly &lt;br /&gt;
0.35124423149024275:&amp;lt;uhoh &lt;br /&gt;
0.3455436053959502:&amp;lt;grabbing &lt;br /&gt;
0.34365264010683094:&amp;lt;lavender &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(64 dimensions : 1 epoch)&lt;br /&gt;
&lt;b&gt;1.0:&amp;lt;dumbledore&lt;/b&gt; &lt;br /&gt;
0.7867909396010355:&amp;lt;snape &lt;br /&gt;
0.652590036205367:&amp;lt;slughorn &lt;br /&gt;
0.6378681113816113:&amp;lt;voldemort &lt;br /&gt;
0.6120050198022656:&amp;lt;aberforth &lt;br /&gt;
0.6019010767912868:&amp;lt;he &lt;br /&gt;
0.5929735071374835:&amp;lt;scrimgeour &lt;br /&gt;
0.5840436894354705:&amp;lt;sirius &lt;br /&gt;
0.5553253520856778:&amp;lt;dumbledores &lt;br /&gt;
&lt;br /&gt;
(256 dimensions : 10 epochs) &lt;br /&gt;
&lt;b&gt;1.0:&amp;lt;dumbledore&lt;/b&gt; &lt;br /&gt;
0.49688884807669753:&amp;lt;snape &lt;br /&gt;
0.43320641875023586:&amp;lt;fudge &lt;br /&gt;
0.42104734145946027:&amp;lt;voldemort &lt;br /&gt;
0.409769764165034:&amp;lt;corpses &lt;br /&gt;
0.40586327560858065:&amp;lt;lupin &lt;br /&gt;
0.3992514094799346:&amp;lt;dumbledores &lt;br /&gt;
0.3984795966379898:&amp;lt;headmaster &lt;br /&gt;
0.36481567503440565:&amp;lt;devastating &lt;br /&gt;
0.35980117000272555:&amp;lt;riddle &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(64 dimensions : 1 epoch)&lt;br /&gt;
&lt;b&gt;1.0000000000000002:&amp;lt;spell&lt;/b&gt; &lt;br /&gt;
0.5705834288105536:&amp;lt;jinx &lt;br /&gt;
0.5528068188658538:&amp;lt;clear &lt;br /&gt;
0.5308173140619804:&amp;lt;however &lt;br /&gt;
0.5256446406146716:&amp;lt;crumplehorned &lt;br /&gt;
0.5217704552103746:&amp;lt;hit &lt;br /&gt;
0.5214290685798957:&amp;lt;latter &lt;br /&gt;
0.5210853653286843:&amp;lt;sectumsempra &lt;br /&gt;
0.5204984581955842:&amp;lt;dolohov &lt;br /&gt;
0.5172019428367624:&amp;lt;made &lt;br /&gt;
&lt;br /&gt;
(256 dimensions : 10 epochs) &lt;br /&gt;
&lt;b&gt;0.9999999999999999:&amp;lt;spell&lt;/b&gt; &lt;br /&gt;
0.45622019920423756:&amp;lt;spells &lt;br /&gt;
0.38503414331623603:&amp;lt;charm &lt;br /&gt;
0.3744579769148505:&amp;lt;retaliate &lt;br /&gt;
0.3365386087137521:&amp;lt;stunning &lt;br /&gt;
0.31299212123460146:&amp;lt;fourpoint &lt;br /&gt;
0.3047318421865308:&amp;lt;defensive &lt;br /&gt;
0.3018663449722407:&amp;lt;jinx &lt;br /&gt;
0.2986278064898596:&amp;lt;practicing &lt;br /&gt;
0.29811271395978733:&amp;lt;hit &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(64 dimensions : 1 epoch)&lt;br /&gt;
&lt;b&gt;1.0:&amp;lt;chamber&lt;/b&gt; &lt;br /&gt;
0.7516236239509654:&amp;lt;staffroom &lt;br /&gt;
0.7097278407351896:&amp;lt;basilisk &lt;br /&gt;
0.6396829682468098:&amp;lt;secrets &lt;br /&gt;
0.6303229904669257:&amp;lt;messages &lt;br /&gt;
0.6292212718692173:&amp;lt;pages &lt;br /&gt;
0.6255458905896577:&amp;lt;gargoyle &lt;br /&gt;
0.623691053534629:&amp;lt;stage &lt;br /&gt;
0.6189105698380645:&amp;lt;sealed &lt;br /&gt;
0.6165084868604697:&amp;lt;hilt &lt;br /&gt;
&lt;br /&gt;
(256 dimensions : 10 epochs) &lt;br /&gt;
&lt;b&gt;1.0:&amp;lt;chamber&lt;/b&gt; &lt;br /&gt;
0.527350716695893:&amp;lt;secrets &lt;br /&gt;
0.45803538999265264:&amp;lt;forsaken &lt;br /&gt;
0.4509279299021009:&amp;lt;fanciful &lt;br /&gt;
0.3937455721042796:&amp;lt;unseal &lt;br /&gt;
0.3737416685904814:&amp;lt;roosters &lt;br /&gt;
0.35312885285278145:&amp;lt;drawingroom &lt;br /&gt;
0.3358263562408226:&amp;lt;unleash &lt;br /&gt;
0.32925459347667607:&amp;lt;daubed &lt;br /&gt;
0.32405200326296857:&amp;lt;runin &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(128 dimensions : 1 epoch)&lt;br /&gt;
&lt;b&gt;1.0:&amp;lt;black&lt;/b&gt; &lt;br /&gt;
0.7090495706356712:&amp;lt;thick &lt;br /&gt;
0.6825056469408932:&amp;lt;silver &lt;br /&gt;
0.6687549059638025:&amp;lt;white &lt;br /&gt;
0.6671827818068091:&amp;lt;thin &lt;br /&gt;
0.6595272052625423:&amp;lt;green &lt;br /&gt;
0.6559287359085553:&amp;lt;tiny &lt;br /&gt;
0.6520876963925315:&amp;lt;glass &lt;br /&gt;
0.6499197812776186:&amp;lt;bright &lt;br /&gt;
0.6376775975420493:&amp;lt;hair &lt;br /&gt;
&lt;br /&gt;
(256 dimensions : 10 epochs) &lt;br /&gt;
&lt;b&gt;1.0000000000000002:&amp;lt;black&lt;/b&gt; &lt;br /&gt;
0.4187862746289444:&amp;lt;ravaged &lt;br /&gt;
0.41376806599272925:&amp;lt;bald &lt;br /&gt;
0.3964342510912526:&amp;lt;silky &lt;br /&gt;
0.39399279699897416:&amp;lt;stripes &lt;br /&gt;
0.3782092012451359:&amp;lt;broadshouldered &lt;br /&gt;
0.3779053329184092:&amp;lt;graying &lt;br /&gt;
0.37579439331917774:&amp;lt;paleeyed &lt;br /&gt;
0.3734468240600482:&amp;lt;atop &lt;br /&gt;
0.37307859100552243:&amp;lt;leathery &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(128 dimensions : 1 epoch)&lt;br /&gt;
&lt;b&gt;1.0:&amp;lt;requirement&lt;/b&gt; &lt;br /&gt;
0.6805251004125765:&amp;lt;common &lt;br /&gt;
0.58822928078406:&amp;lt;detail &lt;br /&gt;
0.5869718509295418:&amp;lt;gaunts &lt;br /&gt;
0.5677933609626798:&amp;lt;portrait &lt;br /&gt;
0.5612000668830176:&amp;lt;rest &lt;br /&gt;
0.5611572795099765:&amp;lt;space &lt;br /&gt;
0.5554348127278043:&amp;lt;marquee &lt;br /&gt;
0.5519591805530948:&amp;lt;middle &lt;br /&gt;
0.5455370331332081:&amp;lt;slightest &lt;br /&gt;
&lt;br /&gt;
(256 dimensions : 10 epochs) &lt;br /&gt;
&lt;b&gt;0.9999999999999998:&amp;lt;requirement&lt;/b&gt; &lt;br /&gt;
0.4016798211784335:&amp;lt;unknowable &lt;br /&gt;
0.3867069097055046:&amp;lt;jampacked &lt;br /&gt;
0.37050061385790234:&amp;lt;room &lt;br /&gt;
0.3616482568609007:&amp;lt;partlife &lt;br /&gt;
0.3557306897710399:&amp;lt;assaulted &lt;br /&gt;
0.35489547684406436:&amp;lt;compression &lt;br /&gt;
0.33972003944909956:&amp;lt;common &lt;br /&gt;
0.32747964915808203:&amp;lt;upholstery &lt;br /&gt;
0.3205128295096265:&amp;lt;reliving &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(128 dimensions : 1 epoch)&lt;br /&gt;
&lt;b&gt;1.0000000000000002:&amp;lt;voldemort&lt;/b&gt; &lt;br /&gt;
0.6883758949036237:&amp;lt;voldemorts &lt;br /&gt;
0.6882314118148244:&amp;lt;bellatrix &lt;br /&gt;
0.6687046547843726:&amp;lt;sirius &lt;br /&gt;
0.6456113933094144:&amp;lt;dumbledores &lt;br /&gt;
0.6378681113816113:&amp;lt;dumbledore &lt;br /&gt;
0.6198750862701423:&amp;lt;lord &lt;br /&gt;
0.601800677476979:&amp;lt;prophecy &lt;br /&gt;
0.5979378004431092:&amp;lt;connection &lt;br /&gt;
0.5976976164728673:&amp;lt;ariana &lt;br /&gt;
&lt;br /&gt;
(256 dimensions : 10 epochs) &lt;br /&gt;
&lt;b&gt;1.0:&amp;lt;voldemort&lt;/b&gt; &lt;br /&gt;
0.5231034885732724:&amp;lt;lord &lt;br /&gt;
0.4949022273659753:&amp;lt;voldemorts &lt;br /&gt;
0.42104734145946027:&amp;lt;dumbledore &lt;br /&gt;
0.40269571073980126:&amp;lt;kill &lt;br /&gt;
0.39346439983965364:&amp;lt;inindeed &lt;br /&gt;
0.3625195714553203:&amp;lt;snape &lt;br /&gt;
0.36251702487473614:&amp;lt;elm &lt;br /&gt;
0.35635136288239055:&amp;lt;merciful &lt;br /&gt;
0.35450715479438577:&amp;lt;prostrate &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(128 dimensions : 1 epoch)&lt;br /&gt;
&lt;b&gt;1.0:&amp;lt;snape&lt;/b&gt; &lt;br /&gt;
0.7867909396010355:&amp;lt;dumbledore &lt;br /&gt;
0.7602249542226724:&amp;lt;slughorn &lt;br /&gt;
0.6055605238284325:&amp;lt;bellatrix &lt;br /&gt;
0.6030688726296658:&amp;lt;mcgonagall &lt;br /&gt;
0.5929395283735124:&amp;lt;phineas &lt;br /&gt;
0.5913798507548866:&amp;lt;umbridge &lt;br /&gt;
0.5626612723245389:&amp;lt;narcissa &lt;br /&gt;
0.5592886705523973:&amp;lt;horace &lt;br /&gt;
0.5535260402939475:&amp;lt;dumbledores &lt;br /&gt;
&lt;br /&gt;
(256 dimensions : 10 epochs)&lt;br /&gt;
&lt;b&gt;1.0:&amp;lt;snape &lt;/b&gt;&lt;br /&gt;
0.49688884807669753:&amp;lt;dumbledore &lt;br /&gt;
0.39141319194131824:&amp;lt;snapes &lt;br /&gt;
0.3788874389546836:&amp;lt;severus &lt;br /&gt;
0.3625195714553203:&amp;lt;voldemort &lt;br /&gt;
0.3602838216909781:&amp;lt;malfoy &lt;br /&gt;
0.3495411504557353:&amp;lt;mcgonagall &lt;br /&gt;
0.3432543679925834:&amp;lt;heroworshipped &lt;br /&gt;
0.3407031113901212:&amp;lt;silkily &lt;br /&gt;
0.3385766904895776:&amp;lt;bbbut &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(128 dimensions : 1 epoch)&lt;br /&gt;
&lt;b&gt;1.0000000000000002:&amp;lt;password&lt;/b&gt; &lt;br /&gt;
0.6759946677363984:&amp;lt;lady &lt;br /&gt;
0.6260981919566827:&amp;lt;north &lt;br /&gt;
0.6258023922269232:&amp;lt;tower &lt;br /&gt;
0.6253624288287926:&amp;lt;owlery &lt;br /&gt;
0.6189141007115594:&amp;lt;fat &lt;br /&gt;
0.6020323426260975:&amp;lt;afterward &lt;br /&gt;
0.5984440756682315:&amp;lt;waking &lt;br /&gt;
0.5788408987574969:&amp;lt;cave &lt;br /&gt;
0.5730507346420423:&amp;lt;heading &lt;br /&gt;
&lt;br /&gt;
(256 dimensions : 10 epochs) &lt;br /&gt;
&lt;b&gt;1.0:&amp;lt;password&lt;/b&gt; &lt;br /&gt;
0.47446983465719267:&amp;lt;fritters &lt;br /&gt;
0.4712847308362276:&amp;lt;lady &lt;br /&gt;
0.4654321201001382:&amp;lt;banana &lt;br /&gt;
0.4440026686633822:&amp;lt;flibbertigibbet &lt;br /&gt;
0.37558294153078775:&amp;lt;ladys &lt;br /&gt;
0.3705196683435887:&amp;lt;abstinence &lt;br /&gt;
0.36897045258759176:&amp;lt;fat &lt;br /&gt;
0.3470203296601344:&amp;lt;portrait &lt;br /&gt;
0.3172485840936194:&amp;lt;festive &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(128 dimensions : 1 epoch)&lt;br /&gt;
&lt;b&gt;1.0:&amp;lt;chocolate&lt;/b&gt; &lt;br /&gt;
0.7724365211403441:&amp;lt;frog &lt;br /&gt;
0.7337068328667901:&amp;lt;mug &lt;br /&gt;
0.7211389912598347:&amp;lt;squeak &lt;br /&gt;
0.7203372114689538:&amp;lt;mouthful &lt;br /&gt;
0.7123522162102919:&amp;lt;meat &lt;br /&gt;
0.7110375068682293:&amp;lt;male &lt;br /&gt;
0.7029104114344779:&amp;lt;swig &lt;br /&gt;
0.6955470835808224:&amp;lt;drops &lt;br /&gt;
0.6901040539654248:&amp;lt;blew &lt;br /&gt;
&lt;br /&gt;
(256 dimensions : 10 epochs) &lt;br /&gt;
&lt;b&gt;0.9999999999999999:&amp;lt;chocolate &lt;/b&gt;&lt;br /&gt;
0.5475055711590749:&amp;lt;frog &lt;br /&gt;
0.5431921714687046:&amp;lt;frogs &lt;br /&gt;
0.47751803650826924:&amp;lt;cards &lt;br /&gt;
0.45420825957039807:&amp;lt;cakes &lt;br /&gt;
0.43692834317867524:&amp;lt;marmalade &lt;br /&gt;
0.4356386019624927:&amp;lt;tarts &lt;br /&gt;
0.43098893267906485:&amp;lt;abbot &lt;br /&gt;
0.41999201661912083:&amp;lt;chopped &lt;br /&gt;
0.4170767831464866:&amp;lt;pasties &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(128 dimensions : 1 epoch)&lt;br /&gt;
&lt;b&gt;1.0:&amp;lt;phoenix&lt;/b&gt; &lt;br /&gt;
0.6477570284902336:&amp;lt;wizengamot &lt;br /&gt;
0.611456341909926:&amp;lt;order &lt;br /&gt;
0.601307062292621:&amp;lt;recent &lt;br /&gt;
0.5894212574676222:&amp;lt;warlock &lt;br /&gt;
0.5777717037132631:&amp;lt;educational &lt;br /&gt;
0.5672181094594285:&amp;lt;charges &lt;br /&gt;
0.5577200810058244:&amp;lt;mysteries &lt;br /&gt;
0.5560769924913356:&amp;lt;ministers &lt;br /&gt;
0.5528013856762239:&amp;lt;quibbler &lt;br /&gt;
&lt;br /&gt;
(256 dimensions : 10 epochs) &lt;br /&gt;
&lt;b&gt;0.9999999999999998:&amp;lt;phoenix&lt;/b&gt; &lt;br /&gt;
0.44566492530943996:&amp;lt;feather &lt;br /&gt;
0.4307836965454031:&amp;lt;order &lt;br /&gt;
0.41943464449038814:&amp;lt;maple &lt;br /&gt;
0.34291846139813786:&amp;lt;fawkes &lt;br /&gt;
0.33463728125471814:&amp;lt;cuttlebone &lt;br /&gt;
0.3323033150650069:&amp;lt;headquarters &lt;br /&gt;
0.33116604341560135:&amp;lt;brethren &lt;br /&gt;
0.31389382936668453:&amp;lt;tto &lt;br /&gt;
0.305949945529935:&amp;lt;cores &lt;br /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 23 Nov 2014 12:00:00 +0000</pubDate>
        <link>http://localhost:4000/2014/11/23/harry-potter/</link>
        <guid isPermaLink="true">http://localhost:4000/2014/11/23/harry-potter/</guid>
        
        
      </item>
    
      <item>
        <title>Tutorial: when Numpy isn't fast enough...</title>
        <description>&lt;p&gt;&lt;b&gt;Summary:&lt;/b&gt; a demo on how to use fortran/blas libraries under the hood of your python program's vector operations to squeeze out extra speed over Numpy.&lt;/p&gt;

&lt;p&gt;Yesterday, I posted a on how to use Apache Spark with GPUs from a notebook. To my joy, it reached the first page of Hacker News (while serving the Scala community!!!). Using Spark from one of the iPython notebooks has become a real passion of mine... and whereas yesterday I focused on Scala/JVM/GPU operations, today I want to offer a bit up to the scientific Python community. These discoveries are from studying a wonderful codebase by Radim Rehurek called &lt;a href=&quot;https://github.com/piskvorky&quot;&gt;Gensim&lt;/a&gt;... specifically the word2vec implementation. &lt;/p&gt;

&lt;p&gt;You might be wondering why I would cover CPU based speedups following GPU based... and the truth is that sometimes lighter weight optimiations are a better fit... especially when dealing with smaller batches of vectors at a time or when GPUs simply aren't available.&lt;/p&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;Part 1: iPython-Notebook Cython Magic&lt;/h2&gt;

&lt;p&gt;Install &lt;a href=&quot;http://stackoverflow.com/questions/2213551/installing-scipy-with-pip&quot;&gt;Numpy,Scipy&lt;/a&gt;,&lt;a href=&quot;http://brewformulas.org/Gfortran&quot;&gt;GFortran&lt;/a&gt;,&lt;a href=&quot;http://docs.cython.org/src/quickstart/install.html&quot;&gt;Cython&lt;/a&gt;, and &lt;a href=&quot;http://scikit-learn.org/stable/install.html&quot;&gt;scikit-learn&lt;/a&gt; packages. I &lt;i&gt;HIGHLY&lt;/i&gt; recommend sticking to easy_install, brew (apt-get), and pip. In my experience, macports has some real trouble with these packages. Also, of course, you need to have ipython notebook installed for these examples to work, but technically it can work for normal cython too.&lt;/p&gt;

&lt;p&gt;With Cython you'll get the &quot;Cython&quot; magic as well. The following command should work in your notebook.&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;img-responsive&quot; src=&quot;/img/sampleCython.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Notice that you load the cython magic using &quot;%load_ext cythonmagic&quot; and then compile cython using &quot;%%cython&quot; at the top of the cell containing cython code. You can then call your cython functions (or classes... etc) from python. It's a neat system. :) &lt;/p&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;Part 2: Scipy Fortran-Blas in Cython&lt;/h2&gt;

&lt;p&gt;Below you'll see the core code that we need to get our superfast blas operations. After the first few imports, you'll see a &quot;cdef extern from&quot; import from a file called voidptr.h. This file allows us to cast a numpy array to its pointer without copying any data.... a key part of the code. The contents of that file are also below.&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;img-responsive&quot; src=&quot;/img/fasterThanNumpyCode.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/klb3713/sentence2vec/blob/master/voidptr.h&quot;&gt;&lt;b&gt; voidptr.h code on Github&lt;/b&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Next, you'll also see six function types and their implementations. There is a whole suite of these funky-named fortran functions in the &lt;a href=&quot;http://docs.scipy.org/doc/scipy-0.12.0/reference/generated/scipy.linalg.blas.html&quot;&gt;Scipy Blas/Fortran Documentation&lt;/a&gt; I also write a simple dot-product function leveraging the dsdot (double dot product... as opposed to float) called pubDotty.&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;img-responsive&quot; src=&quot;/img/fasterThanNumpyDemo.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In this example, I create two numpy vectors of length 32. (one full of ones and another full of threes). I then benchmark and show how the cython/fortran version is &lt;b&gt;5.8x faster&lt;/b&gt;. It should be noted that this is still passing in a python object... this efficiency gain increases when everything stays in cython for several progressive operations.&lt;/p&gt;
</description>
        <pubDate>Sun, 23 Nov 2014 12:00:00 +0000</pubDate>
        <link>http://localhost:4000/2014/11/23/cython-blas-fortran/</link>
        <guid isPermaLink="true">http://localhost:4000/2014/11/23/cython-blas-fortran/</guid>
        
        
      </item>
    
      <item>
        <title>Tutorial: Spark-GPU Cluster Dev in a Notebook</title>
        <description>&lt;p&gt;Speed, Quality, Dev Time... pick two. This has been an age-old tradeoff in software development. The goal of this blog post is to create a local dev environment for ad-hoc gpu-cluster computing using Apache Spark, iPython Notebook (scala version), and the stock GPU powering your Macbook Pro's display.&lt;/p&gt;

&lt;blockquote&gt;Make it work... then make it fast... then make it beautiful -- Matthew Russell&lt;/blockquote&gt;

&lt;p&gt;In the spirit of my mentor, we will start by getting each part &quot;working&quot; individually. Fortunately, the second part (speed) sortof falls out of the first (GPU clusters are like that). Then, we'll integrate these parts into something beautiful... a scalable, ad-hoc environment.&lt;/p&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;Part 1: Spark-Notebook&lt;/h2&gt;

&lt;p&gt;Apache Spark can be controlled by notebooks from several languages. I'm going with Scala for several reasons. First, it allows me to have access to the full Spark API (Graphx support is a dealbreaker for me). Secondly, the only GPU library that allowed me to compile for the GPU without writing C code myself is in Java (which I can call from scala). Even with these limitations, there were still several to choose from. The options were:&lt;/p&gt;

&lt;p&gt;
&lt;a href=&quot;http://zeppelin-project.org/&quot;&gt;Zeppelin&lt;/a&gt; -&amp;gt; buggy API after I imported classes &lt;br /&gt;
&lt;a href=&quot;https://github.com/andypetrella/spark-notebook&quot;&gt;Spark-Notebook&lt;/a&gt; -&amp;gt; headache to import dependencies &lt;br /&gt;
&lt;a href=&quot;https://github.com/hohonuuli/sparknotebook&quot;&gt;Sparknotebook&lt;/a&gt; -&amp;gt; Winner!!! Killer app. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;After cloning the Sparknotebook repo and following its instructions (downloading the IScala.jar...etc), with a single command I could open the notebook on top of a standalone spark cluster... easy peasy... &lt;/p&gt;

&lt;p&gt;Please go like the REPO... I'd like to see it get some love....&lt;/p&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;Part 2: GPU on the JVM&lt;/h2&gt;

&lt;p&gt;The inspiration for this came from a rather impressive library called &lt;a href=&quot;http://www.scalanlp.org/&quot;&gt;ScalaNLP&lt;/a&gt;. They claimed to have a parser that could parse half a million words per minute on one machine! Given that I work in R&amp;amp;D at a &quot;Big-Data NLP&quot; firm, this peaked my interest. Scalanlp on a 100 node cluster seems.... rather disgustingly awesome.&lt;/p&gt;

&lt;p&gt;ScalaNLP Leverages the java opencl library, &lt;a href=&quot;https://code.google.com/p/javacl/&quot;&gt;JavaCL&lt;/a&gt;. The decision to use OpenCL, as opposed to CUDA, means that the code runs on non-NVIDIA graphics cards. All Apple's can use OpenCL. Therefore, I can prototype on my Macbook's GPU. I like that.... i like that a lot. &lt;/p&gt;

&lt;p&gt;However, what I don't like is writing C code. It slows me down and isn't portable. I need my code to be both enterprise-ready and, &quot;we don't want to buy GPUs&quot; ready. This is where &lt;a href=&quot;https://code.google.com/p/aparapi/&quot;&gt;Aparapi&lt;/a&gt; comes in. It compiles Java code down to OpenCL, and runs it in a Java Thread Pool if a GPU isn't available. Also, it's made by AMD... which means you can trust it. Those guys are total bosses. &lt;a href=&quot;http://www.amd.com/en-us/press-releases/Pages/amd-fx-8370-2014sep02.aspx&quot;&gt;AMD Claims New World Record&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I downloaded the AparaPi Mac OS Zip... although all these are available.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://code.google.com/p/aparapi/downloads/detail?name=Aparapi_2012_01_23_MacOSX_zip&amp;amp;can=2&amp;amp;q=&quot;&gt;Aparapi_2012_01_23_MacOSX_zip&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://code.google.com/p/aparapi/downloads/detail?name=Aparapi_2013_01_23_linux_x86.zip&amp;amp;can=2&amp;amp;q=&quot;&gt;Aparapi_2013_01_23_linux_x86.zip&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://code.google.com/p/aparapi/downloads/detail?name=Aparapi_2013_01_23_windows_x86.zip&amp;amp;can=2&amp;amp;q=&quot;&gt;Aparapi_2013_01_23_windows_x86.zip&lt;/a&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;I unzipped the download into a folder on my machine, and it created a folder called &quot;Aparapi_2012_01_23_MacOSX_zip&quot;. &lt;br /&gt;&lt;br /&gt;
&lt;b&gt;Executions:&lt;/b&gt;
&lt;blockquote&gt;cd Aparapi_2012_01_23_MacOSX_zip/samples/squares/ &lt;br /&gt;
sh squares.sh&lt;/blockquote&gt;
&lt;b&gt;Output Sample:&lt;/b&gt;
&lt;blockquote&gt;Execution mode=GPU&lt;br /&gt;
     0        0 &lt;br /&gt;
     1        1&lt;br /&gt;
     2        4&lt;br /&gt;
     3        9&lt;br /&gt;
     4       16&lt;br /&gt;
     5       25&lt;br /&gt;
     6       36&lt;br /&gt;
     7       49&lt;br /&gt;
     8       64&lt;br /&gt;
     9       81&lt;br /&gt;
    10      100
&lt;/blockquote&gt;&lt;/p&gt;

&lt;p&gt; Wallah! Apparently this java code can run on my Macbook's GPU. Feel free to try a few of the other sample programs... the mandlebrot one is super cool!&lt;/p&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;Part 3: Integrating Spark and Aparapi in the Notebook&lt;/h2&gt;

&lt;p&gt; So, everything so far has simply been a tutorial on &quot;proper tool selection&quot; for the task. The real challenge is in getting these tools to talk to each other. The first integration step we need to do is to import the aparapi jar into the iscala notebook. This can be done using the following command.&lt;/p&gt;
&lt;blockquote&gt;mvn install:install-file -Dfile=aparapi.jar -DgroupId=com.amd.aparapi -DartifactId=aparapi -Dversion=1.0 -Dpackaging=jar&lt;/blockquote&gt;

&lt;p&gt;Furthermore, my ~/.ipython/profile_scala/ipython_config.py  looks like this at the bottom...&lt;/p&gt;

&lt;blockquote&gt;c = get_config() &lt;br /&gt;&lt;br /&gt;

c.KernelManager.kernel_cmd = [&quot;java&quot;,&quot;-Djava.library.path=/Users/.. .../Aparapi_2012_01_23_MacOSX_zip&quot;,&quot;-XX:MaxPermSize=2048m&quot;,&quot;-Xmx8g&quot;, &lt;br /&gt; &quot;-jar&quot;,
                          &quot;/Users/myname/.ipython/profile_scala/lib/IScala.jar&quot;,&quot;/Users/... .../Aparapi_2012_01_23_MacOSX_zip/aparapi.jar&quot;, &lt;br /&gt;
                          &quot;--profile&quot;, &lt;br /&gt;
                          &quot;{connection_file}&quot;, &lt;br /&gt;
                          &quot;--parent&quot;]&lt;/blockquote&gt;
&lt;p&gt;This gets the aparapi jar on our spark cluster classpath.&lt;/p&gt;

&lt;p&gt; One more detail, when you're starting ipython notebook, start it with this command (with your aparapi zip directory path instead of mine). I'll go into this in a minute&lt;/p&gt;
&lt;blockquote&gt;SPARK_DAEMON_JAVA_OPTS=-Xmx8128m SPARK_WORKER_MEMORY=-Xmx2048m SPARK_DAEMON_MEMORY=-Xmx2048m SPARK_REPL_OPTS=-XX:MaxPermSize=2048m SBT_OPTS=-Xmx8128m SPARK_JAVA_OPTS=&quot;-Djava.library.path=/Users/... ..../Aparapi_2012_01_23_MacOSX_zip -Xms512m -Xmx8128m&quot; ipython notebook --profile scala	&lt;/blockquote&gt;

&lt;p&gt;When I deploy the aparapi jar locally, I can then import aparapi like so...&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;img-responsive&quot; src=&quot;/img/ipythonDep.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;caption text-muted&quot;&gt; GPU, iPython Notebooks, and Apache Spark meeting for the very first time ever…. a moment in history.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; Assuming no errors in the &quot;upload&quot; command (scroll to the bottom for a list of any import failures), you should be good to go. Also, notice that I'm using the demo scala notebook from the sparknotebook github. I recommend this to make sure that the notebook is working before you start.&lt;/p&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;Part 4: Example Kernel Built in the Notebook (using Scala only)&lt;/h2&gt;

&lt;p&gt;&lt;img class=&quot;img-responsive&quot; src=&quot;/img/exampleKernel.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;caption text-muted&quot;&gt;Building a kernel and running it… notice the output at the bottom…&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; Notice that i tried to set the kernel to run on the GPU, but because the GPU wasn't available, it switched the version and ran it on the CPU. You might be thinking, &quot;Wait!!! This blog is a hoax!!!&quot;. I got a bit discouraged at this point as well, however, debugging later found out that we cannot compile Scala to GPU code. This is acceptable for prototyping kernels and chaining them together. This will even run in the spark context... so to develop and test your kenels (using the Java Thread Pool fallback), feel free to do it this way. &lt;/p&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;Part 5: Executing GPU Kernel on Spark Cluster&lt;/h2&gt;

&lt;p&gt;Now the moment we've all been waiting for.... earlier when you installed the aparapi jar into maven, you were actually installing the compiled jar including the &quot;Square&quot; sample code. If we crack open the &quot;squares.sh&quot; script we ran earlier, we'll see that it is calling a program in that jar&lt;/p&gt;

&lt;p&gt;&lt;b&gt;squares.sh&lt;/b&gt;&lt;/p&gt;
&lt;blockquote&gt;java \ &lt;br /&gt;
 -Djava.library.path=../.. \ &lt;br /&gt;
 -Dcom.amd.aparapi.executionMode=%1 \ &lt;br /&gt;
 -classpath ../../aparapi.jar:squares.jar \ &lt;br /&gt;
 com.amd.aparapi.sample.squares.Main&lt;/blockquote&gt;

&lt;p&gt;This means that the compiled code is already on our classpath... and we can call it from a spark method like so...&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;img-responsive&quot; src=&quot;/img/gpuInSpark.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;caption text-muted&quot;&gt;Running the kernel in the ipython notebook via spark&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;img-responsive&quot; src=&quot;/img/gpuOutputInTerminal.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;caption text-muted&quot;&gt;The logging of the GPU program… showing that it is indeed being run on the GPU (didn’t fallback to JTP)&lt;/span&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 22 Nov 2014 12:00:00 +0000</pubDate>
        <link>http://localhost:4000/2014/11/22/spark-gpu/</link>
        <guid isPermaLink="true">http://localhost:4000/2014/11/22/spark-gpu/</guid>
        
        
      </item>
    
  </channel>
</rss>
